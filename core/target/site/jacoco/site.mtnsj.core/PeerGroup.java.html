<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PeerGroup.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mtnsj</a> &gt; <a href="index.source.html" class="el_package">site.mtnsj.core</a> &gt; <span class="el_source">PeerGroup.java</span></div><h1>PeerGroup.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Google Inc.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package site.mtnsj.core;

import com.google.common.annotations.*;
import com.google.common.base.*;
import com.google.common.collect.*;
import com.google.common.net.*;
import com.google.common.primitives.*;
import com.google.common.util.concurrent.*;
import com.squareup.okhttp.*;
import com.subgraph.orchid.*;
import net.jcip.annotations.*;
import site.mtnsj.core.listeners.*;
import site.mtnsj.crypto.*;
import site.mtnsj.net.*;
import site.mtnsj.net.discovery.*;
import site.mtnsj.script.*;
import site.mtnsj.utils.*;
import site.mtnsj.utils.Threading;
import site.mtnsj.wallet.Wallet;
import site.mtnsj.wallet.listeners.KeyChainEventListener;
import site.mtnsj.wallet.listeners.ScriptsChangeEventListener;
import site.mtnsj.wallet.listeners.WalletCoinsReceivedEventListener;
import org.slf4j.*;

import javax.annotation.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.*;

import static com.google.common.base.Preconditions.*;

/**
 * &lt;p&gt;Runs a set of connections to the P2P network, brings up connections to replace disconnected nodes and manages
 * the interaction between them all. Most applications will want to use one of these.&lt;/p&gt;
 * 
 * &lt;p&gt;PeerGroup tries to maintain a constant number of connections to a set of distinct peers.
 * Each peer runs a network listener in its own thread.  When a connection is lost, a new peer
 * will be tried after a delay as long as the number of connections less than the maximum.&lt;/p&gt;
 * 
 * &lt;p&gt;Connections are made to addresses from a provided list.  When that list is exhausted,
 * we start again from the head of the list.&lt;/p&gt;
 * 
 * &lt;p&gt;The PeerGroup can broadcast a transaction to the currently connected set of peers.  It can
 * also handle download of the blockchain from peers, restarting the process when peers die.&lt;/p&gt;
 *
 * &lt;p&gt;A PeerGroup won't do anything until you call the {@link PeerGroup#start()} method 
 * which will block until peer discovery is completed and some outbound connections 
 * have been initiated (it will return before handshaking is done, however). 
 * You should call {@link PeerGroup#stop()} when finished. Note that not all methods
 * of PeerGroup are safe to call from a UI thread as some may do network IO, 
 * but starting and stopping the service should be fine.&lt;/p&gt;
 */
public class PeerGroup implements TransactionBroadcaster {
<span class="fc" id="L73">    private static final Logger log = LoggerFactory.getLogger(PeerGroup.class);</span>

    // All members in this class should be marked with final, volatile, @GuardedBy or a mix as appropriate to define
    // their thread safety semantics. Volatile requires a Hungarian-style v prefix.

    // By default we don't require any services because any peer will do.
<span class="fc" id="L79">    private long requiredServices = 0;</span>
    /**
     * The default number of connections to the p2p network the library will try to build. This is set to 12 empirically.
     * It used to be 4, but because we divide the connection pool in two for broadcasting transactions, that meant we
     * were only sending transactions to two peers and sometimes this wasn't reliable enough: transactions wouldn't
     * get through.
     */
    public static final int DEFAULT_CONNECTIONS = 12;
    private static final int TOR_TIMEOUT_SECONDS = 60;
<span class="fc" id="L88">    private volatile int vMaxPeersToDiscoverCount = 100;</span>
    private static final long DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS = 5000;
<span class="fc" id="L90">    private volatile long vPeerDiscoveryTimeoutMillis = DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS;</span>

<span class="fc" id="L92">    protected final ReentrantLock lock = Threading.lock(&quot;peergroup&quot;);</span>

<span class="nc" id="L94">    public ReentrantLock getLock() { return lock; }  //for dash</span>

    protected final NetworkParameters params;
    @Nullable protected final AbstractBlockChain chain;

    // This executor is used to queue up jobs: it's used when we don't want to use locks for mutual exclusion,
    // typically because the job might call in to user provided code that needs/wants the freedom to use the API
    // however it wants, or because a job needs to be ordered relative to other jobs like that.
    protected final ListeningScheduledExecutorService executor;

    // Whether the peer group is currently running. Once shut down it cannot be restarted.
    private volatile boolean vRunning;
    // Whether the peer group has been started or not. An unstarted PG does not try to access the network.
    private volatile boolean vUsedUp;

    // Addresses to try to connect to, excluding active peers.
    @GuardedBy(&quot;lock&quot;) private final PriorityQueue&lt;PeerAddress&gt; inactives;
    @GuardedBy(&quot;lock&quot;) private final Map&lt;PeerAddress, ExponentialBackoff&gt; backoffMap;

    // Currently active peers. This is an ordered list rather than a set to make unit tests predictable.
    private final CopyOnWriteArrayList&lt;Peer&gt; peers;
    // Currently connecting peers.
    private final CopyOnWriteArrayList&lt;Peer&gt; pendingPeers;
    private final ClientConnectionManager channels;
    @Nullable private final TorClient torClient;

    // The peer that has been selected for the purposes of downloading announced data.
    @GuardedBy(&quot;lock&quot;) private Peer downloadPeer;
    // Callback for events related to chain download.
    @Nullable @GuardedBy(&quot;lock&quot;) private PeerDataEventListener downloadListener;
<span class="fc" id="L124">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;BlocksDownloadedEventListener&gt;&gt; peersBlocksDownloadedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;BlocksDownloadedEventListener&gt;&gt;();
<span class="fc" id="L126">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;ChainDownloadStartedEventListener&gt;&gt; peersChainDownloadStartedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;ChainDownloadStartedEventListener&gt;&gt;();
    /** Callbacks for events related to peers connecting */
<span class="fc" id="L129">    protected final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerConnectedEventListener&gt;&gt; peerConnectedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerConnectedEventListener&gt;&gt;();
    /** Callbacks for events related to peer connection/disconnection */
<span class="fc" id="L132">    protected final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerDiscoveredEventListener&gt;&gt; peerDiscoveredEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerDiscoveredEventListener&gt;&gt;();
    /** Callbacks for events related to peers disconnecting */
<span class="fc" id="L135">    protected final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerDisconnectedEventListener&gt;&gt; peerDisconnectedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerDisconnectedEventListener&gt;&gt;();
    /** Callbacks for events related to peer data being received */
<span class="fc" id="L138">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;GetDataEventListener&gt;&gt; peerGetDataEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;GetDataEventListener&gt;&gt;();
<span class="fc" id="L140">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PreMessageReceivedEventListener&gt;&gt; peersPreMessageReceivedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;PreMessageReceivedEventListener&gt;&gt;();
<span class="fc" id="L142">    protected final CopyOnWriteArrayList&lt;ListenerRegistration&lt;OnTransactionBroadcastListener&gt;&gt; peersTransactionBroadastEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;OnTransactionBroadcastListener&gt;&gt;();
    // Peer discovery sources, will be polled occasionally if there aren't enough inactives.
    private final CopyOnWriteArraySet&lt;PeerDiscovery&gt; peerDiscoverers;
    // The version message to use for new connections.
    @GuardedBy(&quot;lock&quot;) private VersionMessage versionMessage;
    // Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
    @GuardedBy(&quot;lock&quot;) private int downloadTxDependencyDepth;
    // How many connections we want to have open at the current time. If we lose connections, we'll try opening more
    // until we reach this count.
    @GuardedBy(&quot;lock&quot;) private int maxConnections;
    // Minimum protocol version we will allow ourselves to connect to: require Bloom filtering.
    private volatile int vMinRequiredProtocolVersion;

    /** How many milliseconds to wait after receiving a pong before sending another ping. */
    public static final long DEFAULT_PING_INTERVAL_MSEC = 2000;
<span class="fc" id="L158">    @GuardedBy(&quot;lock&quot;) private long pingIntervalMsec = DEFAULT_PING_INTERVAL_MSEC;</span>

<span class="fc" id="L160">    @GuardedBy(&quot;lock&quot;) private boolean useLocalhostPeerWhenPossible = true;</span>
<span class="fc" id="L161">    @GuardedBy(&quot;lock&quot;) private boolean ipv6Unreachable = false;</span>

    @GuardedBy(&quot;lock&quot;) private long fastCatchupTimeSecs;
    private final CopyOnWriteArrayList&lt;Wallet&gt; wallets;
    private final CopyOnWriteArrayList&lt;PeerFilterProvider&gt; peerFilterProviders;

    // This event listener is added to every peer. It's here so when we announce transactions via an &quot;inv&quot;, every
    // peer can fetch them.
<span class="fc" id="L169">    private final PeerListener peerListener = new PeerListener();</span>

<span class="fc" id="L171">    private int minBroadcastConnections = CoinDefinition.minBroadcastConnections;</span>
<span class="fc" id="L172">    private final ScriptsChangeEventListener walletScriptEventListener = new ScriptsChangeEventListener() {</span>
        @Override public void onScriptsChanged(Wallet wallet, List&lt;Script&gt; scripts, boolean isAddingScripts) {
<span class="nc" id="L174">            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
<span class="nc" id="L175">        }</span>
    };

<span class="fc" id="L178">    private final KeyChainEventListener walletKeyEventListener = new KeyChainEventListener() {</span>
        @Override public void onKeysAdded(List&lt;ECKey&gt; keys) {
<span class="nc" id="L180">            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
<span class="nc" id="L181">        }</span>
    };

<span class="fc" id="L184">    private final WalletCoinsReceivedEventListener walletCoinsReceivedEventListener = new WalletCoinsReceivedEventListener() {</span>
        @Override
        public void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance) {
            // We received a relevant transaction. We MAY need to recalculate and resend the Bloom filter, but only
            // if we have received a transaction that includes a relevant pay-to-pubkey output.
            //
            // The reason is that pay-to-pubkey outputs, when spent, will not repeat any data we can predict in their
            // inputs. So a remote peer will update the Bloom filter for us when such an output is seen matching the
            // existing filter, so that it includes the tx hash in which the pay-to-pubkey output was observed. Thus
            // the spending transaction will always match (due to the outpoint structure).
            //
            // Unfortunately, whilst this is required for correct sync of the chain in blocks, there are two edge cases.
            //
            // (1) If a wallet receives a relevant, confirmed p2pubkey output that was not broadcast across the network,
            // for example in a coinbase transaction, then the node that's serving us the chain will update its filter
            // but the rest will not. If another transaction then spends it, the other nodes won't match/relay it.
            //
            // (2) If we receive a p2pubkey output broadcast across the network, all currently connected nodes will see
            // it and update their filter themselves, but any newly connected nodes will receive the last filter we
            // calculated, which would not include this transaction.
            //
            // For this reason we check if the transaction contained any relevant pay to pubkeys and force a recalc
            // and possibly retransmit if so. The recalculation process will end up including the tx hash into the
            // filter. In case (1), we need to retransmit the filter to the connected peers. In case (2), we don't
            // and shouldn't, we should just recalculate and cache the new filter for next time.
<span class="nc bnc" id="L209" title="All 2 branches missed.">            for (TransactionOutput output : tx.getOutputs()) {</span>
<span class="nc bnc" id="L210" title="All 4 branches missed.">                if (output.getScriptPubKey().isSentToRawPubKey() &amp;&amp; output.isMine(wallet)) {</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">                    if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING)</span>
<span class="nc" id="L212">                        recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
                    else
<span class="nc" id="L214">                        recalculateFastCatchupAndFilter(FilterRecalculateMode.DONT_SEND);</span>
<span class="nc" id="L215">                    return;</span>
                }
<span class="nc" id="L217">            }</span>
<span class="nc" id="L218">        }</span>
    };

    // Exponential backoff for peers starts at 1 second and maxes at 10 minutes.
<span class="fc" id="L222">    private final ExponentialBackoff.Params peerBackoffParams = new ExponentialBackoff.Params(1000, 1.5f, 10 * 60 * 1000);</span>
    // Tracks failures globally in case of a network failure.
<span class="fc" id="L224">    @GuardedBy(&quot;lock&quot;) private ExponentialBackoff groupBackoff = new ExponentialBackoff(new ExponentialBackoff.Params(1000, 1.5f, 10 * 1000));</span>

    // This is a synchronized set, so it locks on itself. We use it to prevent TransactionBroadcast objects from
    // being garbage collected if nothing in the apps code holds on to them transitively. See the discussion
    // in broadcastTransaction.
    private final Set&lt;TransactionBroadcast&gt; runningBroadcasts;

    private class PeerListener implements GetDataEventListener, BlocksDownloadedEventListener {

<span class="fc" id="L233">        public PeerListener() {</span>
<span class="fc" id="L234">        }</span>

        @Override
        public List&lt;Message&gt; getData(Peer peer, GetDataMessage m) {
<span class="nc" id="L238">            return handleGetData(m);</span>
        }

        @Override
        public void onBlocksDownloaded(Peer peer, Block block, @Nullable FilteredBlock filteredBlock, int blocksLeft) {
<span class="nc bnc" id="L243" title="All 2 branches missed.">            if (chain == null) return;</span>
<span class="nc" id="L244">            final double rate = chain.getFalsePositiveRate();</span>
<span class="nc" id="L245">            final double target = bloomFilterMerger.getBloomFilterFPRate() * MAX_FP_RATE_INCREASE;</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (rate &gt; target) {</span>
                // TODO: Avoid hitting this path if the remote peer didn't acknowledge applying a new filter yet.
<span class="nc bnc" id="L248" title="All 2 branches missed.">                if (log.isDebugEnabled())</span>
<span class="nc" id="L249">                    log.debug(&quot;Force update Bloom filter due to high false positive rate ({} vs {})&quot;, rate, target);</span>
<span class="nc" id="L250">                recalculateFastCatchupAndFilter(FilterRecalculateMode.FORCE_SEND_FOR_REFRESH);</span>
            }
<span class="nc" id="L252">        }</span>
    }

<span class="fc" id="L255">    private class PeerStartupListener implements PeerConnectedEventListener, PeerDisconnectedEventListener {</span>
        @Override
        public void onPeerConnected(Peer peer, int peerCount) {
<span class="nc" id="L258">            handleNewPeer(peer);</span>
<span class="nc" id="L259">        }</span>

        @Override
        public void onPeerDisconnected(Peer peer, int peerCount) {
            // The channel will be automatically removed from channels.
<span class="fc" id="L264">            handlePeerDeath(peer, null);</span>
<span class="fc" id="L265">        }</span>
    }

<span class="fc" id="L268">    private final PeerStartupListener startupListener = new PeerStartupListener();</span>

    /**
     * The default Bloom filter false positive rate, which is selected to be extremely low such that you hardly ever
     * download false positives. This provides maximum performance. Although this default can be overridden to push
     * the FP rate higher, due to &lt;a href=&quot;https://groups.google.com/forum/#!msg/bitcoinj/Ys13qkTwcNg/9qxnhwnkeoIJ&quot;&gt;
     * various complexities&lt;/a&gt; there are still ways a remote peer can deanonymize the users wallet. This is why the
     * FP rate is chosen for performance rather than privacy. If a future version of mtnsj fixes the known
     * de-anonymization attacks this FP rate may rise again (or more likely, become expressed as a bandwidth allowance).
     */
    public static final double DEFAULT_BLOOM_FILTER_FP_RATE = 0.00001;
    /** Maximum increase in FP rate before forced refresh of the bloom filter */
    public static final double MAX_FP_RATE_INCREASE = 10.0f;
    // An object that calculates bloom filters given a list of filter providers, whilst tracking some state useful
    // for privacy purposes.
    private final FilterMerger bloomFilterMerger;

    /** The default timeout between when a connection attempt begins and version message exchange completes */
    public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 5000;
<span class="fc" id="L287">    private volatile int vConnectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT_MILLIS;</span>
    
    /** Whether bloom filter support is enabled when using a non FullPrunedBlockchain*/
<span class="fc" id="L290">    private volatile boolean vBloomFilteringEnabled = true;</span>

    /** See {@link #PeerGroup(Context)} */
    public PeerGroup(NetworkParameters params) {
<span class="fc" id="L294">        this(params, null);</span>
<span class="fc" id="L295">    }</span>

    /**
     * Creates a PeerGroup with the given context. No chain is provided so this node will report its chain height
     * as zero to other peers. This constructor is useful if you just want to explore the network but aren't interested
     * in downloading block data.
     */
    public PeerGroup(Context context) {
<span class="nc" id="L303">        this(context, null);</span>
<span class="nc" id="L304">    }</span>

    /** See {@link #PeerGroup(Context, AbstractBlockChain)} */
    public PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain) {
<span class="fc" id="L308">        this(Context.getOrCreate(params), chain, new NioClientManager());</span>
<span class="fc" id="L309">    }</span>

    /**
     * Creates a PeerGroup for the given context and chain. Blocks will be passed to the chain as they are broadcast
     * and downloaded. This is probably the constructor you want to use.
     */
    public PeerGroup(Context context, @Nullable AbstractBlockChain chain) {
<span class="nc" id="L316">        this(context, chain, new NioClientManager());</span>
<span class="nc" id="L317">    }</span>

    /** See {@link #newWithTor(Context, AbstractBlockChain, TorClient)} */
    public static PeerGroup newWithTor(NetworkParameters params, @Nullable AbstractBlockChain chain, TorClient torClient) throws TimeoutException {
<span class="nc" id="L321">        return newWithTor(Context.getOrCreate(params), chain, torClient);</span>
    }

    /**
     * &lt;p&gt;Creates a PeerGroup that accesses the network via the Tor network. The provided TorClient is used so you can
     * preconfigure it beforehand. It should not have been already started. You can just use &quot;new TorClient()&quot; if
     * you don't have any particular configuration requirements.&lt;/p&gt;
     *
     * &lt;p&gt;Peer discovery is automatically configured to use DNS seeds resolved via a random selection of exit nodes.
     * If running on the Oracle JDK the unlimited strength jurisdiction checks will also be overridden,
     * as they no longer apply anyway and can cause startup failures due to the requirement for AES-256.&lt;/p&gt;
     *
     * &lt;p&gt;The user does not need any additional software for this: it's all pure Java. As of April 2014 &lt;b&gt;this mode
     * is experimental&lt;/b&gt;.&lt;/p&gt;
     *
     * @throws TimeoutException if Tor fails to start within 20 seconds.
     */
    public static PeerGroup newWithTor(Context context, @Nullable AbstractBlockChain chain, TorClient torClient) throws TimeoutException {
<span class="nc" id="L339">        return newWithTor(context, chain, torClient, true);</span>
    }

    /**
     * &lt;p&gt;Creates a PeerGroup that accesses the network via the Tor network. The provided TorClient is used so you can
     * preconfigure it beforehand. It should not have been already started. You can just use &quot;new TorClient()&quot; if
     * you don't have any particular configuration requirements.&lt;/p&gt;
     *
     * &lt;p&gt;If running on the Oracle JDK the unlimited strength jurisdiction checks will also be overridden,
     * as they no longer apply anyway and can cause startup failures due to the requirement for AES-256.&lt;/p&gt;
     *
     * &lt;p&gt;The user does not need any additional software for this: it's all pure Java. As of April 2014 &lt;b&gt;this mode
     * is experimental&lt;/b&gt;.&lt;/p&gt;
     *
     * @param doDiscovery if true, DNS or HTTP peer discovery will be performed via Tor: this is almost always what you want.
     * @throws java.util.concurrent.TimeoutException if Tor fails to start within 20 seconds.
     */
    public static PeerGroup newWithTor(Context context, @Nullable AbstractBlockChain chain, TorClient torClient, boolean doDiscovery) throws TimeoutException {
<span class="nc" id="L357">        checkNotNull(torClient);</span>
<span class="nc" id="L358">        DRMWorkaround.maybeDisableExportControls();</span>
<span class="nc" id="L359">        BlockingClientManager manager = new BlockingClientManager(torClient.getSocketFactory());</span>
<span class="nc" id="L360">        final int CONNECT_TIMEOUT_MSEC = TOR_TIMEOUT_SECONDS * 1000;</span>
<span class="nc" id="L361">        manager.setConnectTimeoutMillis(CONNECT_TIMEOUT_MSEC);</span>
<span class="nc" id="L362">        PeerGroup result = new PeerGroup(context, chain, manager, torClient);</span>
<span class="nc" id="L363">        result.setConnectTimeoutMillis(CONNECT_TIMEOUT_MSEC);</span>

<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (doDiscovery) {</span>
<span class="nc" id="L366">            NetworkParameters params = context.getParams();</span>
<span class="nc" id="L367">            HttpDiscovery.Details[] httpSeeds = params.getHttpSeeds();</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">            if (httpSeeds.length &gt; 0) {</span>
                // Use HTTP discovery when Tor is active and there is a Cartographer seed, for a much needed speed boost.
<span class="nc" id="L370">                OkHttpClient httpClient = new OkHttpClient();</span>
<span class="nc" id="L371">                httpClient.setSocketFactory(torClient.getSocketFactory());</span>
<span class="nc" id="L372">                List&lt;PeerDiscovery&gt; discoveries = Lists.newArrayList();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">                for (HttpDiscovery.Details httpSeed : httpSeeds)</span>
<span class="nc" id="L374">                    discoveries.add(new HttpDiscovery(params, httpSeed, httpClient));</span>
<span class="nc" id="L375">                result.addPeerDiscovery(new MultiplexingDiscovery(params, discoveries));</span>
<span class="nc" id="L376">            } else {</span>
<span class="nc" id="L377">                result.addPeerDiscovery(new TorDiscovery(params, torClient));</span>
            }
        }
<span class="nc" id="L380">        return result;</span>
    }

    /** See {@link #PeerGroup(Context, AbstractBlockChain, ClientConnectionManager)} */
    public PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager) {
<span class="nc" id="L385">        this(Context.getOrCreate(params), chain, connectionManager, null);</span>
<span class="nc" id="L386">    }</span>

    /**
     * Creates a new PeerGroup allowing you to specify the {@link ClientConnectionManager} which is used to create new
     * connections and keep track of existing ones.
     */
    public PeerGroup(Context context, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager) {
<span class="fc" id="L393">        this(context, chain, connectionManager, null);</span>
<span class="fc" id="L394">    }</span>

    /**
     * Creates a new PeerGroup allowing you to specify the {@link ClientConnectionManager} which is used to create new
     * connections and keep track of existing ones.
     */
<span class="fc" id="L400">    private PeerGroup(Context context, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager, @Nullable TorClient torClient) {</span>
<span class="fc" id="L401">        checkNotNull(context);</span>
<span class="fc" id="L402">        this.params = context.getParams();</span>
<span class="fc" id="L403">        this.chain = chain;</span>
<span class="fc" id="L404">        fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();</span>
<span class="fc" id="L405">        wallets = new CopyOnWriteArrayList&lt;Wallet&gt;();</span>
<span class="fc" id="L406">        peerFilterProviders = new CopyOnWriteArrayList&lt;PeerFilterProvider&gt;();</span>
<span class="fc" id="L407">        this.torClient = torClient;</span>

<span class="fc" id="L409">        executor = createPrivateExecutor();</span>

        // This default sentinel value will be overridden by one of two actions:
        //   - adding a peer discovery source sets it to the default
        //   - using connectTo() will increment it by one
<span class="fc" id="L414">        maxConnections = 0;</span>

<span class="pc bpc" id="L416" title="1 of 2 branches missed.">        int height = chain == null ? 0 : chain.getBestChainHeight();</span>
<span class="fc" id="L417">        versionMessage = new VersionMessage(params, height);</span>
        // We never request that the remote node wait for a bloom filter yet, as we have no wallets
<span class="fc" id="L419">        versionMessage.relayTxesBeforeFilter = true;</span>

<span class="fc" id="L421">        downloadTxDependencyDepth = Integer.MAX_VALUE;</span>

<span class="fc" id="L423">        inactives = new PriorityQueue&lt;PeerAddress&gt;(1, new Comparator&lt;PeerAddress&gt;() {</span>
            @SuppressWarnings(&quot;FieldAccessNotGuarded&quot;)   // only called when inactives is accessed, and lock is held then.
            @Override
            public int compare(PeerAddress a, PeerAddress b) {
<span class="fc" id="L427">                checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L428">                int result = backoffMap.get(a).compareTo(backoffMap.get(b));</span>
                // Sort by port if otherwise equals - for testing
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">                if (result == 0)</span>
<span class="fc" id="L431">                    result = Ints.compare(a.getPort(), b.getPort());</span>
<span class="fc" id="L432">                return result;</span>
            }
        });
<span class="fc" id="L435">        backoffMap = new HashMap&lt;PeerAddress, ExponentialBackoff&gt;();</span>
<span class="fc" id="L436">        peers = new CopyOnWriteArrayList&lt;Peer&gt;();</span>
<span class="fc" id="L437">        pendingPeers = new CopyOnWriteArrayList&lt;Peer&gt;();</span>
<span class="fc" id="L438">        channels = connectionManager;</span>
<span class="fc" id="L439">        peerDiscoverers = new CopyOnWriteArraySet&lt;PeerDiscovery&gt;();</span>
<span class="fc" id="L440">        runningBroadcasts = Collections.synchronizedSet(new HashSet&lt;TransactionBroadcast&gt;());</span>
<span class="fc" id="L441">        bloomFilterMerger = new FilterMerger(DEFAULT_BLOOM_FILTER_FP_RATE);</span>

        //DashSpecific


        // todo: check mtns MN..
<span class="fc" id="L447">        context.setPeerGroupAndBlockChain(this, chain);</span>
<span class="fc" id="L448">        vMinRequiredProtocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.MINIMUM);</span>
<span class="fc" id="L449">    }</span>

<span class="fc" id="L451">    private CountDownLatch executorStartupLatch = new CountDownLatch(1);</span>

    protected ListeningScheduledExecutorService createPrivateExecutor() {
<span class="fc" id="L454">        ListeningScheduledExecutorService result = MoreExecutors.listeningDecorator(</span>
                new ScheduledThreadPoolExecutor(1, new ContextPropagatingThreadFactory(&quot;PeerGroup Thread&quot;))
        );
        // Hack: jam the executor so jobs just queue up until the user calls start() on us. For example, adding a wallet
        // results in a bloom filter recalc being queued, but we don't want to do that until we're actually started.
<span class="fc" id="L459">        result.execute(new Runnable() {</span>
            @Override
            public void run() {
<span class="fc" id="L462">                Uninterruptibles.awaitUninterruptibly(executorStartupLatch);</span>
<span class="fc" id="L463">            }</span>
        });
<span class="fc" id="L465">        return result;</span>
    }

    /**
     * This is how many milliseconds we wait for peer discoveries to return their results.
     */
    public void setPeerDiscoveryTimeoutMillis(long peerDiscoveryTimeoutMillis) {
<span class="nc" id="L472">        this.vPeerDiscoveryTimeoutMillis = peerDiscoveryTimeoutMillis;</span>
<span class="nc" id="L473">    }</span>

    /**
     * Adjusts the desired number of connections that we will create to peers. Note that if there are already peers
     * open and the new value is lower than the current number of peers, those connections will be terminated. Likewise
     * if there aren't enough current connections to meet the new requested max size, some will be added.
     */
    public void setMaxConnections(int maxConnections) {
        int adjustment;
<span class="nc" id="L482">        lock.lock();</span>
        try {
<span class="nc" id="L484">            this.maxConnections = maxConnections;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">            if (!isRunning()) return;</span>
        } finally {
<span class="nc" id="L487">            lock.unlock();</span>
<span class="nc" id="L488">        }</span>
        // We may now have too many or too few open connections. Add more or drop some to get to the right amount.
<span class="nc" id="L490">        adjustment = maxConnections - channels.getConnectedClientCount();</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (adjustment &gt; 0)</span>
<span class="nc" id="L492">            triggerConnections();</span>

<span class="nc bnc" id="L494" title="All 2 branches missed.">        if (adjustment &lt; 0)</span>
<span class="nc" id="L495">            channels.closeConnections(-adjustment);</span>
<span class="nc" id="L496">    }</span>

    /**
     * Configure download of pending transaction dependencies. A change of values only takes effect for newly connected
     * peers.
     */
    public void setDownloadTxDependencies(int depth) {
<span class="nc" id="L503">        lock.lock();</span>
        try {
<span class="nc" id="L505">            this.downloadTxDependencyDepth = depth;</span>
        } finally {
<span class="nc" id="L507">            lock.unlock();</span>
<span class="nc" id="L508">        }</span>
<span class="nc" id="L509">    }</span>

<span class="fc" id="L511">    private Runnable triggerConnectionsJob = new Runnable() {</span>
<span class="fc" id="L512">        private boolean firstRun = true;</span>
        private final static long MIN_PEER_DISCOVERY_INTERVAL = 1000L;

        @Override
        public void run() {
            try {
<span class="fc" id="L518">                go();</span>
<span class="nc" id="L519">            } catch (Throwable e) {</span>
<span class="nc" id="L520">                log.error(&quot;Exception when trying to build connections&quot;, e);  // The executor swallows exceptions :(</span>
<span class="fc" id="L521">            }</span>
<span class="fc" id="L522">        }</span>

        public void go() {
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">            if (!vRunning) return;</span>

<span class="fc" id="L527">            boolean doDiscovery = false;</span>
<span class="fc" id="L528">            long now = Utils.currentTimeMillis();</span>
<span class="fc" id="L529">            lock.lock();</span>
            try {
                // First run: try and use a local node if there is one, for the additional security it can provide.
                // But, not on Android as there are none for this platform: it could only be a malicious app trying
                // to hijack our traffic.
<span class="pc bpc" id="L534" title="5 of 8 branches missed.">                if (!Utils.isAndroidRuntime() &amp;&amp; useLocalhostPeerWhenPossible &amp;&amp; maybeCheckForLocalhostPeer() &amp;&amp; firstRun) {</span>
<span class="nc" id="L535">                    log.info(&quot;Localhost peer detected, trying to use it instead of P2P discovery&quot;);</span>
<span class="nc" id="L536">                    maxConnections = 0;</span>
<span class="nc" id="L537">                    connectToLocalHost();</span>
<span class="nc" id="L538">                    return;</span>
                }

<span class="pc bpc" id="L541" title="1 of 4 branches missed.">                boolean havePeerWeCanTry = !inactives.isEmpty() &amp;&amp; backoffMap.get(inactives.peek()).getRetryTime() &lt;= now;</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">                doDiscovery = !havePeerWeCanTry;</span>
            } finally {
<span class="pc" id="L544">                firstRun = false;</span>
<span class="pc" id="L545">                lock.unlock();</span>
<span class="pc" id="L546">            }</span>

            // Don't hold the lock across discovery as this process can be very slow.
<span class="fc" id="L549">            boolean discoverySuccess = false;</span>
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">            if (doDiscovery) {</span>
                try {
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">                    discoverySuccess = discoverPeers() &gt; 0;</span>
<span class="nc" id="L553">                } catch (PeerDiscoveryException e) {</span>
<span class="nc" id="L554">                    log.error(&quot;Peer discovery failure&quot;, e);</span>
<span class="fc" id="L555">                }</span>
            }

            long retryTime;
            PeerAddress addrToTry;
<span class="fc" id="L560">            lock.lock();</span>
            try {
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">                if (doDiscovery) {</span>
                    // Require that we have enough connections, to consider this
                    // a success, or we just constantly test for new peers
<span class="pc bpc" id="L565" title="3 of 4 branches missed.">                    if (discoverySuccess &amp;&amp; countConnectedAndPendingPeers() &gt;= getMaxConnections()) {</span>
<span class="nc" id="L566">                        groupBackoff.trackSuccess();</span>
                    } else {
<span class="fc" id="L568">                        groupBackoff.trackFailure();</span>
                    }
                }
                // Inactives is sorted by backoffMap time.
<span class="fc bfc" id="L572" title="All 2 branches covered.">                if (inactives.isEmpty()) {</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">                    if (countConnectedAndPendingPeers() &lt; getMaxConnections()) {</span>
<span class="nc" id="L574">                        long interval = Math.max(groupBackoff.getRetryTime() - now, MIN_PEER_DISCOVERY_INTERVAL);</span>
<span class="nc" id="L575">                        log.info(&quot;Peer discovery didn't provide us any more peers, will try again in &quot;</span>
                            + interval + &quot;ms.&quot;);
<span class="nc" id="L577">                        executor.schedule(this, interval, TimeUnit.MILLISECONDS);</span>
                    } else {
                        // We have enough peers and discovery provided no more, so just settle down. Most likely we
                        // were given a fixed set of addresses in some test scenario.
                    }
<span class="fc" id="L582">                    return;</span>
                } else {
                    do {
<span class="fc" id="L585">                        addrToTry = inactives.poll();</span>
<span class="pc bpc" id="L586" title="3 of 4 branches missed.">                    } while (ipv6Unreachable &amp;&amp; addrToTry.getAddr() instanceof Inet6Address);</span>
<span class="fc" id="L587">                    retryTime = backoffMap.get(addrToTry).getRetryTime();</span>
                }
<span class="fc" id="L589">                retryTime = Math.max(retryTime, groupBackoff.getRetryTime());</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">                if (retryTime &gt; now) {</span>
<span class="fc" id="L591">                    long delay = retryTime - now;</span>
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">                    log.info(&quot;Waiting {} msec before next connect attempt {}&quot;, delay, addrToTry == null ? &quot;&quot; : &quot;to &quot; + addrToTry);</span>
<span class="fc" id="L593">                    inactives.add(addrToTry);</span>
<span class="fc" id="L594">                    executor.schedule(this, delay, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L595">                    return;</span>
                }
<span class="nc" id="L597">                connectTo(addrToTry, false, vConnectTimeoutMillis);</span>
            } finally {
<span class="pc" id="L599">                lock.unlock();</span>
<span class="nc" id="L600">            }</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">            if (countConnectedAndPendingPeers() &lt; getMaxConnections()) {</span>
<span class="nc" id="L602">                executor.execute(this);   // Try next peer immediately.</span>
            }
<span class="nc" id="L604">        }</span>
    };

    private void triggerConnections() {
        // Run on a background thread due to the need to potentially retry and back off in the background.
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">        if (!executor.isShutdown())</span>
<span class="fc" id="L610">            executor.execute(triggerConnectionsJob);</span>
<span class="fc" id="L611">    }</span>

    /** The maximum number of connections that we will create to peers. */
    public int getMaxConnections() {
<span class="fc" id="L615">        lock.lock();</span>
        try {
<span class="fc" id="L617">            return maxConnections;</span>
        } finally {
<span class="pc" id="L619">            lock.unlock();</span>
<span class="nc" id="L620">        }</span>
    }

    private List&lt;Message&gt; handleGetData(GetDataMessage m) {
        // Scans the wallets and memory pool for transactions in the getdata message and returns them.
        // Runs on peer threads.
<span class="nc" id="L626">        lock.lock();</span>
        try {
<span class="nc" id="L628">            LinkedList&lt;Message&gt; transactions = new LinkedList&lt;Message&gt;();</span>
<span class="nc" id="L629">            LinkedList&lt;InventoryItem&gt; items = new LinkedList&lt;InventoryItem&gt;(m.getItems());</span>
<span class="nc" id="L630">            Iterator&lt;InventoryItem&gt; it = items.iterator();</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc" id="L632">                InventoryItem item = it.next();</span>
                // Check the wallets.
<span class="nc bnc" id="L634" title="All 2 branches missed.">                for (Wallet w : wallets) {</span>
<span class="nc" id="L635">                    Transaction tx = w.getTransaction(item.hash);</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">                    if (tx == null) continue;</span>
<span class="nc" id="L637">                    transactions.add(tx);</span>
<span class="nc" id="L638">                    it.remove();</span>
<span class="nc" id="L639">                    break;</span>
                }
<span class="nc" id="L641">            }</span>
<span class="nc" id="L642">            return transactions;</span>
        } finally {
<span class="nc" id="L644">            lock.unlock();</span>
<span class="nc" id="L645">        }</span>
    }

    /**
     * Sets the {@link VersionMessage} that will be announced on newly created connections. A version message is
     * primarily interesting because it lets you customize the &quot;subVer&quot; field which is used a bit like the User-Agent
     * field from HTTP. It means your client tells the other side what it is, see
     * &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki&quot;&gt;BIP 14&lt;/a&gt;.
     *
     * The VersionMessage you provide is copied and the best chain height/time filled in for each new connection,
     * therefore you don't have to worry about setting that. The provided object is really more of a template.
     */
    public void setVersionMessage(VersionMessage ver) {
<span class="nc" id="L658">        lock.lock();</span>
        try {
<span class="nc" id="L660">            versionMessage = ver;</span>
        } finally {
<span class="nc" id="L662">            lock.unlock();</span>
<span class="nc" id="L663">        }</span>
<span class="nc" id="L664">    }</span>

    /**
     * Returns the version message provided by setVersionMessage or a default if none was given.
     */
    public VersionMessage getVersionMessage() {
<span class="fc" id="L670">        lock.lock();</span>
        try {
<span class="fc" id="L672">            return versionMessage;</span>
        } finally {
<span class="pc" id="L674">            lock.unlock();</span>
<span class="nc" id="L675">        }</span>
    }

    /**
     * Sets information that identifies this software to remote nodes. This is a convenience wrapper for creating 
     * a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     * and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that. See the docs for
     * {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     */
    public void setUserAgent(String name, String version, @Nullable String comments) {
        //TODO Check that height is needed here (it wasnt, but it should be, no?)
<span class="nc bnc" id="L686" title="All 2 branches missed.">        int height = chain == null ? 0 : chain.getBestChainHeight();</span>
<span class="nc" id="L687">        VersionMessage ver = new VersionMessage(params, height);</span>
<span class="nc" id="L688">        ver.relayTxesBeforeFilter = false;</span>
<span class="nc" id="L689">        updateVersionMessageRelayTxesBeforeFilter(ver);</span>
<span class="nc" id="L690">        ver.appendToSubVer(name, version, comments);</span>
<span class="nc" id="L691">        setVersionMessage(ver);</span>
<span class="nc" id="L692">    }</span>
    
    // Updates the relayTxesBeforeFilter flag of ver
    private void updateVersionMessageRelayTxesBeforeFilter(VersionMessage ver) {
        // We will provide the remote node with a bloom filter (ie they shouldn't relay yet)
        // if chain == null || !chain.shouldVerifyTransactions() and a wallet is added and bloom filters are enabled
        // Note that the default here means that no tx invs will be received if no wallet is ever added
<span class="nc" id="L699">        lock.lock();</span>
        try {
<span class="nc bnc" id="L701" title="All 4 branches missed.">            boolean spvMode = chain != null &amp;&amp; !chain.shouldVerifyTransactions();</span>
<span class="nc bnc" id="L702" title="All 6 branches missed.">            boolean willSendFilter = spvMode &amp;&amp; peerFilterProviders.size() &gt; 0 &amp;&amp; vBloomFilteringEnabled;</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">            ver.relayTxesBeforeFilter = !willSendFilter;</span>
        } finally {
<span class="nc" id="L705">            lock.unlock();</span>
<span class="nc" id="L706">        }</span>
<span class="nc" id="L707">    }</span>

    /**
     * Sets information that identifies this software to remote nodes. This is a convenience wrapper for creating
     * a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     * and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that. See the docs for
     * {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     */
    public void setUserAgent(String name, String version) {
<span class="nc" id="L716">        setUserAgent(name, version, null);</span>
<span class="nc" id="L717">    }</span>

    /** Use the more specific listener methods instead */
    @Deprecated @SuppressWarnings(&quot;deprecation&quot;)
    public void addEventListener(AbstractPeerEventListener listener, Executor executor) {
<span class="nc" id="L722">        addBlocksDownloadedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L723">        addChainDownloadStartedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L724">        addConnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L725">        addDisconnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L726">        addDiscoveredEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L727">        addGetDataEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L728">        addOnTransactionBroadcastListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L729">        addPreMessageReceivedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L730">    }</span>

    /** Use the more specific listener methods instead */
    @Deprecated @SuppressWarnings(&quot;deprecation&quot;)
    public void addEventListener(AbstractPeerEventListener listener) {
<span class="nc" id="L735">        addBlocksDownloadedEventListener(executor, listener);</span>
<span class="nc" id="L736">        addChainDownloadStartedEventListener(executor, listener);</span>
<span class="nc" id="L737">        addConnectedEventListener(executor, listener);</span>
<span class="nc" id="L738">        addDisconnectedEventListener(executor, listener);</span>
<span class="nc" id="L739">        addDiscoveredEventListener(executor, listener);</span>
<span class="nc" id="L740">        addGetDataEventListener(executor, listener);</span>
<span class="nc" id="L741">        addOnTransactionBroadcastListener(executor, listener);</span>
<span class="nc" id="L742">        addPreMessageReceivedEventListener(executor, listener);</span>
<span class="nc" id="L743">    }</span>

    /** See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)} */
    public void addBlocksDownloadedEventListener(BlocksDownloadedEventListener listener) {
<span class="nc" id="L747">        addBlocksDownloadedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L748">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when
     * blocks are downloaded by the download peer.&lt;/p&gt;
     * @see Peer#addBlocksDownloadedEventListener(Executor, BlocksDownloadedEventListener)
     */
    public void addBlocksDownloadedEventListener(Executor executor, BlocksDownloadedEventListener listener) {
<span class="nc" id="L756">        peersBlocksDownloadedEventListeners.add(new ListenerRegistration&lt;BlocksDownloadedEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L758">            peer.addBlocksDownloadedEventListener(executor, listener);</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L760">            peer.addBlocksDownloadedEventListener(executor, listener);</span>
<span class="nc" id="L761">    }</span>

    /** See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)} */
    public void addChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener) {
<span class="nc" id="L765">        addChainDownloadStartedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L766">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when
     * chain download starts.&lt;/p&gt;
     */
    public void addChainDownloadStartedEventListener(Executor executor, ChainDownloadStartedEventListener listener) {
<span class="nc" id="L773">        peersChainDownloadStartedEventListeners.add(new ListenerRegistration&lt;ChainDownloadStartedEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L775">            peer.addChainDownloadStartedEventListener(executor, listener);</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L777">            peer.addChainDownloadStartedEventListener(executor, listener);</span>
<span class="nc" id="L778">    }</span>

    /** See {@link Peer#addConnectedEventListener(PeerConnectedEventListener)} */
    public void addConnectedEventListener(PeerConnectedEventListener listener) {
<span class="fc" id="L782">        addConnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L783">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when
     * new peers are connected to.&lt;/p&gt;
     */
    public void addConnectedEventListener(Executor executor, PeerConnectedEventListener listener) {
<span class="fc" id="L790">        peerConnectedEventListeners.add(new ListenerRegistration&lt;PeerConnectedEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L792">            peer.addConnectedEventListener(executor, listener);</span>
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L794">            peer.addConnectedEventListener(executor, listener);</span>
<span class="fc" id="L795">    }</span>

    /** See {@link Peer#addDisconnectedEventListener(PeerDisconnectedEventListener)} */
    public void addDisconnectedEventListener(PeerDisconnectedEventListener listener) {
<span class="nc" id="L799">        addDisconnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L800">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when
     * peers are disconnected from.&lt;/p&gt;
     */
    public void addDisconnectedEventListener(Executor executor, PeerDisconnectedEventListener listener) {
<span class="nc" id="L807">        peerDisconnectedEventListeners.add(new ListenerRegistration&lt;PeerDisconnectedEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L809">            peer.addDisconnectedEventListener(executor, listener);</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L811">            peer.addDisconnectedEventListener(executor, listener);</span>
<span class="nc" id="L812">    }</span>

    /** See {@link Peer#addDiscoveredEventListener(PeerDiscoveredEventListener)} */
    public void addDiscoveredEventListener(PeerDiscoveredEventListener listener) {
<span class="nc" id="L816">        addDiscoveredEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L817">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when new
     * peers are discovered.&lt;/p&gt;
     */
    public void addDiscoveredEventListener(Executor executor, PeerDiscoveredEventListener listener) {
<span class="nc" id="L824">        peerDiscoveredEventListeners.add(new ListenerRegistration&lt;PeerDiscoveredEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="nc" id="L825">    }</span>

    /** See {@link Peer#addGetDataEventListener(GetDataEventListener)} */
    public void addGetDataEventListener(GetDataEventListener listener) {
<span class="nc" id="L829">        addGetDataEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L830">    }</span>

    /** See {@link Peer#addGetDataEventListener(Executor, GetDataEventListener)} */
    public void addGetDataEventListener(final Executor executor, final GetDataEventListener listener) {
<span class="nc" id="L834">        peerGetDataEventListeners.add(new ListenerRegistration&lt;GetDataEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L836">            peer.addGetDataEventListener(executor, listener);</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L838">            peer.addGetDataEventListener(executor, listener);</span>
<span class="nc" id="L839">    }</span>

    /** See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)} */
    public void addOnTransactionBroadcastListener(OnTransactionBroadcastListener listener) {
<span class="nc" id="L843">        addOnTransactionBroadcastListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L844">    }</span>

    /** See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)} */
    public void addOnTransactionBroadcastListener(Executor executor, OnTransactionBroadcastListener listener) {
<span class="nc" id="L848">        peersTransactionBroadastEventListeners.add(new ListenerRegistration&lt;OnTransactionBroadcastListener&gt;(checkNotNull(listener), executor));</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L850">            peer.addOnTransactionBroadcastListener(executor, listener);</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L852">            peer.addOnTransactionBroadcastListener(executor, listener);</span>
<span class="nc" id="L853">    }</span>

    /** See {@link Peer#addPreMessageReceivedEventListener(PreMessageReceivedEventListener)} */
    public void addPreMessageReceivedEventListener(PreMessageReceivedEventListener listener) {
<span class="nc" id="L857">        addPreMessageReceivedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L858">    }</span>

    /** See {@link Peer#addPreMessageReceivedEventListener(Executor, PreMessageReceivedEventListener)} */
    public void addPreMessageReceivedEventListener(Executor executor, PreMessageReceivedEventListener listener) {
<span class="nc" id="L862">        peersPreMessageReceivedEventListeners.add(new ListenerRegistration&lt;PreMessageReceivedEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L864">            peer.addPreMessageReceivedEventListener(executor, listener);</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L866">            peer.addPreMessageReceivedEventListener(executor, listener);</span>
<span class="nc" id="L867">    }</span>

    /** Use the more specific listener methods instead */
    @Deprecated @SuppressWarnings(&quot;deprecation&quot;)
    public void removeEventListener(AbstractPeerEventListener listener) {
<span class="nc" id="L872">        removeBlocksDownloadedEventListener(listener);</span>
<span class="nc" id="L873">        removeChainDownloadStartedEventListener(listener);</span>
<span class="nc" id="L874">        removeConnectedEventListener(listener);</span>
<span class="nc" id="L875">        removeDisconnectedEventListener(listener);</span>
<span class="nc" id="L876">        removeDiscoveredEventListener(listener);</span>
<span class="nc" id="L877">        removeGetDataEventListener(listener);</span>
<span class="nc" id="L878">        removeOnTransactionBroadcastListener(listener);</span>
<span class="nc" id="L879">        removePreMessageReceivedEventListener(listener);</span>
<span class="nc" id="L880">    }</span>

    public boolean removeBlocksDownloadedEventListener(BlocksDownloadedEventListener listener) {
<span class="nc" id="L883">        boolean result = ListenerRegistration.removeFromList(listener, peersBlocksDownloadedEventListeners);</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L885">            peer.removeBlocksDownloadedEventListener(listener);</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L887">            peer.removeBlocksDownloadedEventListener(listener);</span>
<span class="nc" id="L888">        return result;</span>
    }

    public boolean removeChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener) {
<span class="nc" id="L892">        boolean result = ListenerRegistration.removeFromList(listener, peersChainDownloadStartedEventListeners);</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L894">            peer.removeChainDownloadStartedEventListener(listener);</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L896">            peer.removeChainDownloadStartedEventListener(listener);</span>
<span class="nc" id="L897">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeConnectedEventListener(PeerConnectedEventListener listener) {
<span class="nc" id="L902">        boolean result = ListenerRegistration.removeFromList(listener, peerConnectedEventListeners);</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L904">            peer.removeConnectedEventListener(listener);</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L906">            peer.removeConnectedEventListener(listener);</span>
<span class="nc" id="L907">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeDisconnectedEventListener(PeerDisconnectedEventListener listener) {
<span class="nc" id="L912">        boolean result = ListenerRegistration.removeFromList(listener, peerDisconnectedEventListeners);</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L914">            peer.removeDisconnectedEventListener(listener);</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L916">            peer.removeDisconnectedEventListener(listener);</span>
<span class="nc" id="L917">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeDiscoveredEventListener(PeerDiscoveredEventListener listener) {
<span class="nc" id="L922">        boolean result = ListenerRegistration.removeFromList(listener, peerDiscoveredEventListeners);</span>
<span class="nc" id="L923">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeGetDataEventListener(GetDataEventListener listener) {
<span class="nc" id="L928">        boolean result = ListenerRegistration.removeFromList(listener, peerGetDataEventListeners);</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L930">            peer.removeGetDataEventListener(listener);</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L932">            peer.removeGetDataEventListener(listener);</span>
<span class="nc" id="L933">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeOnTransactionBroadcastListener(OnTransactionBroadcastListener listener) {
<span class="nc" id="L938">        boolean result = ListenerRegistration.removeFromList(listener, peersTransactionBroadastEventListeners);</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L940">            peer.removeOnTransactionBroadcastListener(listener);</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L942">            peer.removeOnTransactionBroadcastListener(listener);</span>
<span class="nc" id="L943">        return result;</span>
    }

    public boolean removePreMessageReceivedEventListener(PreMessageReceivedEventListener listener) {
<span class="nc" id="L947">        boolean result = ListenerRegistration.removeFromList(listener, peersPreMessageReceivedEventListeners);</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L949">            peer.removePreMessageReceivedEventListener(listener);</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L951">            peer.removePreMessageReceivedEventListener(listener);</span>
<span class="nc" id="L952">        return result;</span>
    }

    /**
     * Returns a newly allocated list containing the currently connected peers. If all you care about is the count,
     * use numConnectedPeers().
     */
    public List&lt;Peer&gt; getConnectedPeers() {
<span class="fc" id="L960">        lock.lock();</span>
        try {
<span class="fc" id="L962">            return new ArrayList&lt;Peer&gt;(peers);</span>
        } finally {
<span class="pc" id="L964">            lock.unlock();</span>
<span class="nc" id="L965">        }</span>
    }

    /**
     * Returns a list containing Peers that did not complete connection yet.
     */
    public List&lt;Peer&gt; getPendingPeers() {
<span class="fc" id="L972">        lock.lock();</span>
        try {
<span class="fc" id="L974">            return new ArrayList&lt;Peer&gt;(pendingPeers);</span>
        } finally {
<span class="pc" id="L976">            lock.unlock();</span>
<span class="nc" id="L977">        }</span>
    }

    /**
     * Add an address to the list of potential peers to connect to. It won't necessarily be used unless there's a need
     * to build new connections to reach the max connection count.
     *
     * @param peerAddress IP/port to use.
     */
    public void addAddress(PeerAddress peerAddress) {
        int newMax;
<span class="nc" id="L988">        lock.lock();</span>
        try {
<span class="nc" id="L990">            addInactive(peerAddress);</span>
<span class="nc" id="L991">            newMax = getMaxConnections() + 1;</span>
        } finally {
<span class="nc" id="L993">            lock.unlock();</span>
<span class="nc" id="L994">        }</span>
<span class="nc" id="L995">        setMaxConnections(newMax);</span>
<span class="nc" id="L996">    }</span>

    private void addInactive(PeerAddress peerAddress) {
<span class="nc" id="L999">        lock.lock();</span>
        try {
            // Deduplicate
<span class="nc bnc" id="L1002" title="All 2 branches missed.">            if (backoffMap.containsKey(peerAddress))</span>
<span class="nc" id="L1003">                return;</span>
<span class="nc" id="L1004">            backoffMap.put(peerAddress, new ExponentialBackoff(peerBackoffParams));</span>
<span class="nc" id="L1005">            inactives.offer(peerAddress);</span>
        } finally {
<span class="nc" id="L1007">            lock.unlock();</span>
<span class="nc" id="L1008">        }</span>
<span class="nc" id="L1009">    }</span>

    /**
     * Convenience for connecting only to peers that can serve specific services. It will configure suitable peer
     * discoveries.
     * @param requiredServices Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     */
    public void setRequiredServices(long requiredServices) {
<span class="nc" id="L1017">        lock.lock();</span>
        try {
<span class="nc" id="L1019">            this.requiredServices = requiredServices;</span>
<span class="nc" id="L1020">            peerDiscoverers.clear();</span>
<span class="nc" id="L1021">            addPeerDiscovery(MultiplexingDiscovery.forServices(params, requiredServices));</span>
        } finally {
<span class="nc" id="L1023">            lock.unlock();</span>
<span class="nc" id="L1024">        }</span>
<span class="nc" id="L1025">    }</span>

    /** Convenience method for addAddress(new PeerAddress(address, params.port)); */
    public void addAddress(InetAddress address) {
<span class="nc" id="L1029">        addAddress(new PeerAddress(params, address, params.getPort()));</span>
<span class="nc" id="L1030">    }</span>

    /**
     * Add addresses from a discovery source to the list of potential peers to connect to. If max connections has not
     * been configured, or set to zero, then it's set to the default at this point.
     */
    public void addPeerDiscovery(PeerDiscovery peerDiscovery) {
<span class="nc" id="L1037">        lock.lock();</span>
        try {
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            if (getMaxConnections() == 0)</span>
<span class="nc" id="L1040">                setMaxConnections(DEFAULT_CONNECTIONS);</span>
<span class="nc" id="L1041">            peerDiscoverers.add(peerDiscovery);</span>
        } finally {
<span class="nc" id="L1043">            lock.unlock();</span>
<span class="nc" id="L1044">        }</span>
<span class="nc" id="L1045">    }</span>

    /** Returns number of discovered peers. */
    protected int discoverPeers() throws PeerDiscoveryException {
        // Don't hold the lock whilst doing peer discovery: it can take a long time and cause high API latency.
<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">        checkState(!lock.isHeldByCurrentThread());</span>
<span class="fc" id="L1051">        int maxPeersToDiscoverCount = this.vMaxPeersToDiscoverCount;</span>
<span class="fc" id="L1052">        long peerDiscoveryTimeoutMillis = this.vPeerDiscoveryTimeoutMillis;</span>
<span class="fc" id="L1053">        final Stopwatch watch = Stopwatch.createStarted();</span>
<span class="fc" id="L1054">        final List&lt;PeerAddress&gt; addressList = Lists.newLinkedList();</span>
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">        for (PeerDiscovery peerDiscovery : peerDiscoverers /* COW */) {</span>
            InetSocketAddress[] addresses;
<span class="nc" id="L1057">            addresses = peerDiscovery.getPeers(requiredServices, peerDiscoveryTimeoutMillis, TimeUnit.MILLISECONDS);</span>
<span class="nc bnc" id="L1058" title="All 2 branches missed.">            for (InetSocketAddress address : addresses) addressList.add(new PeerAddress(params, address));</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">            if (addressList.size() &gt;= maxPeersToDiscoverCount) break;</span>
<span class="nc" id="L1060">        }</span>
<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">        if (!addressList.isEmpty()) {</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">            for (PeerAddress address : addressList) {</span>
<span class="nc" id="L1063">                addInactive(address);</span>
<span class="nc" id="L1064">            }</span>
<span class="nc" id="L1065">            final ImmutableSet&lt;PeerAddress&gt; peersDiscoveredSet = ImmutableSet.copyOf(addressList);</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">            for (final ListenerRegistration&lt;PeerDiscoveredEventListener&gt; registration : peerDiscoveredEventListeners /* COW */) {</span>
<span class="nc" id="L1067">                registration.executor.execute(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="nc" id="L1070">                        registration.listener.onPeersDiscovered(peersDiscoveredSet);</span>
<span class="nc" id="L1071">                    }</span>
                });
<span class="nc" id="L1073">            }</span>
        }
<span class="fc" id="L1075">        watch.stop();</span>
<span class="fc" id="L1076">        log.info(&quot;Peer discovery took {} and returned {} items&quot;, watch, addressList.size());</span>
<span class="fc" id="L1077">        return addressList.size();</span>
    }

    @VisibleForTesting
    void waitForJobQueue() {
<span class="nc" id="L1082">        Futures.getUnchecked(executor.submit(Runnables.doNothing()));</span>
<span class="nc" id="L1083">    }</span>

    private int countConnectedAndPendingPeers() {
<span class="fc" id="L1086">        lock.lock();</span>
        try {
<span class="fc" id="L1088">            return peers.size() + pendingPeers.size();</span>
        } finally {
<span class="pc" id="L1090">            lock.unlock();</span>
<span class="nc" id="L1091">        }</span>
    }

<span class="pc" id="L1094">    private enum LocalhostCheckState {</span>
<span class="fc" id="L1095">        NOT_TRIED,</span>
<span class="fc" id="L1096">        FOUND,</span>
<span class="fc" id="L1097">        FOUND_AND_CONNECTED,</span>
<span class="fc" id="L1098">        NOT_THERE</span>
    }
<span class="fc" id="L1100">    private LocalhostCheckState localhostCheckState = LocalhostCheckState.NOT_TRIED;</span>

    private boolean maybeCheckForLocalhostPeer() {
<span class="fc" id="L1103">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc bfc" id="L1104" title="All 2 branches covered.">        if (localhostCheckState == LocalhostCheckState.NOT_TRIED) {</span>
            // Do a fast blocking connect to see if anything is listening.
<span class="fc" id="L1106">            Socket socket = null;</span>
            try {
<span class="fc" id="L1108">                socket = new Socket();</span>
<span class="nc" id="L1109">                socket.connect(new InetSocketAddress(InetAddresses.forString(&quot;127.0.0.1&quot;), params.getPort()), vConnectTimeoutMillis);</span>
<span class="nc" id="L1110">                localhostCheckState = LocalhostCheckState.FOUND;</span>
<span class="nc" id="L1111">                return true;</span>
<span class="fc" id="L1112">            } catch (IOException e) {</span>
<span class="fc" id="L1113">                log.info(&quot;Localhost peer not detected.&quot;);</span>
<span class="fc" id="L1114">                localhostCheckState = LocalhostCheckState.NOT_THERE;</span>
            } finally {
<span class="pc bpc" id="L1116" title="5 of 6 branches missed.">                if (socket != null) {</span>
                    try {
<span class="pc" id="L1118">                        socket.close();</span>
<span class="nc" id="L1119">                    } catch (IOException e) {</span>
                        // Ignore.
<span class="pc" id="L1121">                    }</span>
                }
<span class="nc" id="L1123">            }</span>
        }
<span class="fc" id="L1125">        return false;</span>
    }

    /**
     * Starts the PeerGroup and begins network activity.
     * @return A future that completes when first connection activity has been triggered (note: not first connection made).
     */
    public ListenableFuture startAsync() {
        // This is run in a background thread by the Service implementation.
<span class="pc bpc" id="L1134" title="1 of 2 branches missed.">        if (chain == null) {</span>
            // Just try to help catch what might be a programming error.
<span class="fc" id="L1136">            log.warn(&quot;Starting up with no attached block chain. Did you forget to pass one to the constructor?&quot;);</span>
        }
<span class="pc bpc" id="L1138" title="1 of 2 branches missed.">        checkState(!vUsedUp, &quot;Cannot start a peer group twice&quot;);</span>
<span class="fc" id="L1139">        vRunning = true;</span>
<span class="fc" id="L1140">        vUsedUp = true;</span>
<span class="fc" id="L1141">        executorStartupLatch.countDown();</span>
        // We do blocking waits during startup, so run on the executor thread.
<span class="fc" id="L1143">        return executor.submit(new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="fc" id="L1147">                    log.info(&quot;Starting ...&quot;);</span>
<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">                    if (torClient != null) {</span>
<span class="nc" id="L1149">                        log.info(&quot;Starting Tor/Orchid ...&quot;);</span>
<span class="nc" id="L1150">                        torClient.start();</span>
                        try {
<span class="nc" id="L1152">                            torClient.waitUntilReady(TOR_TIMEOUT_SECONDS * 1000);</span>
<span class="nc" id="L1153">                        } catch (Exception e) {</span>
<span class="nc" id="L1154">                            throw new RuntimeException(e);</span>
<span class="nc" id="L1155">                        }</span>
<span class="nc" id="L1156">                        log.info(&quot;Tor ready&quot;);</span>
                    }
<span class="fc" id="L1158">                    channels.startAsync();</span>
<span class="fc" id="L1159">                    channels.awaitRunning();</span>
<span class="fc" id="L1160">                    triggerConnections();</span>
<span class="fc" id="L1161">                    setupPinging();</span>
<span class="nc" id="L1162">                } catch (Throwable e) {</span>
<span class="nc" id="L1163">                    log.error(&quot;Exception when starting up&quot;, e);  // The executor swallows exceptions :(</span>
<span class="fc" id="L1164">                }</span>
<span class="fc" id="L1165">            }</span>
        });
    }

    /** Does a blocking startup. */
    public void start() {
<span class="fc" id="L1171">        Futures.getUnchecked(startAsync());</span>
<span class="fc" id="L1172">    }</span>

    /** Can just use start() for a blocking start here instead of startAsync/awaitRunning: PeerGroup is no longer a Guava service. */
    @Deprecated
    public void awaitRunning() {
<span class="nc" id="L1177">        waitForJobQueue();</span>
<span class="nc" id="L1178">    }</span>

    public ListenableFuture stopAsync() {
<span class="nc" id="L1181">        checkState(vRunning);</span>
<span class="nc" id="L1182">        vRunning = false;</span>
<span class="nc" id="L1183">        ListenableFuture future = executor.submit(new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="nc" id="L1187">                    log.info(&quot;Stopping ...&quot;);</span>
                    // Blocking close of all sockets.
<span class="nc" id="L1189">                    channels.stopAsync();</span>
<span class="nc" id="L1190">                    channels.awaitTerminated();</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">                    for (PeerDiscovery peerDiscovery : peerDiscoverers) {</span>
<span class="nc" id="L1192">                        peerDiscovery.shutdown();</span>
<span class="nc" id="L1193">                    }</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">                    if (torClient != null) {</span>
<span class="nc" id="L1195">                        torClient.stop();</span>
                    }
<span class="nc" id="L1197">                    vRunning = false;</span>
<span class="nc" id="L1198">                    log.info(&quot;Stopped.&quot;);</span>
<span class="nc" id="L1199">                } catch (Throwable e) {</span>
<span class="nc" id="L1200">                    log.error(&quot;Exception when shutting down&quot;, e);  // The executor swallows exceptions :(</span>
<span class="nc" id="L1201">                }</span>
<span class="nc" id="L1202">            }</span>
        });
<span class="nc" id="L1204">        executor.shutdown();</span>
<span class="nc" id="L1205">        return future;</span>
    }

    /** Does a blocking stop */
    public void stop() {
        try {
<span class="nc" id="L1211">            stopAsync();</span>
<span class="nc" id="L1212">            log.info(&quot;Awaiting PeerGroup shutdown ...&quot;);</span>
<span class="nc" id="L1213">            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</span>
<span class="nc" id="L1214">        } catch (InterruptedException e) {</span>
<span class="nc" id="L1215">            throw new RuntimeException(e);</span>
<span class="nc" id="L1216">        }</span>
<span class="nc" id="L1217">    }</span>

    /** Can just use stop() here instead of stopAsync/awaitTerminated: PeerGroup is no longer a Guava service. */
    @Deprecated
    public void awaitTerminated() {
        try {
<span class="nc" id="L1223">            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</span>
<span class="nc" id="L1224">        } catch (InterruptedException e) {</span>
<span class="nc" id="L1225">            throw new RuntimeException(e);</span>
<span class="nc" id="L1226">        }</span>
<span class="nc" id="L1227">    }</span>

    /**
     * &lt;p&gt;Link the given wallet to this PeerGroup. This is used for three purposes:&lt;/p&gt;
     *
     * &lt;ol&gt;
     *   &lt;li&gt;So the wallet receives broadcast transactions.&lt;/li&gt;
     *   &lt;li&gt;Announcing pending transactions that didn't get into the chain yet to our peers.&lt;/li&gt;
     *   &lt;li&gt;Set the fast catchup time using {@link PeerGroup#setFastCatchupTimeSecs(long)}, to optimize chain
     *       download.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;Note that this should be done before chain download commences because if you add a wallet with keys earlier
     * than the current chain head, the relevant parts of the chain won't be redownloaded for you.&lt;/p&gt;
     *
     * &lt;p&gt;The Wallet will have an event listener registered on it, so to avoid leaks remember to use
     * {@link PeerGroup#removeWallet(Wallet)} on it if you wish to keep the Wallet but lose the PeerGroup.&lt;/p&gt;
     */
    public void addWallet(Wallet wallet) {
<span class="nc" id="L1246">        lock.lock();</span>
        try {
<span class="nc" id="L1248">            checkNotNull(wallet);</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">            checkState(!wallets.contains(wallet));</span>
<span class="nc" id="L1250">            wallets.add(wallet);</span>
<span class="nc" id="L1251">            wallet.setTransactionBroadcaster(this);</span>
<span class="nc" id="L1252">            wallet.addCoinsReceivedEventListener(Threading.SAME_THREAD, walletCoinsReceivedEventListener);</span>
<span class="nc" id="L1253">            wallet.addKeyChainEventListener(Threading.SAME_THREAD, walletKeyEventListener);</span>
<span class="nc" id="L1254">            wallet.addScriptChangeEventListener(Threading.SAME_THREAD, walletScriptEventListener);</span>
<span class="nc" id="L1255">            addPeerFilterProvider(wallet);</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">            for (Peer peer : peers) {</span>
<span class="nc" id="L1257">                peer.addWallet(wallet);</span>
<span class="nc" id="L1258">            }</span>
        } finally {
<span class="nc" id="L1260">            lock.unlock();</span>
<span class="nc" id="L1261">        }</span>
<span class="nc" id="L1262">    }</span>

    /**
     * &lt;p&gt;Link the given PeerFilterProvider to this PeerGroup. DO NOT use this for Wallets, use
     * {@link PeerGroup#addWallet(Wallet)} instead.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this should be done before chain download commences because if you add a listener with keys earlier
     * than the current chain head, the relevant parts of the chain won't be redownloaded for you.&lt;/p&gt;
     *
     * &lt;p&gt;This method invokes {@link PeerGroup#recalculateFastCatchupAndFilter(FilterRecalculateMode)}.
     * The return value of this method is the &lt;code&gt;ListenableFuture&lt;/code&gt; returned by that invocation.&lt;/p&gt;
     *
     * @return a future that completes once each &lt;code&gt;Peer&lt;/code&gt; in this group has had its
     *         &lt;code&gt;BloomFilter&lt;/code&gt; (re)set.
     */
    public ListenableFuture&lt;BloomFilter&gt; addPeerFilterProvider(PeerFilterProvider provider) {
<span class="nc" id="L1278">        lock.lock();</span>
        try {
<span class="nc" id="L1280">            checkNotNull(provider);</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">            checkState(!peerFilterProviders.contains(provider));</span>
            // Insert provider at the start. This avoids various concurrency problems that could occur because we need
            // all providers to be in a consistent, unchanging state whilst the filter is built. Providers can give
            // this guarantee by taking a lock in their begin method, but if we add to the end of the list here, it
            // means we establish a lock ordering a &gt; b &gt; c if that's the order the providers were added in. Given that
            // the main wallet will usually be first, this establishes an ordering wallet &gt; other-provider, which means
            // other-provider can then not call into the wallet itself. Other providers installed by the API user should
            // come first so the expected ordering is preserved. This can also manifest itself in providers that use
            // synchronous RPCs into an actor instead of locking, but the same issue applies.
<span class="nc" id="L1290">            peerFilterProviders.add(0, provider);</span>

            // Don't bother downloading block bodies before the oldest keys in all our wallets. Make sure we recalculate
            // if a key is added. Of course, by then we may have downloaded the chain already. Ideally adding keys would
            // automatically rewind the block chain and redownload the blocks to find transactions relevant to those keys,
            // all transparently and in the background. But we are a long way from that yet.
<span class="nc" id="L1296">            ListenableFuture&lt;BloomFilter&gt; future = recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
<span class="nc" id="L1297">            updateVersionMessageRelayTxesBeforeFilter(getVersionMessage());</span>
<span class="nc" id="L1298">            return future;</span>
        } finally {
<span class="nc" id="L1300">            lock.unlock();</span>
<span class="nc" id="L1301">        }</span>
    }

    /**
     * Opposite of {@link #addPeerFilterProvider(PeerFilterProvider)}. Again, don't use this for wallets. Does not
     * trigger recalculation of the filter.
     */
    public void removePeerFilterProvider(PeerFilterProvider provider) {
<span class="nc" id="L1309">        lock.lock();</span>
        try {
<span class="nc" id="L1311">            checkNotNull(provider);</span>
<span class="nc" id="L1312">            checkArgument(peerFilterProviders.remove(provider));</span>
        } finally {
<span class="nc" id="L1314">            lock.unlock();</span>
<span class="nc" id="L1315">        }</span>
<span class="nc" id="L1316">    }</span>

    /**
     * Unlinks the given wallet so it no longer receives broadcast transactions or has its transactions announced.
     */
    public void removeWallet(Wallet wallet) {
<span class="nc" id="L1322">        wallets.remove(checkNotNull(wallet));</span>
<span class="nc" id="L1323">        peerFilterProviders.remove(wallet);</span>
<span class="nc" id="L1324">        wallet.removeCoinsReceivedEventListener(walletCoinsReceivedEventListener);</span>
<span class="nc" id="L1325">        wallet.removeKeyChainEventListener(walletKeyEventListener);</span>
<span class="nc" id="L1326">        wallet.removeScriptChangeEventListener(walletScriptEventListener);</span>
<span class="nc" id="L1327">        wallet.setTransactionBroadcaster(null);</span>
<span class="nc bnc" id="L1328" title="All 2 branches missed.">        for (Peer peer : peers) {</span>
<span class="nc" id="L1329">            peer.removeWallet(wallet);</span>
<span class="nc" id="L1330">        }        </span>
<span class="nc" id="L1331">    }</span>

<span class="nc" id="L1333">    public enum FilterRecalculateMode {</span>
<span class="nc" id="L1334">        SEND_IF_CHANGED,</span>
<span class="nc" id="L1335">        FORCE_SEND_FOR_REFRESH,</span>
<span class="nc" id="L1336">        DONT_SEND,</span>
    }

<span class="fc" id="L1339">    private final Map&lt;FilterRecalculateMode, SettableFuture&lt;BloomFilter&gt;&gt; inFlightRecalculations = Maps.newHashMap();</span>

    /**
     * Recalculates the bloom filter given to peers as well as the timestamp after which full blocks are downloaded
     * (instead of only headers). Note that calls made one after another may return the same future, if the request
     * wasn't processed yet (i.e. calls are deduplicated).
     *
     * @param mode In what situations to send the filter to connected peers.
     * @return a future that completes once the filter has been calculated (note: this does not mean acknowledged by remote peers).
     */
    public ListenableFuture&lt;BloomFilter&gt; recalculateFastCatchupAndFilter(final FilterRecalculateMode mode) {
<span class="nc" id="L1350">        final SettableFuture&lt;BloomFilter&gt; future = SettableFuture.create();</span>
<span class="nc" id="L1351">        synchronized (inFlightRecalculations) {</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">            if (inFlightRecalculations.get(mode) != null)</span>
<span class="nc" id="L1353">                return inFlightRecalculations.get(mode);</span>
<span class="nc" id="L1354">            inFlightRecalculations.put(mode, future);</span>
<span class="nc" id="L1355">        }</span>
<span class="nc" id="L1356">        Runnable command = new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="nc" id="L1360">                    go();</span>
<span class="nc" id="L1361">                } catch (Throwable e) {</span>
<span class="nc" id="L1362">                    log.error(&quot;Exception when trying to recalculate Bloom filter&quot;, e);  // The executor swallows exceptions :(</span>
<span class="nc" id="L1363">                }</span>
<span class="nc" id="L1364">            }</span>

            public void go() {
<span class="nc bnc" id="L1367" title="All 2 branches missed.">                checkState(!lock.isHeldByCurrentThread());</span>
                // Fully verifying mode doesn't use this optimization (it can't as it needs to see all transactions).
<span class="nc bnc" id="L1369" title="All 6 branches missed.">                if ((chain != null &amp;&amp; chain.shouldVerifyTransactions()) || !vBloomFilteringEnabled)</span>
<span class="nc" id="L1370">                    return;</span>
                // We only ever call bloomFilterMerger.calculate on jobQueue, so we cannot be calculating two filters at once.
<span class="nc" id="L1372">                FilterMerger.Result result = bloomFilterMerger.calculate(ImmutableList.copyOf(peerFilterProviders /* COW */));</span>
                boolean send;
<span class="nc bnc" id="L1374" title="All 4 branches missed.">                switch (mode) {</span>
                    case SEND_IF_CHANGED:
<span class="nc" id="L1376">                        send = result.changed;</span>
<span class="nc" id="L1377">                        break;</span>
                    case DONT_SEND:
<span class="nc" id="L1379">                        send = false;</span>
<span class="nc" id="L1380">                        break;</span>
                    case FORCE_SEND_FOR_REFRESH:
<span class="nc" id="L1382">                        send = true;</span>
<span class="nc" id="L1383">                        break;</span>
                    default:
<span class="nc" id="L1385">                        throw new UnsupportedOperationException();</span>
                }
<span class="nc bnc" id="L1387" title="All 2 branches missed.">                if (send) {</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">                    for (Peer peer : peers /* COW */) {</span>
                        // Only query the mempool if this recalculation request is not in order to lower the observed FP
                        // rate. There's no point querying the mempool when doing this because the FP rate can only go
                        // down, and we will have seen all the relevant txns before: it's pointless to ask for them again.
<span class="nc bnc" id="L1392" title="All 2 branches missed.">                        peer.setBloomFilter(result.filter, mode != FilterRecalculateMode.FORCE_SEND_FOR_REFRESH);</span>
<span class="nc" id="L1393">                    }</span>
                    // Reset the false positive estimate so that we don't send a flood of filter updates
                    // if the estimate temporarily overshoots our threshold.
<span class="nc bnc" id="L1396" title="All 2 branches missed.">                    if (chain != null)</span>
<span class="nc" id="L1397">                        chain.resetFalsePositiveEstimate();</span>
                }
                // Do this last so that bloomFilter is already set when it gets called.
<span class="nc" id="L1400">                setFastCatchupTimeSecs(result.earliestKeyTimeSecs);</span>
<span class="nc" id="L1401">                synchronized (inFlightRecalculations) {</span>
<span class="nc" id="L1402">                    inFlightRecalculations.put(mode, null);</span>
<span class="nc" id="L1403">                }</span>
<span class="nc" id="L1404">                future.set(result.filter);</span>
<span class="nc" id="L1405">            }</span>
        };
        try {
<span class="nc" id="L1408">            executor.execute(command);</span>
<span class="nc" id="L1409">        } catch (RejectedExecutionException e) {</span>
            // Can happen during shutdown.
<span class="nc" id="L1411">        }</span>
<span class="nc" id="L1412">        return future;</span>
    }
    
    /**
     * &lt;p&gt;Sets the false positive rate of bloom filters given to peers. The default is {@link #DEFAULT_BLOOM_FILTER_FP_RATE}.&lt;/p&gt;
     *
     * &lt;p&gt;Be careful regenerating the bloom filter too often, as it decreases anonymity because remote nodes can
     * compare transactions against both the new and old filters to significantly decrease the false positive rate.&lt;/p&gt;
     * 
     * &lt;p&gt;See the docs for {@link BloomFilter#BloomFilter(int, double, long, BloomFilter.BloomUpdate)} for a brief
     * explanation of anonymity when using bloom filters.&lt;/p&gt;
     */
    public void setBloomFilterFalsePositiveRate(double bloomFilterFPRate) {
<span class="nc" id="L1425">        lock.lock();</span>
        try {
<span class="nc" id="L1427">            bloomFilterMerger.setBloomFilterFPRate(bloomFilterFPRate);</span>
<span class="nc" id="L1428">            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
        } finally {
<span class="nc" id="L1430">            lock.unlock();</span>
<span class="nc" id="L1431">        }</span>
<span class="nc" id="L1432">    }</span>

    /**
     * Returns the number of currently connected peers. To be informed when this count changes, register a 
     * {@link site.mtnsj.core.listeners.PeerConnectionEventListener} and use the onPeerConnected/onPeerDisconnected methods.
     */
    public int numConnectedPeers() {
<span class="nc" id="L1439">        return peers.size();</span>
    }

    /**
     * Connect to a peer by creating a channel to the destination address.  This should not be
     * used normally - let the PeerGroup manage connections through {@link #start()}
     * 
     * @param address destination IP and port.
     * @return The newly created Peer object or null if the peer could not be connected.
     *         Use {@link site.mtnsj.core.Peer#getConnectionOpenFuture()} if you
     *         want a future which completes when the connection is open.
     */
    @Nullable
    public Peer connectTo(InetSocketAddress address) {
<span class="nc" id="L1453">        lock.lock();</span>
        try {
<span class="nc" id="L1455">            PeerAddress peerAddress = new PeerAddress(params, address);</span>
<span class="nc" id="L1456">            backoffMap.put(peerAddress, new ExponentialBackoff(peerBackoffParams));</span>
<span class="nc" id="L1457">            return connectTo(peerAddress, true, vConnectTimeoutMillis);</span>
        } finally {
<span class="nc" id="L1459">            lock.unlock();</span>
<span class="nc" id="L1460">        }</span>
    }

    /**
     * Helper for forcing a connection to localhost. Useful when using regtest mode. Returns the peer object.
     */
    @Nullable
    public Peer connectToLocalHost() {
<span class="fc" id="L1468">        lock.lock();</span>
        try {
<span class="fc" id="L1470">            final PeerAddress localhost = PeerAddress.localhost(params);</span>
<span class="fc" id="L1471">            backoffMap.put(localhost, new ExponentialBackoff(peerBackoffParams));</span>
<span class="fc" id="L1472">            return connectTo(localhost, true, vConnectTimeoutMillis);</span>
        } finally {
<span class="pc" id="L1474">            lock.unlock();</span>
<span class="nc" id="L1475">        }</span>
    }

    /**
     * Creates a version message to send, constructs a Peer object and attempts to connect it. Returns the peer on
     * success or null on failure.
     * @param address Remote network address
     * @param incrementMaxConnections Whether to consider this connection an attempt to fill our quota, or something
     *                                explicitly requested.
     * @return Peer or null.
     */
    @Nullable @GuardedBy(&quot;lock&quot;)
    protected Peer connectTo(PeerAddress address, boolean incrementMaxConnections, int connectTimeoutMillis) {
<span class="fc" id="L1488">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L1489">        VersionMessage ver = getVersionMessage().duplicate();</span>
<span class="pc bpc" id="L1490" title="1 of 2 branches missed.">        ver.bestHeight = chain == null ? 0 : chain.getBestChainHeight();</span>
<span class="fc" id="L1491">        ver.time = Utils.currentTimeSeconds();</span>

<span class="fc" id="L1493">        Peer peer = createPeer(address, ver);</span>
<span class="fc" id="L1494">        peer.addConnectedEventListener(Threading.SAME_THREAD, startupListener);</span>
<span class="fc" id="L1495">        peer.addDisconnectedEventListener(Threading.SAME_THREAD, startupListener);</span>
<span class="fc" id="L1496">        peer.setMinProtocolVersion(vMinRequiredProtocolVersion);</span>
<span class="fc" id="L1497">        pendingPeers.add(peer);</span>

        try {
<span class="fc" id="L1500">            log.info(&quot;Attempting connection to {}     ({} connected, {} pending, {} max)&quot;, address,</span>
<span class="fc" id="L1501">                    peers.size(), pendingPeers.size(), maxConnections);</span>
<span class="fc" id="L1502">            ListenableFuture&lt;SocketAddress&gt; future = channels.openConnection(address.toSocketAddress(), peer);</span>
<span class="pc bpc" id="L1503" title="1 of 2 branches missed.">            if (future.isDone())</span>
<span class="nc" id="L1504">                Uninterruptibles.getUninterruptibly(future);</span>
<span class="nc" id="L1505">        } catch (ExecutionException e) {</span>
<span class="nc" id="L1506">            Throwable cause = Throwables.getRootCause(e);</span>
<span class="nc" id="L1507">            log.warn(&quot;Failed to connect to &quot; + address + &quot;: &quot; + cause.getMessage());</span>
<span class="nc" id="L1508">            handlePeerDeath(peer, cause);</span>
<span class="nc" id="L1509">            return null;</span>
<span class="fc" id="L1510">        }</span>
<span class="fc" id="L1511">        peer.setSocketTimeout(connectTimeoutMillis);</span>
        // When the channel has connected and version negotiated successfully, handleNewPeer will end up being called on
        // a worker thread.
<span class="pc bpc" id="L1514" title="1 of 2 branches missed.">        if (incrementMaxConnections) {</span>
            // We don't use setMaxConnections here as that would trigger a recursive attempt to establish a new
            // outbound connection.
<span class="fc" id="L1517">            maxConnections++;</span>
        }
<span class="fc" id="L1519">        return peer;</span>
    }

    /** You can override this to customise the creation of {@link Peer} objects. */
    @GuardedBy(&quot;lock&quot;)
    protected Peer createPeer(PeerAddress address, VersionMessage ver) {
<span class="fc" id="L1525">        return new Peer(params, ver, address, chain, downloadTxDependencyDepth);</span>
    }

    /**
     * Sets the timeout between when a connection attempt to a peer begins and when the version message exchange
     * completes. This does not apply to currently pending peers.
     */
    public void setConnectTimeoutMillis(int connectTimeoutMillis) {
<span class="nc" id="L1533">        this.vConnectTimeoutMillis = connectTimeoutMillis;</span>
<span class="nc" id="L1534">    }</span>

    /**
     * &lt;p&gt;Start downloading the blockchain from the first available peer.&lt;/p&gt;
     *
     * &lt;p&gt;If no peers are currently connected, the download will be started once a peer starts.  If the peer dies,
     * the download will resume with another peer.&lt;/p&gt;
     *
     * @param listener a listener for chain download events, may not be null
     */
    public void startBlockChainDownload(PeerDataEventListener listener) {
<span class="nc" id="L1545">        lock.lock();</span>
        try {
<span class="nc bnc" id="L1547" title="All 2 branches missed.">            if (downloadPeer != null) {</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">                if (this.downloadListener != null) {</span>
<span class="nc" id="L1549">                    removeDataEventListenerFromPeer(downloadPeer, this.downloadListener);</span>
                }
<span class="nc bnc" id="L1551" title="All 2 branches missed.">                if (listener != null) {</span>
<span class="nc" id="L1552">                    addDataEventListenerToPeer(Threading.USER_THREAD, downloadPeer, listener);</span>
                }
            }
<span class="nc" id="L1555">            this.downloadListener = listener;</span>
            // TODO: be more nuanced about which peer to download from.  We can also try
            // downloading from multiple peers and handle the case when a new peer comes along
            // with a longer chain after we thought we were done.
<span class="nc bnc" id="L1559" title="All 2 branches missed.">            if (!peers.isEmpty()) {</span>
<span class="nc" id="L1560">                startBlockChainDownloadFromPeer(peers.iterator().next()); // Will add the new download listener</span>
            }
        } finally {
<span class="nc" id="L1563">            lock.unlock();</span>
<span class="nc" id="L1564">        }</span>
<span class="nc" id="L1565">    }</span>

    /**
     * Register a data event listener against a single peer (i.e. for blockchain
     * download). Handling registration/deregistration on peer death/add is
     * outside the scope of these methods.
     */
    private static void addDataEventListenerToPeer(Executor executor, Peer peer, PeerDataEventListener downloadListener) {
<span class="nc" id="L1573">        peer.addBlocksDownloadedEventListener(executor, downloadListener);</span>
<span class="nc" id="L1574">        peer.addChainDownloadStartedEventListener(executor, downloadListener);</span>
<span class="nc" id="L1575">        peer.addGetDataEventListener(executor, downloadListener);</span>
<span class="nc" id="L1576">        peer.addPreMessageReceivedEventListener(executor, downloadListener);</span>
<span class="nc" id="L1577">    }</span>

    /**
     * Remove a registered data event listener against a single peer (i.e. for
     * blockchain download). Handling registration/deregistration on peer death/add is
     * outside the scope of these methods.
     */
    private static void removeDataEventListenerFromPeer(Peer peer, PeerDataEventListener listener) {
<span class="nc" id="L1585">        peer.removeBlocksDownloadedEventListener(listener);</span>
<span class="nc" id="L1586">        peer.removeChainDownloadStartedEventListener(listener);</span>
<span class="nc" id="L1587">        peer.removeGetDataEventListener(listener);</span>
<span class="nc" id="L1588">        peer.removePreMessageReceivedEventListener(listener);</span>
<span class="nc" id="L1589">    }</span>

    /**
     * Download the blockchain from peers. Convenience that uses a {@link DownloadProgressTracker} for you.&lt;p&gt;
     * 
     * This method waits until the download is complete.  &quot;Complete&quot; is defined as downloading
     * from at least one peer all the blocks that are in that peer's inventory.
     */
    public void downloadBlockChain() {
<span class="nc" id="L1598">        DownloadProgressTracker listener = new DownloadProgressTracker();</span>
<span class="nc" id="L1599">        startBlockChainDownload(listener);</span>
        try {
<span class="nc" id="L1601">            listener.await();</span>
<span class="nc" id="L1602">        } catch (InterruptedException e) {</span>
<span class="nc" id="L1603">            throw new RuntimeException(e);</span>
<span class="nc" id="L1604">        }</span>
<span class="nc" id="L1605">    }</span>

    protected void handleNewPeer(final Peer peer) {
<span class="nc" id="L1608">        int newSize = -1;</span>
<span class="nc" id="L1609">        lock.lock();</span>
        try {
<span class="nc" id="L1611">            groupBackoff.trackSuccess();</span>
<span class="nc" id="L1612">            backoffMap.get(peer.getAddress()).trackSuccess();</span>

            // Sets up the newly connected peer so it can do everything it needs to.
<span class="nc" id="L1615">            pendingPeers.remove(peer);</span>
<span class="nc" id="L1616">            peers.add(peer);</span>
<span class="nc" id="L1617">            newSize = peers.size();</span>
<span class="nc" id="L1618">            log.info(&quot;{}: New peer      ({} connected, {} pending, {} max)&quot;, peer, newSize, pendingPeers.size(), maxConnections);</span>
            // Give the peer a filter that can be used to probabilistically drop transactions that
            // aren't relevant to our wallet. We may still receive some false positives, which is
            // OK because it helps improve wallet privacy. Old nodes will just ignore the message.
<span class="nc bnc" id="L1622" title="All 2 branches missed.">            if (bloomFilterMerger.getLastFilter() != null) peer.setBloomFilter(bloomFilterMerger.getLastFilter());</span>
<span class="nc" id="L1623">            peer.setDownloadData(false);</span>
            // TODO: The peer should calculate the fast catchup time from the added wallets here.
<span class="nc bnc" id="L1625" title="All 2 branches missed.">            for (Wallet wallet : wallets)</span>
<span class="nc" id="L1626">                peer.addWallet(wallet);</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">            if (downloadPeer == null) {</span>
                // Kick off chain download if we aren't already doing it.
<span class="nc" id="L1629">                setDownloadPeer(selectDownloadPeer(peers));</span>
<span class="nc bnc" id="L1630" title="All 4 branches missed.">                boolean shouldDownloadChain = downloadListener != null &amp;&amp; chain != null;</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">                if (shouldDownloadChain) {</span>
<span class="nc" id="L1632">                    startBlockChainDownloadFromPeer(downloadPeer);</span>
                }
            }
            // Make sure the peer knows how to upload transactions that are requested from us.
<span class="nc" id="L1636">            peer.addBlocksDownloadedEventListener(Threading.SAME_THREAD, peerListener);</span>
<span class="nc" id="L1637">            peer.addGetDataEventListener(Threading.SAME_THREAD, peerListener);</span>

            // And set up event listeners for clients. This will allow them to find out about new transactions and blocks.
<span class="nc bnc" id="L1640" title="All 2 branches missed.">            for (ListenerRegistration&lt;BlocksDownloadedEventListener&gt; registration : peersBlocksDownloadedEventListeners)</span>
<span class="nc" id="L1641">                peer.addBlocksDownloadedEventListener(registration.executor, registration.listener);</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">            for (ListenerRegistration&lt;ChainDownloadStartedEventListener&gt; registration : peersChainDownloadStartedEventListeners)</span>
<span class="nc" id="L1643">                peer.addChainDownloadStartedEventListener(registration.executor, registration.listener);</span>
<span class="nc bnc" id="L1644" title="All 2 branches missed.">            for (ListenerRegistration&lt;PeerConnectedEventListener&gt; registration : peerConnectedEventListeners)</span>
<span class="nc" id="L1645">                peer.addConnectedEventListener(registration.executor, registration.listener);</span>
            // We intentionally do not add disconnect listeners to peers
<span class="nc bnc" id="L1647" title="All 2 branches missed.">            for (ListenerRegistration&lt;GetDataEventListener&gt; registration : peerGetDataEventListeners)</span>
<span class="nc" id="L1648">                peer.addGetDataEventListener(registration.executor, registration.listener);</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">            for (ListenerRegistration&lt;OnTransactionBroadcastListener&gt; registration : peersTransactionBroadastEventListeners)</span>
<span class="nc" id="L1650">                peer.addOnTransactionBroadcastListener(registration.executor, registration.listener);</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">            for (ListenerRegistration&lt;PreMessageReceivedEventListener&gt; registration : peersPreMessageReceivedEventListeners)</span>
<span class="nc" id="L1652">                peer.addPreMessageReceivedEventListener(registration.executor, registration.listener);</span>
        } finally {
<span class="nc" id="L1654">            lock.unlock();</span>
<span class="nc" id="L1655">        }</span>

<span class="nc" id="L1657">        final int fNewSize = newSize;</span>
<span class="nc bnc" id="L1658" title="All 2 branches missed.">        for (final ListenerRegistration&lt;PeerConnectedEventListener&gt; registration : peerConnectedEventListeners) {</span>
<span class="nc" id="L1659">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L1662">                    registration.listener.onPeerConnected(peer, fNewSize);</span>
<span class="nc" id="L1663">                }</span>
            });
<span class="nc" id="L1665">        }</span>
<span class="nc" id="L1666">    }</span>

    @Nullable private volatile ListenableScheduledFuture&lt;?&gt; vPingTask;

    @SuppressWarnings(&quot;NonAtomicOperationOnVolatileField&quot;)
    private void setupPinging() {
<span class="pc bpc" id="L1672" title="1 of 2 branches missed.">        if (getPingIntervalMsec() &lt;= 0)</span>
<span class="nc" id="L1673">            return;  // Disabled.</span>

<span class="fc" id="L1675">        vPingTask = executor.scheduleAtFixedRate(new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="pc bpc" id="L1679" title="1 of 2 branches missed.">                    if (getPingIntervalMsec() &lt;= 0) {</span>
<span class="nc" id="L1680">                        ListenableScheduledFuture&lt;?&gt; task = vPingTask;</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">                        if (task != null) {</span>
<span class="nc" id="L1682">                            task.cancel(false);</span>
<span class="nc" id="L1683">                            vPingTask = null;</span>
                        }
<span class="nc" id="L1685">                        return;  // Disabled.</span>
                    }
<span class="pc bpc" id="L1687" title="1 of 2 branches missed.">                    for (Peer peer : getConnectedPeers()) {</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">                        if (peer.getPeerVersionMessage().clientVersion &lt; params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.PONG))</span>
<span class="nc" id="L1689">                            continue;</span>

                        try {
                            // todo: here i have to implement the GetBlock
                            //System.out.println(&quot;Peer pings sent: &quot; + peer.getSentPingNumber());
                            //if (peer.getSentPingNumber() &gt; 5) {
                            //    if (peer.isDownloadData()) {
                            //        peer.startBlockChainDownload();
                            //    }
                            //}
                        }catch (Exception e){
                            e.printStackTrace();
                        }
<span class="nc" id="L1702">                        peer.ping();</span>
<span class="nc" id="L1703">                    }</span>
<span class="nc" id="L1704">                } catch (Throwable e) {</span>
<span class="nc" id="L1705">                    log.error(&quot;Exception in ping loop&quot;, e);  // The executor swallows exceptions :(</span>
<span class="fc" id="L1706">                }</span>
<span class="fc" id="L1707">            }</span>
<span class="fc" id="L1708">        }, getPingIntervalMsec(), getPingIntervalMsec(), TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L1709">    }</span>

    private void setDownloadPeer(@Nullable Peer peer) {
<span class="nc" id="L1712">        lock.lock();</span>
        try {
<span class="nc bnc" id="L1714" title="All 2 branches missed.">            if (downloadPeer == peer)</span>
<span class="nc" id="L1715">                return;</span>
<span class="nc bnc" id="L1716" title="All 2 branches missed.">            if (downloadPeer != null) {</span>
<span class="nc" id="L1717">                log.info(&quot;Unsetting download peer: {}&quot;, downloadPeer);</span>
<span class="nc bnc" id="L1718" title="All 2 branches missed.">                if (downloadListener != null) {</span>
<span class="nc" id="L1719">                    removeDataEventListenerFromPeer(downloadPeer, downloadListener);</span>
                }
<span class="nc" id="L1721">                downloadPeer.setDownloadData(false);</span>
            }
<span class="nc" id="L1723">            downloadPeer = peer;</span>
<span class="nc bnc" id="L1724" title="All 2 branches missed.">            if (downloadPeer != null) {</span>
<span class="nc" id="L1725">                log.info(&quot;Setting download peer: {}&quot;, downloadPeer);</span>
<span class="nc bnc" id="L1726" title="All 2 branches missed.">                if (downloadListener != null) {</span>
<span class="nc" id="L1727">                    addDataEventListenerToPeer(Threading.SAME_THREAD, peer, downloadListener);</span>
                }
<span class="nc" id="L1729">                downloadPeer.setDownloadData(true);</span>
<span class="nc bnc" id="L1730" title="All 2 branches missed.">                if (chain != null)</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">                    downloadPeer.setDownloadParameters(fastCatchupTimeSecs, bloomFilterMerger.getLastFilter() != null);</span>
            }
        } finally {
<span class="nc" id="L1734">            lock.unlock();</span>
<span class="nc" id="L1735">        }</span>
<span class="nc" id="L1736">    }</span>

    /** Use &quot;Context.get().getConfidenceTable()&quot; instead */
    @Deprecated @Nullable
    public TxConfidenceTable getMemoryPool() {
<span class="nc" id="L1741">        return Context.get().getConfidenceTable();</span>
    }

    /**
     * Tells the PeerGroup to download only block headers before a certain time and bodies after that. Call this
     * before starting block chain download.
     * Do not use a time &gt; NOW - 1 block, as it will break some block download logic.
     */
    public void setFastCatchupTimeSecs(long secondsSinceEpoch) {
<span class="nc" id="L1750">        lock.lock();</span>
        try {
<span class="nc bnc" id="L1752" title="All 4 branches missed.">            checkState(chain == null || !chain.shouldVerifyTransactions(), &quot;Fast catchup is incompatible with fully verifying&quot;);</span>
<span class="nc" id="L1753">            fastCatchupTimeSecs = secondsSinceEpoch;</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">            if (downloadPeer != null) {</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">                downloadPeer.setDownloadParameters(secondsSinceEpoch, bloomFilterMerger.getLastFilter() != null);</span>
            }
        } finally {
<span class="nc" id="L1758">            lock.unlock();</span>
<span class="nc" id="L1759">        }</span>
<span class="nc" id="L1760">    }</span>

    /**
     * Returns the current fast catchup time. The contents of blocks before this time won't be downloaded as they
     * cannot contain any interesting transactions. If you use {@link PeerGroup#addWallet(Wallet)} this just returns
     * the min of the wallets earliest key times.
     * @return a time in seconds since the epoch
     */
    public long getFastCatchupTimeSecs() {
<span class="nc" id="L1769">        lock.lock();</span>
        try {
<span class="nc" id="L1771">            return fastCatchupTimeSecs;</span>
        } finally {
<span class="nc" id="L1773">            lock.unlock();</span>
<span class="nc" id="L1774">        }</span>
    }


    protected void handlePeerDeath(final Peer peer, @Nullable Throwable exception) {
        // Peer deaths can occur during startup if a connect attempt after peer discovery aborts immediately.
<span class="pc bpc" id="L1780" title="1 of 2 branches missed.">        if (!isRunning()) return;</span>

        int numPeers;
<span class="fc" id="L1783">        int numConnectedPeers = 0;</span>
<span class="fc" id="L1784">        lock.lock();</span>
        try {
<span class="fc" id="L1786">            pendingPeers.remove(peer);</span>
<span class="fc" id="L1787">            peers.remove(peer);</span>

<span class="fc" id="L1789">            PeerAddress address = peer.getAddress();</span>

<span class="fc" id="L1791">            log.info(&quot;{}: Peer died      ({} connected, {} pending, {} max)&quot;, address, peers.size(), pendingPeers.size(), maxConnections);</span>
<span class="pc bpc" id="L1792" title="1 of 2 branches missed.">            if (peer == downloadPeer) {</span>
<span class="nc" id="L1793">                log.info(&quot;Download peer died. Picking a new one.&quot;);</span>
<span class="nc" id="L1794">                setDownloadPeer(null);</span>
                // Pick a new one and possibly tell it to download the chain.
<span class="nc" id="L1796">                final Peer newDownloadPeer = selectDownloadPeer(peers);</span>
<span class="nc bnc" id="L1797" title="All 2 branches missed.">                if (newDownloadPeer != null) {</span>
<span class="nc" id="L1798">                    setDownloadPeer(newDownloadPeer);</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">                    if (downloadListener != null) {</span>
<span class="nc" id="L1800">                        startBlockChainDownloadFromPeer(newDownloadPeer);</span>
                    }
                }
            }
<span class="fc" id="L1804">            numPeers = peers.size() + pendingPeers.size();</span>
<span class="fc" id="L1805">            numConnectedPeers = peers.size();</span>

<span class="fc" id="L1807">            groupBackoff.trackFailure();</span>

<span class="pc bpc" id="L1809" title="1 of 2 branches missed.">            if (exception instanceof NoRouteToHostException) {</span>
<span class="nc bnc" id="L1810" title="All 4 branches missed.">                if (address.getAddr() instanceof Inet6Address &amp;&amp; !ipv6Unreachable) {</span>
<span class="nc" id="L1811">                    ipv6Unreachable = true;</span>
<span class="nc" id="L1812">                    log.warn(&quot;IPv6 peer connect failed due to routing failure, ignoring IPv6 addresses from now on&quot;);</span>
                }
            } else {
<span class="fc" id="L1815">                backoffMap.get(address).trackFailure();</span>
                // Put back on inactive list
<span class="fc" id="L1817">                inactives.offer(address);</span>
            }

<span class="pc bpc" id="L1820" title="1 of 2 branches missed.">            if (numPeers &lt; getMaxConnections()) {</span>
<span class="fc" id="L1821">                triggerConnections();</span>
            }
        } finally {
<span class="pc" id="L1824">            lock.unlock();</span>
<span class="pc" id="L1825">        }</span>

<span class="fc" id="L1827">        peer.removeBlocksDownloadedEventListener(peerListener);</span>
<span class="fc" id="L1828">        peer.removeGetDataEventListener(peerListener);</span>
<span class="pc bpc" id="L1829" title="1 of 2 branches missed.">        for (Wallet wallet : wallets) {</span>
<span class="nc" id="L1830">            peer.removeWallet(wallet);</span>
<span class="nc" id="L1831">        }</span>

<span class="fc" id="L1833">        final int fNumConnectedPeers = numConnectedPeers;</span>

<span class="pc bpc" id="L1835" title="1 of 2 branches missed.">        for (ListenerRegistration&lt;BlocksDownloadedEventListener&gt; registration: peersBlocksDownloadedEventListeners)</span>
<span class="nc" id="L1836">            peer.removeBlocksDownloadedEventListener(registration.listener);</span>
<span class="pc bpc" id="L1837" title="1 of 2 branches missed.">        for (ListenerRegistration&lt;ChainDownloadStartedEventListener&gt; registration: peersChainDownloadStartedEventListeners)</span>
<span class="nc" id="L1838">            peer.removeChainDownloadStartedEventListener(registration.listener);</span>
<span class="pc bpc" id="L1839" title="1 of 2 branches missed.">        for (ListenerRegistration&lt;GetDataEventListener&gt; registration: peerGetDataEventListeners)</span>
<span class="nc" id="L1840">            peer.removeGetDataEventListener(registration.listener);</span>
<span class="pc bpc" id="L1841" title="1 of 2 branches missed.">        for (ListenerRegistration&lt;PreMessageReceivedEventListener&gt; registration: peersPreMessageReceivedEventListeners)</span>
<span class="nc" id="L1842">            peer.removePreMessageReceivedEventListener(registration.listener);</span>
<span class="pc bpc" id="L1843" title="1 of 2 branches missed.">        for (ListenerRegistration&lt;OnTransactionBroadcastListener&gt; registration : peersTransactionBroadastEventListeners)</span>
<span class="nc" id="L1844">            peer.removeOnTransactionBroadcastListener(registration.listener);</span>
<span class="pc bpc" id="L1845" title="1 of 2 branches missed.">        for (final ListenerRegistration&lt;PeerDisconnectedEventListener&gt; registration : peerDisconnectedEventListeners) {</span>
<span class="nc" id="L1846">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L1849">                    registration.listener.onPeerDisconnected(peer, fNumConnectedPeers);</span>
<span class="nc" id="L1850">                }</span>
            });
<span class="nc" id="L1852">            peer.removeDisconnectedEventListener(registration.listener);</span>
<span class="nc" id="L1853">        }</span>
<span class="fc" id="L1854">    }</span>

<span class="fc" id="L1856">    @GuardedBy(&quot;lock&quot;) private int stallPeriodSeconds = 10;</span>
<span class="fc" id="L1857">    @GuardedBy(&quot;lock&quot;) private int stallMinSpeedBytesSec = Block.HEADER_SIZE * 20;</span>

    /**
     * Configures the stall speed: the speed at which a peer is considered to be serving us the block chain
     * unacceptably slowly. Once a peer has served us data slower than the given data rate for the given
     * number of seconds, it is considered stalled and will be disconnected, forcing the chain download to continue
     * from a different peer. The defaults are chosen conservatively, but if you are running on a platform that is
     * CPU constrained or on a very slow network e.g. EDGE, the default settings may need adjustment to
     * avoid false stalls.
     *
     * @param periodSecs How many seconds the download speed must be below blocksPerSec, defaults to 10.
     * @param bytesPerSecond Download speed (only blocks/txns count) must be consistently below this for a stall, defaults to the bandwidth required for 20 block headers per second.
     */
    public void setStallThreshold(int periodSecs, int bytesPerSecond) {
<span class="nc" id="L1871">        lock.lock();</span>
        try {
<span class="nc" id="L1873">            stallPeriodSeconds = periodSecs;</span>
<span class="nc" id="L1874">            stallMinSpeedBytesSec = bytesPerSecond;</span>
        } finally {
<span class="nc" id="L1876">            lock.unlock();</span>
<span class="nc" id="L1877">        }</span>
<span class="nc" id="L1878">    }</span>

<span class="nc" id="L1880">    private class ChainDownloadSpeedCalculator implements BlocksDownloadedEventListener, Runnable {</span>
        private int blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond;
        private long bytesInLastSecond;

        // If we take more stalls than this, we assume we're on some kind of terminally slow network and the
        // stall threshold just isn't set properly. We give up on stall disconnects after that.
<span class="nc" id="L1886">        private int maxStalls = 3;</span>

        // How many seconds the peer has until we start measuring its speed.
<span class="nc" id="L1889">        private int warmupSeconds = -1;</span>

        // Used to calculate a moving average.
        private long[] samples;
        private int cursor;

        private boolean syncDone;

        @Override
        public synchronized void onBlocksDownloaded(Peer peer, Block block, @Nullable FilteredBlock filteredBlock, int blocksLeft) {
<span class="nc" id="L1899">            blocksInLastSecond++;</span>
<span class="nc" id="L1900">            bytesInLastSecond += Block.HEADER_SIZE;</span>
<span class="nc" id="L1901">            List&lt;Transaction&gt; blockTransactions = block.getTransactions();</span>
            // This whole area of the type hierarchy is a mess.
<span class="nc bnc" id="L1903" title="All 4 branches missed.">            int txCount = (blockTransactions != null ? countAndMeasureSize(blockTransactions) : 0) +</span>
<span class="nc" id="L1904">                          (filteredBlock != null ? countAndMeasureSize(filteredBlock.getAssociatedTransactions().values()) : 0);</span>
<span class="nc" id="L1905">            txnsInLastSecond = txnsInLastSecond + txCount;</span>
<span class="nc bnc" id="L1906" title="All 2 branches missed.">            if (filteredBlock != null)</span>
<span class="nc" id="L1907">                origTxnsInLastSecond += filteredBlock.getTransactionCount();</span>
<span class="nc" id="L1908">        }</span>

        private int countAndMeasureSize(Collection&lt;Transaction&gt; transactions) {
<span class="nc bnc" id="L1911" title="All 2 branches missed.">            for (Transaction transaction : transactions)</span>
<span class="nc" id="L1912">                bytesInLastSecond += transaction.getMessageSize();</span>
<span class="nc" id="L1913">            return transactions.size();</span>
        }

        @Override
        public void run() {
            try {
<span class="nc" id="L1919">                calculate();</span>
<span class="nc" id="L1920">            } catch (Throwable e) {</span>
<span class="nc" id="L1921">                log.error(&quot;Error in speed calculator&quot;, e);</span>
<span class="nc" id="L1922">            }</span>
<span class="nc" id="L1923">        }</span>

        private void calculate() {
            int minSpeedBytesPerSec;
            int period;

<span class="nc" id="L1929">            lock.lock();</span>
            try {
<span class="nc" id="L1931">                minSpeedBytesPerSec = stallMinSpeedBytesSec;</span>
<span class="nc" id="L1932">                period = stallPeriodSeconds;</span>
            } finally {
<span class="nc" id="L1934">                lock.unlock();</span>
<span class="nc" id="L1935">            }</span>

<span class="nc" id="L1937">            synchronized (this) {</span>
<span class="nc bnc" id="L1938" title="All 4 branches missed.">                if (samples == null || samples.length != period) {</span>
<span class="nc" id="L1939">                    samples = new long[period];</span>
                    // *2 because otherwise a single low sample could cause an immediate disconnect which is too harsh.
<span class="nc" id="L1941">                    Arrays.fill(samples, minSpeedBytesPerSec * 2);</span>
<span class="nc" id="L1942">                    warmupSeconds = 15;</span>
                }

<span class="nc bnc" id="L1945" title="All 4 branches missed.">                boolean behindPeers = chain != null &amp;&amp; chain.getBestChainHeight() &lt; getMostCommonChainHeight();</span>
<span class="nc bnc" id="L1946" title="All 2 branches missed.">                if (!behindPeers)</span>
<span class="nc" id="L1947">                    syncDone = true;</span>
<span class="nc bnc" id="L1948" title="All 2 branches missed.">                if (!syncDone) {</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">                    if (warmupSeconds &lt; 0) {</span>
                        // Calculate the moving average.
<span class="nc" id="L1951">                        samples[cursor++] = bytesInLastSecond;</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">                        if (cursor == samples.length) cursor = 0;</span>
<span class="nc" id="L1953">                        long average = 0;</span>
<span class="nc bnc" id="L1954" title="All 2 branches missed.">                        for (long sample : samples) average += sample;</span>
<span class="nc" id="L1955">                        average /= samples.length;</span>

<span class="nc" id="L1957">                        log.info(String.format(Locale.US, &quot;%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, avg/last %.2f/%.2f kilobytes per sec (stall threshold &lt;%.2f KB/sec for %d seconds)&quot;,</span>
<span class="nc" id="L1958">                                blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, average / 1024.0, bytesInLastSecond / 1024.0,</span>
<span class="nc" id="L1959">                                minSpeedBytesPerSec / 1024.0, samples.length));</span>

<span class="nc bnc" id="L1961" title="All 4 branches missed.">                        if (average &lt; minSpeedBytesPerSec &amp;&amp; maxStalls &gt; 0) {</span>
<span class="nc" id="L1962">                            maxStalls--;</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">                            if (maxStalls == 0) {</span>
                                // We could consider starting to drop the Bloom filtering FP rate at this point, because
                                // we tried a bunch of peers and no matter what we don't seem to be able to go any faster.
                                // This implies we're bandwidth bottlenecked and might want to start using bandwidth
                                // more effectively. Of course if there's a MITM that is deliberately throttling us,
                                // this is a good way to make us take away all the FPs from our Bloom filters ... but
                                // as they don't give us a whole lot of privacy either way that's not inherently a big
                                // deal.
<span class="nc" id="L1971">                                log.warn(&quot;This network seems to be slower than the requested stall threshold - won't do stall disconnects any more.&quot;);</span>
                            } else {
<span class="nc" id="L1973">                                Peer peer = getDownloadPeer();</span>
<span class="nc" id="L1974">                                log.warn(String.format(Locale.US, &quot;Chain download stalled: received %.2f KB/sec for %d seconds, require average of %.2f KB/sec, disconnecting %s&quot;, average / 1024.0, samples.length, minSpeedBytesPerSec / 1024.0, peer));</span>
<span class="nc" id="L1975">                                peer.close();</span>
                                // Reset the sample buffer and give the next peer time to get going.
<span class="nc" id="L1977">                                samples = null;</span>
<span class="nc" id="L1978">                                warmupSeconds = period;</span>
                            }
                        }
<span class="nc" id="L1981">                    } else {</span>
<span class="nc" id="L1982">                        warmupSeconds--;</span>
<span class="nc bnc" id="L1983" title="All 2 branches missed.">                        if (bytesInLastSecond &gt; 0)</span>
<span class="nc" id="L1984">                            log.info(String.format(Locale.US, &quot;%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, last %.2f kilobytes per sec&quot;,</span>
<span class="nc" id="L1985">                                    blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, bytesInLastSecond / 1024.0));</span>
                    }
                }
<span class="nc" id="L1988">                blocksInLastSecond = 0;</span>
<span class="nc" id="L1989">                txnsInLastSecond = 0;</span>
<span class="nc" id="L1990">                origTxnsInLastSecond = 0;</span>
<span class="nc" id="L1991">                bytesInLastSecond = 0;</span>
<span class="nc" id="L1992">            }</span>
<span class="nc" id="L1993">        }</span>
    }
    @Nullable private ChainDownloadSpeedCalculator chainDownloadSpeedCalculator;

    private void startBlockChainDownloadFromPeer(Peer peer) {
<span class="nc" id="L1998">        lock.lock();</span>
        try {
<span class="nc" id="L2000">            setDownloadPeer(peer);</span>

<span class="nc bnc" id="L2002" title="All 2 branches missed.">            if (chainDownloadSpeedCalculator == null) {</span>
                // Every second, run the calculator which will log how fast we are downloading the chain.
<span class="nc" id="L2004">                chainDownloadSpeedCalculator = new ChainDownloadSpeedCalculator();</span>
<span class="nc" id="L2005">                executor.scheduleAtFixedRate(chainDownloadSpeedCalculator, 1, 1, TimeUnit.SECONDS);</span>
            }
<span class="nc" id="L2007">            peer.addBlocksDownloadedEventListener(Threading.SAME_THREAD, chainDownloadSpeedCalculator);</span>

            // startBlockChainDownload will setDownloadData(true) on itself automatically.
<span class="nc" id="L2010">            peer.startBlockChainDownload();</span>
        } finally {
<span class="nc" id="L2012">            lock.unlock();</span>
<span class="nc" id="L2013">        }</span>
<span class="nc" id="L2014">    }</span>

    /**
     * Returns a future that is triggered when the number of connected peers is equal to the given number of
     * peers. By using this with {@link site.mtnsj.core.PeerGroup#getMaxConnections()} you can wait until the
     * network is fully online. To block immediately, just call get() on the result. Just calls
     * {@link #waitForPeersOfVersion(int, long)} with zero as the protocol version.
     *
     * @param numPeers How many peers to wait for.
     * @return a future that will be triggered when the number of connected peers &gt;= numPeers
     */
    public ListenableFuture&lt;List&lt;Peer&gt;&gt; waitForPeers(final int numPeers) {
<span class="nc" id="L2026">        return waitForPeersOfVersion(numPeers, 0);</span>
    }

    /**
     * Returns a future that is triggered when there are at least the requested number of connected peers that support
     * the given protocol version or higher. To block immediately, just call get() on the result.
     *
     * @param numPeers How many peers to wait for.
     * @param protocolVersion The protocol version the awaited peers must implement (or better).
     * @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher &gt;= numPeers
     */
    public ListenableFuture&lt;List&lt;Peer&gt;&gt; waitForPeersOfVersion(final int numPeers, final long protocolVersion) {
<span class="nc" id="L2038">        List&lt;Peer&gt; foundPeers = findPeersOfAtLeastVersion(protocolVersion);</span>
<span class="nc bnc" id="L2039" title="All 2 branches missed.">        if (foundPeers.size() &gt;= numPeers) {</span>
<span class="nc" id="L2040">            return Futures.immediateFuture(foundPeers);</span>
        }
<span class="nc" id="L2042">        final SettableFuture&lt;List&lt;Peer&gt;&gt; future = SettableFuture.create();</span>
<span class="nc" id="L2043">        addConnectedEventListener(new PeerConnectedEventListener() {</span>
            @Override
            public void onPeerConnected(Peer peer, int peerCount) {
<span class="nc" id="L2046">                final List&lt;Peer&gt; peers = findPeersOfAtLeastVersion(protocolVersion);</span>
<span class="nc bnc" id="L2047" title="All 2 branches missed.">                if (peers.size() &gt;= numPeers) {</span>
<span class="nc" id="L2048">                    future.set(peers);</span>
<span class="nc" id="L2049">                    removeConnectedEventListener(this);</span>
                }
<span class="nc" id="L2051">            }</span>
        });
<span class="nc" id="L2053">        return future;</span>
    }

    /**
     * Returns an array list of peers that implement the given protocol version or better.
     */
    public List&lt;Peer&gt; findPeersOfAtLeastVersion(long protocolVersion) {
<span class="nc" id="L2060">        lock.lock();</span>
        try {
<span class="nc" id="L2062">            ArrayList&lt;Peer&gt; results = new ArrayList&lt;Peer&gt;(peers.size());</span>
<span class="nc bnc" id="L2063" title="All 2 branches missed.">            for (Peer peer : peers)</span>
<span class="nc bnc" id="L2064" title="All 2 branches missed.">                if (peer.getPeerVersionMessage().clientVersion &gt;= protocolVersion)</span>
<span class="nc" id="L2065">                    results.add(peer);</span>
<span class="nc" id="L2066">            return results;</span>
        } finally {
<span class="nc" id="L2068">            lock.unlock();</span>
<span class="nc" id="L2069">        }</span>
    }

    /**
     * Returns a future that is triggered when there are at least the requested number of connected peers that support
     * the given protocol version or higher. To block immediately, just call get() on the result.
     *
     * @param numPeers How many peers to wait for.
     * @param mask An integer representing a bit mask that will be ANDed with the peers advertised service masks.
     * @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher &gt;= numPeers
     */
    public ListenableFuture&lt;List&lt;Peer&gt;&gt; waitForPeersWithServiceMask(final int numPeers, final int mask) {
<span class="nc" id="L2081">        lock.lock();</span>
        try {
<span class="nc" id="L2083">            List&lt;Peer&gt; foundPeers = findPeersWithServiceMask(mask);</span>
<span class="nc bnc" id="L2084" title="All 2 branches missed.">            if (foundPeers.size() &gt;= numPeers)</span>
<span class="nc" id="L2085">                return Futures.immediateFuture(foundPeers);</span>
<span class="nc" id="L2086">            final SettableFuture&lt;List&lt;Peer&gt;&gt; future = SettableFuture.create();</span>
<span class="nc" id="L2087">            addConnectedEventListener(new PeerConnectedEventListener() {</span>
                @Override
                public void onPeerConnected(Peer peer, int peerCount) {
<span class="nc" id="L2090">                    final List&lt;Peer&gt; peers = findPeersWithServiceMask(mask);</span>
<span class="nc bnc" id="L2091" title="All 2 branches missed.">                    if (peers.size() &gt;= numPeers) {</span>
<span class="nc" id="L2092">                        future.set(peers);</span>
<span class="nc" id="L2093">                        removeConnectedEventListener(this);</span>
                    }
<span class="nc" id="L2095">                }</span>
            });
<span class="nc" id="L2097">            return future;</span>
        } finally {
<span class="nc" id="L2099">            lock.unlock();</span>
<span class="nc" id="L2100">        }</span>
    }

    /**
     * Returns an array list of peers that match the requested service bit mask.
     */
    public List&lt;Peer&gt; findPeersWithServiceMask(int mask) {
<span class="nc" id="L2107">        lock.lock();</span>
        try {
<span class="nc" id="L2109">            ArrayList&lt;Peer&gt; results = new ArrayList&lt;Peer&gt;(peers.size());</span>
<span class="nc bnc" id="L2110" title="All 2 branches missed.">            for (Peer peer : peers)</span>
<span class="nc bnc" id="L2111" title="All 2 branches missed.">                if ((peer.getPeerVersionMessage().localServices &amp; mask) == mask)</span>
<span class="nc" id="L2112">                    results.add(peer);</span>
<span class="nc" id="L2113">            return results;</span>
        } finally {
<span class="nc" id="L2115">            lock.unlock();</span>
<span class="nc" id="L2116">        }</span>
    }

    /**
     * Returns the number of connections that are required before transactions will be broadcast. If there aren't
     * enough, {@link PeerGroup#broadcastTransaction(Transaction)} will wait until the minimum number is reached so
     * propagation across the network can be observed. If no value has been set using
     * {@link PeerGroup#setMinBroadcastConnections(int)} a default of 80% of whatever
     * {@link site.mtnsj.core.PeerGroup#getMaxConnections()} returns is used.
     */
    public int getMinBroadcastConnections() {
<span class="nc" id="L2127">        lock.lock();</span>
        try {
<span class="nc bnc" id="L2129" title="All 2 branches missed.">            if (minBroadcastConnections == 0) {</span>
<span class="nc" id="L2130">                int max = getMaxConnections();</span>
<span class="nc bnc" id="L2131" title="All 2 branches missed.">                if (max &lt;= 1)</span>
<span class="nc" id="L2132">                    return max;</span>
                else
<span class="nc" id="L2134">                    return (int) Math.round(getMaxConnections() * 0.8);</span>
            }
<span class="nc" id="L2136">            return minBroadcastConnections;</span>
        } finally {
<span class="nc" id="L2138">            lock.unlock();</span>
<span class="nc" id="L2139">        }</span>
    }

    /**
     * See {@link site.mtnsj.core.PeerGroup#getMinBroadcastConnections()}.
     */
    public void setMinBroadcastConnections(int value) {
<span class="nc" id="L2146">        lock.lock();</span>
        try {
<span class="nc" id="L2148">            minBroadcastConnections = value;</span>
        } finally {
<span class="nc" id="L2150">            lock.unlock();</span>
<span class="nc" id="L2151">        }</span>
<span class="nc" id="L2152">    }</span>

    /**
     * Calls {@link PeerGroup#broadcastTransaction(Transaction,int,boolean)} with getMinBroadcastConnections() as the number
     * of connections to wait for before commencing broadcast.
     */
    @Override
    public TransactionBroadcast broadcastTransaction(final Transaction tx) {
<span class="nc" id="L2160">        return broadcastTransaction(tx, Math.max(1, getMinBroadcastConnections()),false);</span>
    }

    /**
     * Calls {@link PeerGroup#broadcastTransaction(Transaction,int,boolean)} with getMinBroadcastConnections() as the number
     * of connections to wait for before commencing broadcast.
     */
    @Override
    public TransactionBroadcast broadcastTransaction(final Transaction tx,boolean isSwiftX) {
<span class="nc" id="L2169">        return broadcastTransaction(tx, Math.max(1, getMinBroadcastConnections()),isSwiftX);</span>
    }

    /**
     * &lt;p&gt;Given a transaction, sends it un-announced to one peer and then waits for it to be received back from other
     * peers. Once all connected peers have announced the transaction, the future available via the
     * {@link site.mtnsj.core.TransactionBroadcast#future()} method will be completed. If anything goes
     * wrong the exception will be thrown when get() is called, or you can receive it via a callback on the
     * {@link ListenableFuture}. This method returns immediately, so if you want it to block just call get() on the
     * result.&lt;/p&gt;
     *
     * &lt;p&gt;Note that if the PeerGroup is limited to only one connection (discovery is not activated) then the future
     * will complete as soon as the transaction was successfully written to that peer.&lt;/p&gt;
     *
     * &lt;p&gt;The transaction won't be sent until there are at least minConnections active connections available.
     * A good choice for proportion would be between 0.5 and 0.8 but if you want faster transmission during initial
     * bringup of the peer group you can lower it.&lt;/p&gt;
     *
     * &lt;p&gt;The returned {@link site.mtnsj.core.TransactionBroadcast} object can be used to get progress feedback,
     * which is calculated by watching the transaction propagate across the network and be announced by peers.&lt;/p&gt;
     */
    public TransactionBroadcast broadcastTransaction(final Transaction tx, final int minConnections, boolean isSwiftX) {
        // If we don't have a record of where this tx came from already, set it to be ourselves so Peer doesn't end up
        // redownloading it from the network redundantly.
<span class="nc bnc" id="L2193" title="All 2 branches missed.">        if (tx.getConfidence().getSource().equals(TransactionConfidence.Source.UNKNOWN)) {</span>
<span class="nc" id="L2194">            log.info(&quot;Transaction source unknown, setting to SELF: {}&quot;, tx.getHashAsString());</span>
<span class="nc" id="L2195">            tx.getConfidence().setSource(TransactionConfidence.Source.SELF);</span>
        }
<span class="nc" id="L2197">        final TransactionBroadcast broadcast = new TransactionBroadcast(this, tx,isSwiftX);</span>
<span class="nc" id="L2198">        broadcast.setMinConnections(minConnections);</span>
        // Send the TX to the wallet once we have a successful broadcast.
<span class="nc" id="L2200">        Futures.addCallback(broadcast.future(), new FutureCallback&lt;Transaction&gt;() {</span>
            @Override
            public void onSuccess(Transaction transaction) {
<span class="nc" id="L2203">                runningBroadcasts.remove(broadcast);</span>
                // OK, now tell the wallet about the transaction. If the wallet created the transaction then
                // it already knows and will ignore this. If it's a transaction we received from
                // somebody else via a side channel and are now broadcasting, this will put it into the
                // wallet now we know it's valid.
<span class="nc bnc" id="L2208" title="All 2 branches missed.">                for (Wallet wallet : wallets) {</span>
                    // Assumption here is there are no dependencies of the created transaction.
                    //
                    // We may end up with two threads trying to do this in parallel - the wallet will
                    // ignore whichever one loses the race.
                    try {
<span class="nc" id="L2214">                        wallet.receivePending(transaction, null);</span>
<span class="nc" id="L2215">                    } catch (VerificationException e) {</span>
<span class="nc" id="L2216">                        throw new RuntimeException(e);   // Cannot fail to verify a tx we created ourselves.</span>
<span class="nc" id="L2217">                    }</span>
<span class="nc" id="L2218">                }</span>
<span class="nc" id="L2219">            }</span>

            @Override
            public void onFailure(Throwable throwable) {
                // This can happen if we get a reject message from a peer.
<span class="nc" id="L2224">                runningBroadcasts.remove(broadcast);</span>
<span class="nc" id="L2225">            }</span>
        });
        // Keep a reference to the TransactionBroadcast object. This is important because otherwise, the entire tree
        // of objects we just created would become garbage if the user doesn't hold on to the returned future, and
        // eventually be collected. This in turn could result in the transaction not being committed to the wallet
        // at all.
<span class="nc" id="L2231">        runningBroadcasts.add(broadcast);</span>
<span class="nc" id="L2232">        broadcast.broadcast();</span>
<span class="nc" id="L2233">        return broadcast;</span>
    }

    /**
     * Returns the period between pings for an individual peer. Setting this lower means more accurate and timely ping
     * times are available via {@link site.mtnsj.core.Peer#getLastPingTime()} but it increases load on the
     * remote node. It defaults to 5000.
     */
    public long getPingIntervalMsec() {
<span class="fc" id="L2242">        lock.lock();</span>
        try {
<span class="fc" id="L2244">            return pingIntervalMsec;</span>
        } finally {
<span class="pc" id="L2246">            lock.unlock();</span>
<span class="nc" id="L2247">        }</span>
    }

    /**
     * Sets the period between pings for an individual peer. Setting this lower means more accurate and timely ping
     * times are available via {@link site.mtnsj.core.Peer#getLastPingTime()} but it increases load on the
     * remote node. It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     * Setting the value to be &lt;= 0 disables pinging entirely, although you can still request one yourself
     * using {@link site.mtnsj.core.Peer#ping()}.
     */
    public void setPingIntervalMsec(long pingIntervalMsec) {
<span class="nc" id="L2258">        lock.lock();</span>
        try {
<span class="nc" id="L2260">            this.pingIntervalMsec = pingIntervalMsec;</span>
<span class="nc" id="L2261">            ListenableScheduledFuture&lt;?&gt; task = vPingTask;</span>
<span class="nc bnc" id="L2262" title="All 2 branches missed.">            if (task != null)</span>
<span class="nc" id="L2263">                task.cancel(false);</span>
<span class="nc" id="L2264">            setupPinging();</span>
        } finally {
<span class="nc" id="L2266">            lock.unlock();</span>
<span class="nc" id="L2267">        }</span>
<span class="nc" id="L2268">    }</span>

    /**
     * If a peer is connected to that claims to speak a protocol version lower than the given version, it will
     * be disconnected and another one will be tried instead.
     */
    public void setMinRequiredProtocolVersion(int minRequiredProtocolVersion) {
<span class="nc" id="L2275">        this.vMinRequiredProtocolVersion = minRequiredProtocolVersion;</span>
<span class="nc" id="L2276">    }</span>

    /** The minimum protocol version required: defaults to the version required for Bloom filtering. */
    public int getMinRequiredProtocolVersion() {
<span class="nc" id="L2280">        return vMinRequiredProtocolVersion;</span>
    }

    /**
     * Returns our peers most commonly reported chain height. If multiple heights are tied, the highest is returned.
     * If no peers are connected, returns zero.
     */
    public int getMostCommonChainHeight() {
<span class="nc" id="L2288">        lock.lock();</span>
        try {
<span class="nc" id="L2290">            return getMostCommonChainHeight(this.peers);</span>
        } finally {
<span class="nc" id="L2292">            lock.unlock();</span>
<span class="nc" id="L2293">        }</span>
    }

    /**
     * Returns most commonly reported chain height from the given list of {@link Peer}s.
     * If multiple heights are tied, the highest is returned. If no peers are connected, returns zero.
     */
    public static int getMostCommonChainHeight(final List&lt;Peer&gt; peers) {
<span class="nc bnc" id="L2301" title="All 2 branches missed.">        if (peers.isEmpty())</span>
<span class="nc" id="L2302">            return 0;</span>
<span class="nc" id="L2303">        List&lt;Integer&gt; heights = new ArrayList&lt;Integer&gt;(peers.size());</span>
<span class="nc bnc" id="L2304" title="All 2 branches missed.">        for (Peer peer : peers) heights.add((int) peer.getBestHeight());</span>
<span class="nc" id="L2305">        return Utils.maxOfMostFreq(heights);</span>
    }

    /**
     * Given a list of Peers, return a Peer to be used as the download peer. If you don't want PeerGroup to manage
     * download peer statuses for you, just override this and always return null.
     */
    @Nullable
    protected Peer selectDownloadPeer(List&lt;Peer&gt; peers) {
        // Characteristics to select for in order of importance:
        //  - Chain height is reasonable (majority of nodes)
        //  - High enough protocol version for the features we want (but we'll settle for less)
        //  - Randomly, to try and spread the load.
<span class="nc bnc" id="L2318" title="All 2 branches missed.">        if (peers.isEmpty())</span>
<span class="nc" id="L2319">            return null;</span>
        // Make sure we don't select a peer that is behind/synchronizing itself.
<span class="nc" id="L2321">        int mostCommonChainHeight = getMostCommonChainHeight(peers);</span>
<span class="nc" id="L2322">        List&lt;Peer&gt; candidates = new ArrayList&lt;Peer&gt;();</span>
<span class="nc bnc" id="L2323" title="All 2 branches missed.">        for (Peer peer : peers) {</span>
<span class="nc bnc" id="L2324" title="All 2 branches missed.">            if (peer.getBestHeight() == mostCommonChainHeight) candidates.add(peer);</span>
<span class="nc" id="L2325">        }</span>
        // Of the candidates, find the peers that meet the minimum protocol version we want to target. We could select
        // the highest version we've seen on the assumption that newer versions are always better but we don't want to
        // zap peers if they upgrade early. If we can't find any peers that have our preferred protocol version or
        // better then we'll settle for the highest we found instead.
<span class="nc" id="L2330">        int highestVersion = 0, preferredVersion = 0;</span>
        // If/when PREFERRED_VERSION is not equal to vMinRequiredProtocolVersion, reenable the last test in PeerGroupTest.downloadPeerSelection
<span class="nc" id="L2332">        final int PREFERRED_VERSION = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.BLOOM_FILTER);</span>
<span class="nc bnc" id="L2333" title="All 2 branches missed.">        for (Peer peer : candidates) {</span>
<span class="nc" id="L2334">            highestVersion = Math.max(peer.getPeerVersionMessage().clientVersion, highestVersion);</span>
<span class="nc" id="L2335">            preferredVersion = Math.min(highestVersion, PREFERRED_VERSION);</span>
<span class="nc" id="L2336">        }</span>
<span class="nc" id="L2337">        ArrayList&lt;Peer&gt; candidates2 = new ArrayList&lt;Peer&gt;(candidates.size());</span>
<span class="nc bnc" id="L2338" title="All 2 branches missed.">        for (Peer peer : candidates) {</span>
<span class="nc bnc" id="L2339" title="All 2 branches missed.">            if (peer.getPeerVersionMessage().clientVersion &gt;= preferredVersion) {</span>
<span class="nc" id="L2340">                candidates2.add(peer);</span>
            }
<span class="nc" id="L2342">        }</span>
<span class="nc" id="L2343">        int index = (int) (Math.random() * candidates2.size());</span>
<span class="nc" id="L2344">        return candidates2.get(index);</span>
    }

    /**
     * Returns the currently selected download peer. Bear in mind that it may have changed as soon as this method
     * returns. Can return null if no peer was selected.
     */
    public Peer getDownloadPeer() {
<span class="nc" id="L2352">        lock.lock();</span>
        try {
<span class="nc" id="L2354">            return downloadPeer;</span>
        } finally {
<span class="nc" id="L2356">            lock.unlock();</span>
<span class="nc" id="L2357">        }</span>
    }

    /**
     * Returns the {@link com.subgraph.orchid.TorClient} object for this peer group, if Tor is in use, null otherwise.
     */
    @Nullable
    public TorClient getTorClient() {
<span class="nc" id="L2365">        return torClient;</span>
    }

    /**
     * Returns the maximum number of {@link Peer}s to discover. This maximum is checked after
     * each {@link PeerDiscovery} so this max number can be surpassed.
     * @return the maximum number of peers to discover
     */
    public int getMaxPeersToDiscoverCount() {
<span class="nc" id="L2374">        return vMaxPeersToDiscoverCount;</span>
    }

    /**
     * Sets the maximum number of {@link Peer}s to discover. This maximum is checked after
     * each {@link PeerDiscovery} so this max number can be surpassed.
     * @param maxPeersToDiscoverCount the maximum number of peers to discover
     */
    public void setMaxPeersToDiscoverCount(int maxPeersToDiscoverCount) {
<span class="nc" id="L2383">        this.vMaxPeersToDiscoverCount = maxPeersToDiscoverCount;</span>
<span class="nc" id="L2384">    }</span>

    /** See {@link #setUseLocalhostPeerWhenPossible(boolean)} */
    public boolean getUseLocalhostPeerWhenPossible() {
<span class="nc" id="L2388">        lock.lock();</span>
        try {
<span class="nc" id="L2390">            return useLocalhostPeerWhenPossible;</span>
        } finally {
<span class="nc" id="L2392">            lock.unlock();</span>
<span class="nc" id="L2393">        }</span>
    }

    /**
     * When true (the default), PeerGroup will attempt to connect to a Bitcoin node running on localhost before
     * attempting to use the P2P network. If successful, only localhost will be used. This makes for a simple
     * and easy way for a user to upgrade a mtnsj based app running in SPV mode to fully validating security.
     */
    public void setUseLocalhostPeerWhenPossible(boolean useLocalhostPeerWhenPossible) {
<span class="nc" id="L2402">        lock.lock();</span>
        try {
<span class="nc" id="L2404">            this.useLocalhostPeerWhenPossible = useLocalhostPeerWhenPossible;</span>
        } finally {
<span class="nc" id="L2406">            lock.unlock();</span>
<span class="nc" id="L2407">        }</span>
<span class="nc" id="L2408">    }</span>

    public boolean isRunning() {
<span class="fc" id="L2411">        return vRunning;</span>
    }

    /**
     * Can be used to disable Bloom filtering entirely, even in SPV mode. You are very unlikely to need this, it is
     * an optimisation for rare cases when full validation is not required but it's still more efficient to download
     * full blocks than filtered blocks.
     */
    public void setBloomFilteringEnabled(boolean bloomFilteringEnabled) {
<span class="nc" id="L2420">        this.vBloomFilteringEnabled = bloomFilteringEnabled;</span>
<span class="nc" id="L2421">    }</span>

    /** Returns whether the Bloom filtering protocol optimisation is in use: defaults to true. */
    public boolean isBloomFilteringEnabled() {
<span class="nc" id="L2425">        return vBloomFilteringEnabled;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>