<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractBlockChain.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mtnsj</a> &gt; <a href="index.source.html" class="el_package">site.mtnsj.core</a> &gt; <span class="el_source">AbstractBlockChain.java</span></div><h1>AbstractBlockChain.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2012 Google Inc.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * modified OmotenashiCoin Project by kani
 */

package site.mtnsj.core;

import com.google.common.base.*;
import com.google.common.collect.*;
import com.google.common.util.concurrent.*;
import site.mtnsj.core.listeners.*;
import site.mtnsj.store.*;
import site.mtnsj.utils.*;
import site.mtnsj.wallet.Wallet;
import org.slf4j.*;

import javax.annotation.*;
import java.math.BigInteger;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.*;

import static com.google.common.base.Preconditions.*;

/**
 * &lt;p&gt;An AbstractBlockChain holds a series of {@link Block} objects, links them together, and knows how to verify that
 * the chain follows the rules of the {@link NetworkParameters} for this chain.&lt;/p&gt;
 *
 * &lt;p&gt;It can be connected to a {@link Wallet}, and also {@link TransactionReceivedInBlockListener}s that can receive transactions and
 * notifications of re-organizations.&lt;/p&gt;
 *
 * &lt;p&gt;An AbstractBlockChain implementation must be connected to a {@link BlockStore} implementation. The chain object
 * by itself doesn't store any data, that's delegated to the store. Which store you use is a decision best made by
 * reading the getting started guide, but briefly, fully validating block chains need fully validating stores. In
 * the lightweight SPV mode, a {@link site.mtnsj.store.SPVBlockStore} is the right choice.&lt;/p&gt;
 *
 * &lt;p&gt;This class implements an abstract class which makes it simple to create a BlockChain that does/doesn't do full
 * verification.  It verifies headers and is implements most of what is required to implement SPV mode, but
 * also provides callback hooks which can be used to do full verification.&lt;/p&gt;
 *
 * &lt;p&gt;There are two subclasses of AbstractBlockChain that are useful: {@link BlockChain}, which is the simplest
 * class and implements &lt;i&gt;simplified payment verification&lt;/i&gt;. This is a lightweight and efficient mode that does
 * not verify the contents of blocks, just their headers. A {@link FullPrunedBlockChain} paired with a
 * {@link site.mtnsj.store.H2FullPrunedBlockStore} implements full verification, which is equivalent to
 * Bitcoin Core. To learn more about the alternative security models, please consult the articles on the
 * website.&lt;/p&gt;
 *
 * &lt;b&gt;Theory&lt;/b&gt;
 *
 * &lt;p&gt;The 'chain' is actually a tree although in normal operation it operates mostly as a list of {@link Block}s.
 * When multiple new head blocks are found simultaneously, there are multiple stories of the economy competing to become
 * the one true consensus. This can happen naturally when two miners solve a block within a few seconds of each other,
 * or it can happen when the chain is under attack.&lt;/p&gt;
 *
 * &lt;p&gt;A reference to the head block of the best known chain is stored. If you can reach the genesis block by repeatedly
 * walking through the prevBlock pointers, then we say this is a full chain. If you cannot reach the genesis block
 * we say it is an orphan chain. Orphan chains can occur when blocks are solved and received during the initial block
 * chain download, or if we connect to a peer that doesn't send us blocks in order.&lt;/p&gt;
 *
 * &lt;p&gt;A reorganize occurs when the blocks that make up the best known chain changes. Note that simply adding a
 * new block to the top of the best chain isn't as reorganize, but that a reorganize is always triggered by adding
 * a new block that connects to some other (non best head) block. By &quot;best&quot; we mean the chain representing the largest
 * amount of work done.&lt;/p&gt;
 *
 * &lt;p&gt;Every so often the block chain passes a difficulty transition point. At that time, all the blocks in the last
 * 2016 blocks are examined and a new difficulty target is calculated from them.&lt;/p&gt;
 */
public abstract class AbstractBlockChain {
<span class="fc" id="L82">    private static final Logger log = LoggerFactory.getLogger(AbstractBlockChain.class);</span>
<span class="fc" id="L83">    protected final ReentrantLock lock = Threading.lock(&quot;blockchain&quot;);</span>

    /** Keeps a map of block hashes to StoredBlocks. */
    private final BlockStore blockStore;

    /**
     * Tracks the top of the best known chain.&lt;p&gt;
     *
     * Following this one down to the genesis block produces the story of the economy from the creation of Bitcoin
     * until the present day. The chain head can change if a new set of blocks is received that results in a chain of
     * greater work than the one obtained by following this one down. In that case a reorganize is triggered,
     * potentially invalidating transactions in our wallet.
     */
    protected StoredBlock chainHead;

    // TODO: Scrap this and use a proper read/write for all of the block chain objects.
    // The chainHead field is read/written synchronized with this object rather than BlockChain. However writing is
    // also guaranteed to happen whilst BlockChain is synchronized (see setChainHead). The goal of this is to let
    // clients quickly access the chain head even whilst the block chain is downloading and thus the BlockChain is
    // locked most of the time.
<span class="fc" id="L103">    private final Object chainHeadLock = new Object();</span>

    protected final NetworkParameters params;
    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;NewBestBlockListener&gt;&gt; newBestBlockListeners;
    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;ReorganizeListener&gt;&gt; reorganizeListeners;
    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;TransactionReceivedInBlockListener&gt;&gt; transactionReceivedListeners;

    // Holds a block header and, optionally, a list of tx hashes or block's transactions
    class OrphanBlock {
        final Block block;
        final List&lt;Sha256Hash&gt; filteredTxHashes;
        final Map&lt;Sha256Hash, Transaction&gt; filteredTxn;
<span class="fc" id="L115">        OrphanBlock(Block block, @Nullable List&lt;Sha256Hash&gt; filteredTxHashes, @Nullable Map&lt;Sha256Hash, Transaction&gt; filteredTxn) {</span>
<span class="pc bpc" id="L116" title="3 of 4 branches missed.">            final boolean filtered = filteredTxHashes != null &amp;&amp; filteredTxn != null;</span>
<span class="pc bpc" id="L117" title="5 of 8 branches missed.">            Preconditions.checkArgument((block.transactions == null &amp;&amp; filtered)</span>
                                        || (block.transactions != null &amp;&amp; !filtered));
<span class="fc" id="L119">            this.block = block;</span>
<span class="fc" id="L120">            this.filteredTxHashes = filteredTxHashes;</span>
<span class="fc" id="L121">            this.filteredTxn = filteredTxn;</span>
<span class="fc" id="L122">        }</span>
    }
    // Holds blocks that we have received but can't plug into the chain yet, eg because they were created whilst we
    // were downloading the block chain.
<span class="fc" id="L126">    private final LinkedHashMap&lt;Sha256Hash, OrphanBlock&gt; orphanBlocks = new LinkedHashMap&lt;Sha256Hash, OrphanBlock&gt;();</span>

    /** False positive estimation uses a double exponential moving average. */
    public static final double FP_ESTIMATOR_ALPHA = 0.0001;
    /** False positive estimation uses a double exponential moving average. */
    public static final double FP_ESTIMATOR_BETA = 0.01;

    private double falsePositiveRate;
    private double falsePositiveTrend;
    private double previousFalsePositiveRate;

    private final VersionTally versionTally;

    /** See {@link #AbstractBlockChain(Context, List, BlockStore)} */
    public AbstractBlockChain(NetworkParameters params, List&lt;? extends Wallet&gt; transactionReceivedListeners,
                              BlockStore blockStore) throws BlockStoreException {
<span class="nc" id="L142">        this(Context.getOrCreate(params), transactionReceivedListeners, blockStore);</span>
<span class="nc" id="L143">    }</span>

    /**
     * Constructs a BlockChain connected to the given list of listeners (eg, wallets) and a store.
     */
    public AbstractBlockChain(Context context, List&lt;? extends Wallet&gt; wallets,
<span class="fc" id="L149">                              BlockStore blockStore) throws BlockStoreException {</span>
<span class="fc" id="L150">        this.blockStore = blockStore;</span>
<span class="fc" id="L151">        chainHead = blockStore.getChainHead();</span>
<span class="fc" id="L152">        log.info(&quot;chain head is at height {}:\n{}&quot;, chainHead.getHeight(), chainHead.getHeader());</span>
<span class="fc" id="L153">        this.params = context.getParams();</span>

<span class="fc" id="L155">        this.newBestBlockListeners = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;NewBestBlockListener&gt;&gt;();</span>
<span class="fc" id="L156">        this.reorganizeListeners = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;ReorganizeListener&gt;&gt;();</span>
<span class="fc" id="L157">        this.transactionReceivedListeners = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;TransactionReceivedInBlockListener&gt;&gt;();</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">        for (NewBestBlockListener l : wallets) addNewBestBlockListener(Threading.SAME_THREAD, l);</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        for (ReorganizeListener l : wallets) addReorganizeListener(Threading.SAME_THREAD, l);</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        for (TransactionReceivedInBlockListener l : wallets) addTransactionReceivedListener(Threading.SAME_THREAD, l);</span>

<span class="fc" id="L162">        this.versionTally = new VersionTally(context.getParams());</span>
<span class="fc" id="L163">        this.versionTally.initialize(blockStore, chainHead);</span>
<span class="fc" id="L164">    }</span>

    /**
     * Add a wallet to the BlockChain. Note that the wallet will be unaffected by any blocks received while it
     * was not part of this BlockChain. This method is useful if the wallet has just been created, and its keys
     * have never been in use, or if the wallet has been loaded along with the BlockChain. Note that adding multiple
     * wallets is not well tested!
     */
    public final void addWallet(Wallet wallet) {
<span class="fc" id="L173">        addNewBestBlockListener(Threading.SAME_THREAD, wallet);</span>
<span class="fc" id="L174">        addReorganizeListener(Threading.SAME_THREAD, wallet);</span>
<span class="fc" id="L175">        addTransactionReceivedListener(Threading.SAME_THREAD, wallet);</span>
<span class="fc" id="L176">        int walletHeight = wallet.getLastBlockSeenHeight();</span>
<span class="fc" id="L177">        int chainHeight = getBestChainHeight();</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (walletHeight != chainHeight) {</span>
<span class="fc" id="L179">            log.warn(&quot;Wallet/chain height mismatch: {} vs {}&quot;, walletHeight, chainHeight);</span>
<span class="fc" id="L180">            log.warn(&quot;Hashes: {} vs {}&quot;, wallet.getLastBlockSeenHash(), getChainHead().getHeader().getHash());</span>

            // This special case happens when the VM crashes because of a transaction received. It causes the updated
            // block store to persist, but not the wallet. In order to fix the issue, we roll back the block store to
            // the wallet height to make it look like as if the block has never been received.
<span class="pc bpc" id="L185" title="2 of 4 branches missed.">            if (walletHeight &lt; chainHeight &amp;&amp; walletHeight &gt; 0) {</span>
                try {
<span class="fc" id="L187">                    rollbackBlockStore(walletHeight);</span>
<span class="fc" id="L188">                    log.info(&quot;Rolled back block store to height {}.&quot;, walletHeight);</span>
<span class="nc" id="L189">                } catch (BlockStoreException x) {</span>
<span class="nc" id="L190">                    log.warn(&quot;Rollback of block store failed, continuing with mismatched heights. This can happen due to a replay.&quot;);</span>
<span class="fc" id="L191">                }</span>
            }
        }
<span class="fc" id="L194">    }</span>

    /** Removes a wallet from the chain. */
    public void removeWallet(Wallet wallet) {
<span class="fc" id="L198">        removeNewBestBlockListener(wallet);</span>
<span class="fc" id="L199">        removeReorganizeListener(wallet);</span>
<span class="fc" id="L200">        removeTransactionReceivedListener(wallet);</span>
<span class="fc" id="L201">    }</span>

    /** Replaced with more specific listener methods: use them instead. */
    @Deprecated @SuppressWarnings(&quot;deprecation&quot;)
    public void addListener(BlockChainListener listener) {
<span class="nc" id="L206">        addListener(listener, Threading.USER_THREAD);</span>
<span class="nc" id="L207">    }</span>

    /** Replaced with more specific listener methods: use them instead. */
    @Deprecated
    public void addListener(BlockChainListener listener, Executor executor) {
<span class="nc" id="L212">        addReorganizeListener(executor, listener);</span>
<span class="nc" id="L213">        addNewBestBlockListener(executor, listener);</span>
<span class="nc" id="L214">        addTransactionReceivedListener(executor, listener);</span>
<span class="nc" id="L215">    }</span>

    @Deprecated
    public void removeListener(BlockChainListener listener) {
<span class="nc" id="L219">        removeReorganizeListener(listener);</span>
<span class="nc" id="L220">        removeNewBestBlockListener(listener);</span>
<span class="nc" id="L221">        removeTransactionReceivedListener(listener);</span>
<span class="nc" id="L222">    }</span>

    /**
     * Adds a {@link NewBestBlockListener} listener to the chain.
     */
    public void addNewBestBlockListener(NewBestBlockListener listener) {
<span class="nc" id="L228">        addNewBestBlockListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L229">    }</span>

    /**
     * Adds a {@link NewBestBlockListener} listener to the chain.
     */
    public final void addNewBestBlockListener(Executor executor, NewBestBlockListener listener) {
<span class="fc" id="L235">        newBestBlockListeners.add(new ListenerRegistration&lt;NewBestBlockListener&gt;(listener, executor));</span>
<span class="fc" id="L236">    }</span>

    /**
     * Adds a generic {@link ReorganizeListener} listener to the chain.
     */
    public void addReorganizeListener(ReorganizeListener listener) {
<span class="nc" id="L242">        addReorganizeListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L243">    }</span>

    /**
     * Adds a generic {@link ReorganizeListener} listener to the chain.
     */
    public final void addReorganizeListener(Executor executor, ReorganizeListener listener) {
<span class="fc" id="L249">        reorganizeListeners.add(new ListenerRegistration&lt;ReorganizeListener&gt;(listener, executor));</span>
<span class="fc" id="L250">    }</span>

    /**
     * Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
     */
    public void addTransactionReceivedListener(TransactionReceivedInBlockListener listener) {
<span class="nc" id="L256">        addTransactionReceivedListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L257">    }</span>

    /**
     * Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
     */
    public final void addTransactionReceivedListener(Executor executor, TransactionReceivedInBlockListener listener) {
<span class="fc" id="L263">        transactionReceivedListeners.add(new ListenerRegistration&lt;TransactionReceivedInBlockListener&gt;(listener, executor));</span>
<span class="fc" id="L264">    }</span>

    /**
     * Removes the given {@link NewBestBlockListener} from the chain.
     */
    public void removeNewBestBlockListener(NewBestBlockListener listener) {
<span class="fc" id="L270">        ListenerRegistration.removeFromList(listener, newBestBlockListeners);</span>
<span class="fc" id="L271">    }</span>

    /**
     * Removes the given {@link ReorganizeListener} from the chain.
     */
    public void removeReorganizeListener(ReorganizeListener listener) {
<span class="fc" id="L277">        ListenerRegistration.removeFromList(listener, reorganizeListeners);</span>
<span class="fc" id="L278">    }</span>

    /**
     * Removes the given {@link TransactionReceivedInBlockListener} from the chain.
     */
    public void removeTransactionReceivedListener(TransactionReceivedInBlockListener listener) {
<span class="fc" id="L284">        ListenerRegistration.removeFromList(listener, transactionReceivedListeners);</span>
<span class="fc" id="L285">    }</span>
    
    /**
     * Returns the {@link BlockStore} the chain was constructed with. You can use this to iterate over the chain.
     */
    public BlockStore getBlockStore() {
<span class="nc" id="L291">        return blockStore;</span>
    }
    
    /**
     * Adds/updates the given {@link Block} with the block store.
     * This version is used when the transactions have not been verified.
     * @param storedPrev The {@link StoredBlock} which immediately precedes block.
     * @param block The {@link Block} to add/update.
     * @return the newly created {@link StoredBlock}
     */
    protected abstract StoredBlock addToBlockStore(StoredBlock storedPrev, Block block)
            throws BlockStoreException, VerificationException;
    
    /**
     * Adds/updates the given {@link StoredBlock} with the block store.
     * This version is used when the transactions have already been verified to properly spend txOutputChanges.
     * @param storedPrev The {@link StoredBlock} which immediately precedes block.
     * @param header The {@link StoredBlock} to add/update.
     * @param txOutputChanges The total sum of all changes made by this block to the set of open transaction outputs
     *                        (from a call to connectTransactions), if in fully verifying mode (null otherwise).
     * @return the newly created {@link StoredBlock}
     */
    protected abstract StoredBlock addToBlockStore(StoredBlock storedPrev, Block header,
                                                   @Nullable TransactionOutputChanges txOutputChanges)
            throws BlockStoreException, VerificationException;

    /**
     * Rollback the block store to a given height. This is currently only supported by {@link BlockChain} instances.
     * 
     * @throws BlockStoreException
     *             if the operation fails or is unsupported.
     */
    protected abstract void rollbackBlockStore(int height) throws BlockStoreException;

    /**
     * Called before setting chain head in memory.
     * Should write the new head to block store and then commit any database transactions
     * that were started by disconnectTransactions/connectTransactions.
     */
    protected abstract void doSetChainHead(StoredBlock chainHead) throws BlockStoreException;
    
    /**
     * Called if we (possibly) previously called disconnectTransaction/connectTransactions,
     * but will not be calling preSetChainHead as a block failed verification.
     * Can be used to abort database transactions that were started by
     * disconnectTransactions/connectTransactions.
     */
    protected abstract void notSettingChainHead() throws BlockStoreException;
    
    /**
     * For a standard BlockChain, this should return blockStore.get(hash),
     * for a FullPrunedBlockChain blockStore.getOnceUndoableStoredBlock(hash)
     */
    protected abstract StoredBlock getStoredBlockInCurrentScope(Sha256Hash hash) throws BlockStoreException;

    /**
     * Processes a received block and tries to add it to the chain. If there's something wrong with the block an
     * exception is thrown. If the block is OK but cannot be connected to the chain at this time, returns false.
     * If the block can be connected to the chain, returns true.
     * Accessing block's transactions in another thread while this method runs may result in undefined behavior.
     */
    public boolean add(Block block) throws VerificationException, PrunedException {
        try {
<span class="fc" id="L354">            return add(block, true, null, null);</span>
<span class="nc" id="L355">        } catch (BlockStoreException e) {</span>
            // TODO: Figure out a better way to propagate this exception to the user.
<span class="nc" id="L357">            throw new RuntimeException(e);</span>
<span class="fc" id="L358">        } catch (VerificationException e) {</span>
            try {
<span class="fc" id="L360">                notSettingChainHead();</span>
<span class="nc" id="L361">            } catch (BlockStoreException e1) {</span>
<span class="nc" id="L362">                throw new RuntimeException(e1);</span>
<span class="fc" id="L363">            }</span>
<span class="fc" id="L364">            throw new VerificationException(&quot;Could not verify block:\n&quot; +</span>
<span class="fc" id="L365">                    block.toString(), e);</span>
        }
    }
    
    /**
     * Processes a received block and tries to add it to the chain. If there's something wrong with the block an
     * exception is thrown. If the block is OK but cannot be connected to the chain at this time, returns false.
     * If the block can be connected to the chain, returns true.
     */
    public boolean add(FilteredBlock block) throws VerificationException, PrunedException {
        try {
            // The block has a list of hashes of transactions that matched the Bloom filter, and a list of associated
            // Transaction objects. There may be fewer Transaction objects than hashes, this is expected. It can happen
            // in the case where we were already around to witness the initial broadcast, so we downloaded the
            // transaction and sent it to the wallet before this point (the wallet may have thrown it away if it was
            // a false positive, as expected in any Bloom filtering scheme). The filteredTxn list here will usually
            // only be full of data when we are catching up to the head of the chain and thus haven't witnessed any
            // of the transactions.
<span class="nc" id="L383">            return add(block.getBlockHeader(), true, block.getTransactionHashes(), block.getAssociatedTransactions());</span>
<span class="nc" id="L384">        } catch (BlockStoreException e) {</span>
            // TODO: Figure out a better way to propagate this exception to the user.
<span class="nc" id="L386">            throw new RuntimeException(e);</span>
<span class="nc" id="L387">        } catch (VerificationException e) {</span>
            try {
<span class="nc" id="L389">                notSettingChainHead();</span>
<span class="nc" id="L390">            } catch (BlockStoreException e1) {</span>
<span class="nc" id="L391">                throw new RuntimeException(e1);</span>
<span class="nc" id="L392">            }</span>
<span class="nc" id="L393">            throw new VerificationException(&quot;Could not verify block &quot; + block.getHash().toString() + &quot;\n&quot; +</span>
<span class="nc" id="L394">                    block.toString(), e);</span>
        }
    }
    
    /**
     * Whether or not we are maintaining a set of unspent outputs and are verifying all transactions.
     * Also indicates that all calls to add() should provide a block containing transactions
     */
    protected abstract boolean shouldVerifyTransactions();
    
    /**
     * Connect each transaction in block.transactions, verifying them as we go and removing spent outputs
     * If an error is encountered in a transaction, no changes should be made to the underlying BlockStore.
     * and a VerificationException should be thrown.
     * Only called if(shouldVerifyTransactions())
     * @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     * @throws BlockStoreException if the block store had an underlying error.
     * @return The full set of all changes made to the set of open transaction outputs.
     */
    protected abstract TransactionOutputChanges connectTransactions(int height, Block block) throws VerificationException, BlockStoreException;

    /**
     * Load newBlock from BlockStore and connect its transactions, returning changes to the set of unspent transactions.
     * If an error is encountered in a transaction, no changes should be made to the underlying BlockStore.
     * Only called if(shouldVerifyTransactions())
     * @throws PrunedException if newBlock does not exist as a {@link StoredUndoableBlock} in the block store.
     * @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     * @throws BlockStoreException if the block store had an underlying error or newBlock does not exist in the block store at all.
     * @return The full set of all changes made to the set of open transaction outputs.
     */
    protected abstract TransactionOutputChanges connectTransactions(StoredBlock newBlock) throws VerificationException, BlockStoreException, PrunedException;    
    
    // filteredTxHashList contains all transactions, filteredTxn just a subset
    private boolean add(Block block, boolean tryConnecting,
                        @Nullable List&lt;Sha256Hash&gt; filteredTxHashList, @Nullable Map&lt;Sha256Hash, Transaction&gt; filteredTxn)
            throws BlockStoreException, VerificationException, PrunedException {
        // TODO: Use read/write locks to ensure that during chain download properties are still low latency.
<span class="fc" id="L431">        lock.lock();</span>
        try {
            // Quick check for duplicates to avoid an expensive check further down (in findSplit). This can happen a lot
            // when connecting orphan transactions due to the dumb brute force algorithm we use.
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">            if (block.equals(getChainHead().getHeader())) {</span>
<span class="nc" id="L436">                return true;</span>
            }
<span class="pc bpc" id="L438" title="1 of 4 branches missed.">            if (tryConnecting &amp;&amp; orphanBlocks.containsKey(block.getHash())) {</span>
<span class="nc" id="L439">                log.info(&quot;orphanBlock..&quot;);</span>
<span class="nc" id="L440">                return false;</span>
            }

            // If we want to verify transactions (ie we are running with full blocks), verify that block has transactions
<span class="pc bpc" id="L444" title="1 of 4 branches missed.">            if (shouldVerifyTransactions() &amp;&amp; block.transactions == null)</span>
<span class="nc" id="L445">                throw new VerificationException(&quot;Got a block header while running in full-block mode&quot;);</span>

            // Check for already-seen block, but only for full pruned mode, where the DB is
            // more likely able to handle these queries quickly.
<span class="pc bpc" id="L449" title="1 of 4 branches missed.">            if (shouldVerifyTransactions() &amp;&amp; blockStore.get(block.getHash()) != null) {</span>
<span class="nc" id="L450">                return true;</span>
            }

            final StoredBlock storedPrev;
            final int height;
            final EnumSet&lt;Block.VerifyFlag&gt; flags;

            // Prove the block is internally valid: hash is lower than target, etc. This only checks the block contents
            // if there is a tx sending or receiving coins using an address in one of our wallets. And those transactions
            // are only lightly verified: presence in a valid connecting block is taken as proof of validity. See the
            // article here for more details: https://bitcoinj.github.io/security-model
            try {
<span class="fc" id="L462">                block.verifyHeader();</span>
                //System.out.println(&quot;New block previous hash: &quot;+block.getPrevBlockHash());
<span class="fc" id="L464">                storedPrev = getStoredBlockInCurrentScope(block.getPrevBlockHash());</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">                if (storedPrev!=null) {</span>
                    //System.out.println(&quot;New block, previous stored block from db: &quot; + storedPrev.getHeader().getHashAsString());
<span class="fc" id="L467">                    checkArgument(block.getPrevBlockHash().equals(storedPrev.getHeader().getHash()), &quot;Database saving shit.. prev hash block: &quot; + block.getPrevBlockHash() + &quot;, db prev hash: &quot; + storedPrev.getHeader().getHashAsString());</span>
                }

<span class="fc bfc" id="L470" title="All 2 branches covered.">                if (storedPrev != null) {</span>
<span class="fc" id="L471">                    height = storedPrev.getHeight() + 1;</span>
                    //System.out.println(&quot;Adding Block: &quot;+height+&quot; hash &quot;+block.getHashAsString()+&quot;, Prev block &quot;+storedPrev.getHeight()+&quot; hash: &quot;+block.getPrevBlockHash().toString());
                } else {
                    //System.out.println(&quot;block height unknown&quot;);
<span class="fc" id="L475">                    height = Block.BLOCK_HEIGHT_UNKNOWN;</span>
                }
<span class="fc" id="L477">                flags = params.getBlockVerificationFlags(block, versionTally, height);</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">                if (shouldVerifyTransactions())</span>
<span class="fc" id="L479">                    block.verifyTransactions(height, flags);</span>
<span class="nc" id="L480">            } catch (VerificationException e) {</span>
<span class="nc" id="L481">                log.error(&quot;Failed to verify block: &quot;, e);</span>
<span class="nc" id="L482">                log.error(block.getHashAsString());</span>
<span class="nc" id="L483">                throw e;</span>
<span class="fc" id="L484">            }</span>

            // Try linking it to a place in the currently known blocks.

<span class="fc bfc" id="L488" title="All 2 branches covered.">            if (storedPrev == null) {</span>
                // We can't find the previous block. Probably we are still in the process of downloading the chain and a
                // block was solved whilst we were doing it. We put it to one side and try to connect it later when we
                // have more blocks.
<span class="fc" id="L492">                checkState(tryConnecting, &quot;bug in tryConnectingOrphans&quot;);</span>
<span class="fc" id="L493">                log.warn(&quot;Block does not connect: {} prev {}&quot;, block.getHashAsString(), block.getPrevBlockHash());</span>
<span class="fc" id="L494">                orphanBlocks.put(block.getHash(), new OrphanBlock(block, filteredTxHashList, filteredTxn));</span>
<span class="fc" id="L495">                return false;</span>
            } else {
<span class="fc" id="L497">                checkState(lock.isHeldByCurrentThread());</span>
                // It connects to somewhere on the chain. Not necessarily the top of the best known chain.
                //context.checkDifficultyTransitions(storedPrev, block, blockStore);
                //todo furszy: i'm not checking the difficulty yet
                //todo: this should be checked on a MN wallet service.
                //checkDifficultyTransitions(storedPrev, block);
                //System.out.println(&quot;going to connect block with accumulator: &quot;+block.getAccumulator().toString());
<span class="fc" id="L504">                connectBlock(block, storedPrev, shouldVerifyTransactions(), filteredTxHashList, filteredTxn);</span>
            }

<span class="fc bfc" id="L507" title="All 2 branches covered.">            if (tryConnecting)</span>
<span class="fc" id="L508">                tryConnectingOrphans();</span>

<span class="fc" id="L510">            return true;</span>
        } finally {
<span class="pc" id="L512">            lock.unlock();</span>
<span class="fc" id="L513">        }</span>
    }

    /**
     * Returns the hashes of the currently stored orphan blocks and then deletes them from this objects storage.
     * Used by Peer when a filter exhaustion event has occurred and thus any orphan blocks that have been downloaded
     * might be inaccurate/incomplete.
     */
    public Set&lt;Sha256Hash&gt; drainOrphanBlocks() {
<span class="nc" id="L522">        lock.lock();</span>
        try {
<span class="nc" id="L524">            Set&lt;Sha256Hash&gt; hashes = new HashSet&lt;Sha256Hash&gt;(orphanBlocks.keySet());</span>
<span class="nc" id="L525">            orphanBlocks.clear();</span>
<span class="nc" id="L526">            return hashes;</span>
        } finally {
<span class="nc" id="L528">            lock.unlock();</span>
<span class="nc" id="L529">        }</span>
    }

    // expensiveChecks enables checks that require looking at blocks further back in the chain
    // than the previous one when connecting (eg median timestamp check)
    // It could be exposed, but for now we just set it to shouldVerifyTransactions()
    private void connectBlock(final Block block, StoredBlock storedPrev, boolean expensiveChecks,
                              @Nullable final List&lt;Sha256Hash&gt; filteredTxHashList,
                              @Nullable final Map&lt;Sha256Hash, Transaction&gt; filteredTxn) throws BlockStoreException, VerificationException, PrunedException {
<span class="fc" id="L538">        checkState(lock.isHeldByCurrentThread());</span>
<span class="pc bpc" id="L539" title="3 of 4 branches missed.">        boolean filtered = filteredTxHashList != null &amp;&amp; filteredTxn != null;</span>
        // Check that we aren't connecting a block that fails a checkpoint check
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">        if (!params.passesCheckpoint(storedPrev.getHeight() + 1, block.getHash()))</span>
<span class="nc" id="L542">            throw new VerificationException(&quot;Block failed checkpoint lockin at &quot; + (storedPrev.getHeight() + 1));</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (shouldVerifyTransactions()) {</span>
<span class="fc" id="L544">            checkNotNull(block.transactions);</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">            for (Transaction tx : block.transactions)</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">                if (!tx.isFinal(storedPrev.getHeight() + 1, block.getTimeSeconds()))</span>
<span class="nc" id="L547">                   throw new VerificationException(&quot;Block contains non-final transaction&quot;);</span>
        }
        
<span class="fc" id="L550">        StoredBlock head = getChainHead();</span>
       // System.out.println(&quot;New block: &quot;+block.toString());
        //System.out.println(&quot;Head height: &quot;+head.getHeight() + &quot; hash: &quot;+head.getHeader().getHashAsString()
        //        + &quot; Previous block stored height: &quot;+storedPrev.getHeight());
<span class="fc bfc" id="L554" title="All 2 branches covered.">        if (storedPrev.equals(head)) {</span>
<span class="pc bpc" id="L555" title="3 of 4 branches missed.">            if (filtered &amp;&amp; filteredTxn.size() &gt; 0)  {</span>
<span class="nc" id="L556">                log.debug(&quot;Block {} connects to top of best chain with {} transaction(s) of which we were sent {}&quot;,</span>
<span class="nc" id="L557">                        block.getHashAsString(), filteredTxHashList.size(), filteredTxn.size());</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">                for (Sha256Hash hash : filteredTxHashList) log.debug(&quot;  matched tx {}&quot;, hash);</span>
            }
<span class="pc bpc" id="L560" title="1 of 4 branches missed.">            if (expensiveChecks &amp;&amp; block.getTimeSeconds() &lt;= getMedianTimestampOfRecentBlocks(head, blockStore))</span>
<span class="nc" id="L561">                throw new VerificationException(&quot;Block's timestamp is too early&quot;);</span>

            // BIP 66 &amp; 65: Enforce block version 3/4 once they are a supermajority of blocks
            // NOTE: This requires 1,000 blocks since the last checkpoint (on main
            // net, less on test) in order to be applied. It is also limited to
            // stopping addition of new v2/3 blocks to the tip of the chain.
            // TODO: check this.
            //if (block.getVersion() == Block.BLOCK_VERSION_BIP34
            //    || block.getVersion() == Block.BLOCK_VERSION_BIP66) {
            //    final Integer count = versionTally.getCountAtOrAbove(block.getVersion() + 1);
            //    if (count != null
            //        &amp;&amp; count &gt;= params.getMajorityRejectBlockOutdated()) {
            //        throw new VerificationException.BlockVersionOutOfDate(block.getVersion());
            //    }
            //}

            // This block connects to the best known block, it is a normal continuation of the system.
<span class="fc" id="L578">            TransactionOutputChanges txOutChanges = null;</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">            if (shouldVerifyTransactions())</span>
<span class="fc" id="L580">                txOutChanges = connectTransactions(storedPrev.getHeight() + 1, block);</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">            StoredBlock newStoredBlock = addToBlockStore(storedPrev,</span>
<span class="fc" id="L582">                    block.transactions == null ? block : block.cloneAsHeader(), txOutChanges);</span>
<span class="fc" id="L583">            versionTally.add(block.getVersion());</span>
<span class="fc" id="L584">            setChainHead(newStoredBlock);</span>
<span class="fc" id="L585">            log.debug(&quot;Chain is now {} blocks high, running listeners&quot;, newStoredBlock.getHeight());</span>
<span class="fc" id="L586">            informListenersForNewBlock(block, NewBlockType.BEST_CHAIN, filteredTxHashList, filteredTxn, newStoredBlock);</span>
<span class="fc" id="L587">        } else {</span>
            //System.out.println(&quot;#####################&quot;);
            //System.out.println(&quot;block not connect to the blockchain heads..&quot;);
            //System.out.println(&quot;head chain: &quot;+head.getHeader().getHashAsString());
            //System.out.println(&quot;Stored block: &quot;+storedPrev.getHeader().getHashAsString());
            //System.out.println(&quot;New block work: &quot;+block.getHashAsString());
            //System.out.println(&quot;#####################&quot;);
            // This block connects to somewhere other than the top of the best known chain. We treat these differently.
            //
            // Note that we send the transactions to the wallet FIRST, even if we're about to re-organize this block
            // to become the new best chain head. This simplifies handling of the re-org in the Wallet class.
<span class="fc" id="L598">            StoredBlock newBlock = storedPrev.build(block);</span>
<span class="fc" id="L599">            boolean haveNewBestChain = newBlock.moreWorkThan(head);</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">            if (haveNewBestChain) {</span>
<span class="fc" id="L601">                log.info(&quot;Block is causing a re-organize, block height: &quot;+newBlock.getHeight()+&quot;, &quot;</span>
<span class="fc" id="L602">                + &quot; new block bits: &quot;+newBlock.getChainWork()+&quot; -&gt; height: &quot;+newBlock.getHeight()+&quot;, old block bits: &quot;+storedPrev.getChainWork()+&quot; -&gt; height: &quot;+storedPrev.getHeight());</span>
            } else {
<span class="fc" id="L604">                StoredBlock splitPoint = findSplit(newBlock, head, blockStore);</span>
<span class="pc bpc" id="L605" title="1 of 4 branches missed.">                if (splitPoint != null &amp;&amp; splitPoint.equals(newBlock)) {</span>
                    // newStoredBlock is a part of the same chain, there's no fork. This happens when we receive a block
                    // that we already saw and linked into the chain previously, which isn't the chain head.
                    // Re-processing it is confusing for the wallet so just skip.
<span class="fc" id="L609">                    log.warn(&quot;Saw duplicated block in main chain at height {}: {}&quot;,</span>
<span class="fc" id="L610">                            newBlock.getHeight(), newBlock.getHeader().getHash());</span>
<span class="fc" id="L611">                    return;</span>
                }
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">                if (splitPoint == null) {</span>
                    // This should absolutely never happen
                    // (lets not write the full block to disk to keep any bugs which allow this to happen
                    //  from writing unreasonable amounts of data to disk)
<span class="nc" id="L617">                    throw new VerificationException(&quot;Block forks the chain but splitPoint is null&quot;);</span>
                } else {
                    // We aren't actually spending any transactions (yet) because we are on a fork
<span class="fc" id="L620">                    addToBlockStore(storedPrev, block);</span>
<span class="fc" id="L621">                    int splitPointHeight = splitPoint.getHeight();</span>
<span class="fc" id="L622">                    String splitPointHash = splitPoint.getHeader().getHashAsString();</span>
<span class="fc" id="L623">                    log.info(&quot;Block forks the chain at height {}/block {}, but it did not cause a reorganize:\n{}&quot;,</span>
<span class="fc" id="L624">                            splitPointHeight, splitPointHash, newBlock.getHeader().getHashAsString());</span>
                }
            }
            
            // We may not have any transactions if we received only a header, which can happen during fast catchup.
            // If we do, send them to the wallet but state that they are on a side chain so it knows not to try and
            // spend them until they become activated.
<span class="pc bpc" id="L631" title="3 of 4 branches missed.">            if (block.transactions != null || filtered) {</span>
<span class="fc" id="L632">                informListenersForNewBlock(block, NewBlockType.SIDE_CHAIN, filteredTxHashList, filteredTxn, newBlock);</span>
            }
            
<span class="fc bfc" id="L635" title="All 2 branches covered.">            if (haveNewBestChain)</span>
<span class="fc" id="L636">                handleNewBestChain(storedPrev, newBlock, block, expensiveChecks);</span>
        }
<span class="fc" id="L638">    }</span>

    private void informListenersForNewBlock(final Block block, final NewBlockType newBlockType,
                                            @Nullable final List&lt;Sha256Hash&gt; filteredTxHashList,
                                            @Nullable final Map&lt;Sha256Hash, Transaction&gt; filteredTxn,
                                            final StoredBlock newStoredBlock) throws VerificationException {
        // Notify the listeners of the new block, so the depth and workDone of stored transactions can be updated
        // (in the case of the listener being a wallet). Wallets need to know how deep each transaction is so
        // coinbases aren't used before maturity.
<span class="fc" id="L647">        boolean first = true;</span>
<span class="fc" id="L648">        Set&lt;Sha256Hash&gt; falsePositives = Sets.newHashSet();</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">        if (filteredTxHashList != null) falsePositives.addAll(filteredTxHashList);</span>

<span class="fc bfc" id="L651" title="All 2 branches covered.">        for (final ListenerRegistration&lt;TransactionReceivedInBlockListener&gt; registration : transactionReceivedListeners) {</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">            if (registration.executor == Threading.SAME_THREAD) {</span>
<span class="fc" id="L653">                informListenerForNewTransactions(block, newBlockType, filteredTxHashList, filteredTxn,</span>
                        newStoredBlock, first, registration.listener, falsePositives);
            } else {
                // Listener wants to be run on some other thread, so marshal it across here.
<span class="nc bnc" id="L657" title="All 2 branches missed.">                final boolean notFirst = !first;</span>
<span class="nc" id="L658">                registration.executor.execute(new Runnable() {</span>
                    @Override
                    public void run() {
                        try {
                            // We can't do false-positive handling when executing on another thread
<span class="nc" id="L663">                            Set&lt;Sha256Hash&gt; ignoredFalsePositives = Sets.newHashSet();</span>
<span class="nc" id="L664">                            informListenerForNewTransactions(block, newBlockType, filteredTxHashList, filteredTxn,</span>
                                    newStoredBlock, notFirst, registration.listener, ignoredFalsePositives);
<span class="nc" id="L666">                        } catch (VerificationException e) {</span>
<span class="nc" id="L667">                            log.error(&quot;Block chain listener threw exception: &quot;, e);</span>
                            // Don't attempt to relay this back to the original peer thread if this was an async
                            // listener invocation.
                            // TODO: Make exception reporting a global feature and use it here.
<span class="nc" id="L671">                        }</span>
<span class="nc" id="L672">                    }</span>
                });
            }
<span class="fc" id="L675">            first = false;</span>
<span class="fc" id="L676">        }</span>

<span class="fc bfc" id="L678" title="All 2 branches covered.">        for (final ListenerRegistration&lt;NewBestBlockListener&gt; registration : newBestBlockListeners) {</span>
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">            if (registration.executor == Threading.SAME_THREAD) {</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">                if (newBlockType == NewBlockType.BEST_CHAIN)</span>
<span class="fc" id="L681">                    registration.listener.notifyNewBestBlock(newStoredBlock);</span>
            } else {
                // Listener wants to be run on some other thread, so marshal it across here.
<span class="nc" id="L684">                registration.executor.execute(new Runnable() {</span>
                    @Override
                    public void run() {
                        try {
<span class="nc bnc" id="L688" title="All 2 branches missed.">                            if (newBlockType == NewBlockType.BEST_CHAIN)</span>
<span class="nc" id="L689">                                registration.listener.notifyNewBestBlock(newStoredBlock);</span>
<span class="nc" id="L690">                        } catch (VerificationException e) {</span>
<span class="nc" id="L691">                            log.error(&quot;Block chain listener threw exception: &quot;, e);</span>
                            // Don't attempt to relay this back to the original peer thread if this was an async
                            // listener invocation.
                            // TODO: Make exception reporting a global feature and use it here.
<span class="nc" id="L695">                        }</span>
<span class="nc" id="L696">                    }</span>
                });
            }
<span class="fc" id="L699">            first = false;</span>
<span class="fc" id="L700">        }</span>

<span class="fc" id="L702">        trackFalsePositives(falsePositives.size());</span>
<span class="fc" id="L703">    }</span>

    private static void informListenerForNewTransactions(Block block, NewBlockType newBlockType,
                                                         @Nullable List&lt;Sha256Hash&gt; filteredTxHashList,
                                                         @Nullable Map&lt;Sha256Hash, Transaction&gt; filteredTxn,
                                                         StoredBlock newStoredBlock, boolean first,
                                                         TransactionReceivedInBlockListener listener,
                                                         Set&lt;Sha256Hash&gt; falsePositives) throws VerificationException {
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">        if (block.transactions != null) {</span>
            // If this is not the first wallet, ask for the transactions to be duplicated before being given
            // to the wallet when relevant. This ensures that if we have two connected wallets and a tx that
            // is relevant to both of them, they don't end up accidentally sharing the same object (which can
            // result in temporary in-memory corruption during re-orgs). See bug 257. We only duplicate in
            // the case of multiple wallets to avoid an unnecessary efficiency hit in the common case.
<span class="fc bfc" id="L717" title="All 2 branches covered.">            sendTransactionsToListener(newStoredBlock, newBlockType, listener, 0, block.transactions,</span>
                    !first, falsePositives);
<span class="nc bnc" id="L719" title="All 2 branches missed.">        } else if (filteredTxHashList != null) {</span>
<span class="nc" id="L720">            checkNotNull(filteredTxn);</span>
            // We must send transactions to listeners in the order they appeared in the block - thus we iterate over the
            // set of hashes and call sendTransactionsToListener with individual txn when they have not already been
            // seen in loose broadcasts - otherwise notifyTransactionIsInBlock on the hash.
<span class="nc" id="L724">            int relativityOffset = 0;</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">            for (Sha256Hash hash : filteredTxHashList) {</span>
<span class="nc" id="L726">                Transaction tx = filteredTxn.get(hash);</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">                if (tx != null) {</span>
<span class="nc" id="L728">                    sendTransactionsToListener(newStoredBlock, newBlockType, listener, relativityOffset,</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">                            Collections.singletonList(tx), !first, falsePositives);</span>
                } else {
<span class="nc bnc" id="L731" title="All 2 branches missed.">                    if (listener.notifyTransactionIsInBlock(hash, newStoredBlock, newBlockType, relativityOffset)) {</span>
<span class="nc" id="L732">                        falsePositives.remove(hash);</span>
                    }
                }
<span class="nc" id="L735">                relativityOffset++;</span>
<span class="nc" id="L736">            }</span>
        }
<span class="fc" id="L738">    }</span>

    /**
     * Gets the median timestamp of the last 11 blocks
     */
    private static long getMedianTimestampOfRecentBlocks(StoredBlock storedBlock,
                                                         BlockStore store) throws BlockStoreException {
<span class="fc" id="L745">        long[] timestamps = new long[11];</span>
<span class="fc" id="L746">        int unused = 9;</span>
<span class="fc" id="L747">        timestamps[10] = storedBlock.getHeader().getTimeSeconds();</span>
<span class="pc bpc" id="L748" title="1 of 4 branches missed.">        while (unused &gt;= 0 &amp;&amp; (storedBlock = storedBlock.getPrev(store)) != null)</span>
<span class="fc" id="L749">            timestamps[unused--] = storedBlock.getHeader().getTimeSeconds();</span>
        
<span class="fc" id="L751">        Arrays.sort(timestamps, unused+1, 11);</span>
<span class="fc" id="L752">        return timestamps[unused + (11-unused)/2];</span>
    }
    
    /**
     * Disconnect each transaction in the block (after reading it from the block store)
     * Only called if(shouldVerifyTransactions())
     * @throws PrunedException if block does not exist as a {@link StoredUndoableBlock} in the block store.
     * @throws BlockStoreException if the block store had an underlying error or block does not exist in the block store at all.
     */
    protected abstract void disconnectTransactions(StoredBlock block) throws PrunedException, BlockStoreException;

    /**
     * Called as part of connecting a block when the new block results in a different chain having higher total work.
     * 
     * if (shouldVerifyTransactions)
     *     Either newChainHead needs to be in the block store as a FullStoredBlock, or (block != null &amp;&amp; block.transactions != null)
     */
    private void handleNewBestChain(StoredBlock storedPrev, StoredBlock newChainHead, Block block, boolean expensiveChecks)
            throws BlockStoreException, VerificationException, PrunedException {
<span class="fc" id="L771">        checkState(lock.isHeldByCurrentThread());</span>
        // This chain has overtaken the one we currently believe is best. Reorganize is required.
        //
        // Firstly, calculate the block at which the chain diverged. We only need to examine the
        // chain from beyond this block to find differences.
<span class="fc" id="L776">        StoredBlock head = getChainHead();</span>
<span class="fc" id="L777">        final StoredBlock splitPoint = findSplit(newChainHead, head, blockStore);</span>
<span class="fc" id="L778">        log.info(&quot;Re-organize after split at height {}&quot;, splitPoint.getHeight());</span>
<span class="fc" id="L779">        log.info(&quot;Old chain head: {}&quot;, head.getHeader().getHashAsString());</span>
<span class="fc" id="L780">        log.info(&quot;New chain head: {}&quot;, newChainHead.getHeader().getHashAsString());</span>
<span class="fc" id="L781">        log.info(&quot;Split at block: {}&quot;, splitPoint.getHeader().getHashAsString());</span>
        // Then build a list of all blocks in the old part of the chain and the new part.
        //System.out.println(&quot;head work: &quot;+head.getChainWork()+ &quot;, splitPoint: &quot;+splitPoint.getChainWork());
<span class="fc" id="L784">        final LinkedList&lt;StoredBlock&gt; oldBlocks = getPartialChain(head, splitPoint, blockStore);</span>
<span class="fc" id="L785">        final LinkedList&lt;StoredBlock&gt; newBlocks = getPartialChain(newChainHead, splitPoint, blockStore);</span>
        // Disconnect each transaction in the previous main chain that is no longer in the new main chain
<span class="fc" id="L787">        StoredBlock storedNewHead = splitPoint;</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">        if (shouldVerifyTransactions()) {</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">            for (StoredBlock oldBlock : oldBlocks) {</span>
                try {
<span class="fc" id="L791">                    disconnectTransactions(oldBlock);</span>
<span class="nc" id="L792">                } catch (PrunedException e) {</span>
                    // We threw away the data we need to re-org this deep! We need to go back to a peer with full
                    // block contents and ask them for the relevant data then rebuild the indexs. Or we could just
                    // give up and ask the human operator to help get us unstuck (eg, rescan from the genesis block).
                    // TODO: Retry adding this block when we get a block with hash e.getHash()
<span class="nc" id="L797">                    throw e;</span>
<span class="fc" id="L798">                }</span>
<span class="fc" id="L799">            }</span>
            StoredBlock cursor;
            // Walk in ascending chronological order.
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">            for (Iterator&lt;StoredBlock&gt; it = newBlocks.descendingIterator(); it.hasNext();) {</span>
<span class="fc" id="L803">                cursor = it.next();</span>
<span class="fc" id="L804">                Block cursorBlock = cursor.getHeader();</span>
<span class="pc bpc" id="L805" title="2 of 4 branches missed.">                if (expensiveChecks &amp;&amp; cursorBlock.getTimeSeconds() &lt;= getMedianTimestampOfRecentBlocks(cursor.getPrev(blockStore), blockStore))</span>
<span class="nc" id="L806">                    throw new VerificationException(&quot;Block's timestamp is too early during reorg&quot;);</span>
                TransactionOutputChanges txOutChanges;
<span class="pc bpc" id="L808" title="3 of 4 branches missed.">                if (cursor != newChainHead || block == null)</span>
<span class="fc" id="L809">                    txOutChanges = connectTransactions(cursor);</span>
                else
<span class="nc" id="L811">                    txOutChanges = connectTransactions(newChainHead.getHeight(), block);</span>
<span class="fc" id="L812">                storedNewHead = addToBlockStore(storedNewHead, cursorBlock.cloneAsHeader(), txOutChanges);</span>
<span class="pc" id="L813">            }</span>
        } else {
            // (Finally) write block to block store
<span class="fc" id="L816">            storedNewHead = addToBlockStore(storedPrev, newChainHead.getHeader());</span>
        }
        // Now inform the listeners. This is necessary so the set of currently active transactions (that we can spend)
        // can be updated to take into account the re-organize. We might also have received new coins we didn't have
        // before and our previous spends might have been undone.
<span class="fc bfc" id="L821" title="All 2 branches covered.">        for (final ListenerRegistration&lt;ReorganizeListener&gt; registration : reorganizeListeners) {</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">            if (registration.executor == Threading.SAME_THREAD) {</span>
                // Short circuit the executor so we can propagate any exceptions.
                // TODO: Do we really need to do this or should it be irrelevant?
<span class="fc" id="L825">                registration.listener.reorganize(splitPoint, oldBlocks, newBlocks);</span>
            } else {
<span class="nc" id="L827">                registration.executor.execute(new Runnable() {</span>
                    @Override
                    public void run() {
                        try {
<span class="nc" id="L831">                            registration.listener.reorganize(splitPoint, oldBlocks, newBlocks);</span>
<span class="nc" id="L832">                        } catch (VerificationException e) {</span>
<span class="nc" id="L833">                            log.error(&quot;Block chain listener threw exception during reorg&quot;, e);</span>
<span class="nc" id="L834">                        }</span>
<span class="nc" id="L835">                    }</span>
                });
            }
<span class="fc" id="L838">        }</span>
        // Update the pointer to the best known block.
<span class="fc" id="L840">        setChainHead(storedNewHead);</span>
<span class="fc" id="L841">    }</span>

    /**
     * Returns the set of contiguous blocks between 'higher' and 'lower'. Higher is included, lower is not.
     */
    private static LinkedList&lt;StoredBlock&gt; getPartialChain(StoredBlock higher, StoredBlock lower, BlockStore store) throws BlockStoreException {
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">        checkArgument(higher.getHeight() &gt; lower.getHeight(), &quot;higher and lower are reversed&quot;);</span>
<span class="fc" id="L848">        LinkedList&lt;StoredBlock&gt; results = new LinkedList&lt;StoredBlock&gt;();</span>
<span class="fc" id="L849">        StoredBlock cursor = higher;</span>
        while (true) {
<span class="fc" id="L851">            results.add(cursor);</span>
<span class="fc" id="L852">            cursor = checkNotNull(cursor.getPrev(store), &quot;Ran off the end of the chain&quot;);</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">            if (cursor.equals(lower)) break;</span>
        }
<span class="fc" id="L855">        return results;</span>
    }

    /**
     * Locates the point in the chain at which newStoredBlock and chainHead diverge. Returns null if no split point was
     * found (ie they are not part of the same chain). Returns newChainHead or chainHead if they don't actually diverge
     * but are part of the same chain.
     */
    private static StoredBlock findSplit(StoredBlock newChainHead, StoredBlock oldChainHead,
                                         BlockStore store) throws BlockStoreException {
<span class="fc" id="L865">        StoredBlock currentChainCursor = oldChainHead;</span>
<span class="fc" id="L866">        StoredBlock newChainCursor = newChainHead;</span>
        // Loop until we find the block both chains have in common. Example:
        //
        //    A -&gt; B -&gt; C -&gt; D
        //         \--&gt; E -&gt; F -&gt; G
        //
        // findSplit will return block B. oldChainHead = D and newChainHead = G.
<span class="fc bfc" id="L873" title="All 2 branches covered.">        while (!currentChainCursor.equals(newChainCursor)) {</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">            if (currentChainCursor.getHeight() &gt; newChainCursor.getHeight()) {</span>
<span class="fc" id="L875">                currentChainCursor = currentChainCursor.getPrev(store);</span>
<span class="fc" id="L876">                checkNotNull(currentChainCursor, &quot;Attempt to follow an orphan chain&quot;);</span>
            } else {
<span class="fc" id="L878">                newChainCursor = newChainCursor.getPrev(store);</span>
<span class="fc" id="L879">                checkNotNull(newChainCursor, &quot;Attempt to follow an orphan chain&quot;);</span>
            }
        }
<span class="fc" id="L882">        return currentChainCursor;</span>
    }

    /**
     * @return the height of the best known chain, convenience for &lt;tt&gt;getChainHead().getHeight()&lt;/tt&gt;.
     */
    public final int getBestChainHeight() {
<span class="fc" id="L889">        return getChainHead().getHeight();</span>
    }

<span class="pc" id="L892">    public enum NewBlockType {</span>
<span class="fc" id="L893">        BEST_CHAIN,</span>
<span class="fc" id="L894">        SIDE_CHAIN</span>
    }

    private static void sendTransactionsToListener(StoredBlock block, NewBlockType blockType,
                                                   TransactionReceivedInBlockListener listener,
                                                   int relativityOffset,
                                                   List&lt;Transaction&gt; transactions,
                                                   boolean clone,
                                                   Set&lt;Sha256Hash&gt; falsePositives) throws VerificationException {
<span class="fc bfc" id="L903" title="All 2 branches covered.">        for (Transaction tx : transactions) {</span>
            try {
<span class="fc" id="L905">                falsePositives.remove(tx.getHash());</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">                if (clone)</span>
<span class="fc" id="L907">                    tx = tx.params.getDefaultSerializer().makeTransaction(tx.bitcoinSerialize());</span>
<span class="fc" id="L908">                listener.receiveFromBlock(tx, block, blockType, relativityOffset++);</span>
<span class="nc" id="L909">            } catch (ScriptException e) {</span>
                // We don't want scripts we don't understand to break the block chain so just note that this tx was
                // not scanned here and continue.
<span class="nc" id="L912">                log.warn(&quot;Failed to parse a script: &quot; + e.toString());</span>
<span class="nc" id="L913">            } catch (ProtocolException e) {</span>
                // Failed to duplicate tx, should never happen.
<span class="nc" id="L915">                throw new RuntimeException(e);</span>
<span class="pc" id="L916">            }</span>
<span class="fc" id="L917">        }</span>
<span class="fc" id="L918">    }</span>

    protected void setChainHead(StoredBlock chainHead) throws BlockStoreException {
<span class="fc" id="L921">        doSetChainHead(chainHead);</span>
<span class="fc" id="L922">        synchronized (chainHeadLock) {</span>
<span class="fc" id="L923">            this.chainHead = chainHead;</span>
<span class="pc" id="L924">        }</span>
<span class="fc" id="L925">        Context.get().updatedChainHead(chainHead);</span>
<span class="fc" id="L926">    }</span>

    /**
     * For each block in orphanBlocks, see if we can now fit it on top of the chain and if so, do so.
     */
    private void tryConnectingOrphans() throws VerificationException, BlockStoreException, PrunedException {
<span class="fc" id="L932">        checkState(lock.isHeldByCurrentThread());</span>
        // For each block in our orphan list, try and fit it onto the head of the chain. If we succeed remove it
        // from the list and keep going. If we changed the head of the list at the end of the round try again until
        // we can't fit anything else on the top.
        //
        // This algorithm is kind of crappy, we should do a topo-sort then just connect them in order, but for small
        // numbers of orphan blocks it does OK.
        int blocksConnectedThisRound;
        do {
<span class="fc" id="L941">            blocksConnectedThisRound = 0;</span>
<span class="fc" id="L942">            Iterator&lt;OrphanBlock&gt; iter = orphanBlocks.values().iterator();</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L944">                OrphanBlock orphanBlock = iter.next();</span>
                // Look up the blocks previous.
<span class="fc" id="L946">                StoredBlock prev = getStoredBlockInCurrentScope(orphanBlock.block.getPrevBlockHash());</span>
<span class="pc bpc" id="L947" title="1 of 2 branches missed.">                if (prev == null) {</span>
                    // This is still an unconnected/orphan block.
<span class="nc" id="L949">                    log.debug(&quot;Orphan block {} is not connectable right now&quot;, orphanBlock.block.getHash());</span>
<span class="nc" id="L950">                    continue;</span>
                }
                // Otherwise we can connect it now.
                // False here ensures we don't recurse infinitely downwards when connecting huge chains.
<span class="fc" id="L954">                log.info(&quot;Connected orphan {}&quot;, orphanBlock.block.getHash());</span>
<span class="fc" id="L955">                add(orphanBlock.block, false, orphanBlock.filteredTxHashes, orphanBlock.filteredTxn);</span>
<span class="fc" id="L956">                iter.remove();</span>
<span class="fc" id="L957">                blocksConnectedThisRound++;</span>
<span class="fc" id="L958">            }</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">            if (blocksConnectedThisRound &gt; 0) {</span>
<span class="fc" id="L960">                log.info(&quot;Connected {} orphan blocks.&quot;, blocksConnectedThisRound);</span>
            }
<span class="fc bfc" id="L962" title="All 2 branches covered.">        } while (blocksConnectedThisRound &gt; 0);</span>
<span class="fc" id="L963">    }</span>


    // February 16th 2012
<span class="fc" id="L967">    private static final Date testnetDiffDate = new Date(1329264000000L);</span>

    /**
     * Throws an exception if the blocks difficulty is not correct.
     */
    private void checkDifficultyTransitions(StoredBlock storedPrev, Block nextBlock) throws BlockStoreException, VerificationException {
<span class="nc" id="L973">        checkState(lock.isHeldByCurrentThread());</span>

<span class="nc" id="L975">        int DiffMode = 1;</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">        if (params.getId().equals(NetworkParameters.ID_TESTNET)) {</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">            if (storedPrev.getHeight()+1 &gt;= 3000) { DiffMode = 4; }</span>
        }
        else {
<span class="nc bnc" id="L980" title="All 2 branches missed.">            if (storedPrev.getHeight()+1 &gt;= 68589) { DiffMode = 4; }</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">            else if (storedPrev.getHeight()+1 &gt;= 34140) { DiffMode = 3; }</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">            else if (storedPrev.getHeight()+1 &gt;= 15200) { DiffMode = 2; }</span>
        }

<span class="nc bnc" id="L985" title="All 2 branches missed.">        if (DiffMode == 1) { checkDifficultyTransitions_V1(storedPrev, nextBlock); return; }</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">        else if (DiffMode == 2) { checkDifficultyTransitions_V2(storedPrev, nextBlock); return;}</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">        else if (DiffMode == 3) { DarkGravityWave(storedPrev, nextBlock); return;}</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">        else if (DiffMode == 4) { DarkGravityWave3(storedPrev, nextBlock); return; }</span>

<span class="nc" id="L990">        DarkGravityWave3(storedPrev, nextBlock);</span>

<span class="nc" id="L992">        return;</span>

    }
    private void DarkGravityWave1(StoredBlock storedPrev, Block nextBlock) {
    /* current difficulty formula, limecoin - DarkGravity, written by Evan Duffield - evan@limecoin.io */
<span class="nc" id="L997">        StoredBlock BlockLastSolved = storedPrev;</span>
<span class="nc" id="L998">        StoredBlock BlockReading = storedPrev;</span>
<span class="nc" id="L999">        Block BlockCreating = nextBlock;</span>
        //BlockCreating = BlockCreating;
<span class="nc" id="L1001">        long nBlockTimeAverage = 0;</span>
<span class="nc" id="L1002">        long nBlockTimeAveragePrev = 0;</span>
<span class="nc" id="L1003">        long nBlockTimeCount = 0;</span>
<span class="nc" id="L1004">        long nBlockTimeSum2 = 0;</span>
<span class="nc" id="L1005">        long nBlockTimeCount2 = 0;</span>
<span class="nc" id="L1006">        long LastBlockTime = 0;</span>
<span class="nc" id="L1007">        long PastBlocksMin = 14;</span>
<span class="nc" id="L1008">        long PastBlocksMax = 140;</span>
<span class="nc" id="L1009">        long CountBlocks = 0;</span>
<span class="nc" id="L1010">        BigInteger PastDifficultyAverage = BigInteger.valueOf(0);</span>
<span class="nc" id="L1011">        BigInteger PastDifficultyAveragePrev = BigInteger.valueOf(0);</span>

        //if (BlockLastSolved == NULL || BlockLastSolved-&gt;nHeight == 0 || BlockLastSolved-&gt;nHeight &lt; PastBlocksMin) { return bnProofOfWorkLimit.GetCompact(); }
<span class="nc bnc" id="L1014" title="All 6 branches missed.">        if (BlockLastSolved == null || BlockLastSolved.getHeight() == 0 || (long)BlockLastSolved.getHeight() &lt; PastBlocksMin)</span>
<span class="nc" id="L1015">        { verifyDifficulty(params.getMaxTarget(), storedPrev, nextBlock); }</span>

<span class="nc bnc" id="L1017" title="All 4 branches missed.">        for (int i = 1; BlockReading != null &amp;&amp; BlockReading.getHeight() &gt; 0; i++) {</span>
<span class="nc bnc" id="L1018" title="All 4 branches missed.">            if (PastBlocksMax &gt; 0 &amp;&amp; i &gt; PastBlocksMax) { break; }</span>
<span class="nc" id="L1019">            CountBlocks++;</span>

<span class="nc bnc" id="L1021" title="All 2 branches missed.">            if(CountBlocks &lt;= PastBlocksMin) {</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">                if (CountBlocks == 1) { PastDifficultyAverage = BlockReading.getHeader().getDifficultyTargetAsInteger(); }</span>
                else
                {
                    //PastDifficultyAverage = ((CBigNum().SetCompact(BlockReading-&gt;nBits) - PastDifficultyAveragePrev) / CountBlocks) + PastDifficultyAveragePrev;
<span class="nc" id="L1026">                    PastDifficultyAverage = BlockReading.getHeader().getDifficultyTargetAsInteger().subtract(PastDifficultyAveragePrev).divide(BigInteger.valueOf(CountBlocks)).add(PastDifficultyAveragePrev);</span>

                }
<span class="nc" id="L1029">                PastDifficultyAveragePrev = PastDifficultyAverage;</span>
            }

<span class="nc bnc" id="L1032" title="All 2 branches missed.">            if(LastBlockTime &gt; 0){</span>
<span class="nc" id="L1033">                long Diff = (LastBlockTime - BlockReading.getHeader().getTimeSeconds());</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">                if(Diff &lt; 0) Diff = 0;</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">                if(nBlockTimeCount &lt;= PastBlocksMin) {</span>
<span class="nc" id="L1036">                    nBlockTimeCount++;</span>

<span class="nc bnc" id="L1038" title="All 2 branches missed.">                    if (nBlockTimeCount == 1) { nBlockTimeAverage = Diff; }</span>
<span class="nc" id="L1039">                    else { nBlockTimeAverage = ((Diff - nBlockTimeAveragePrev) / nBlockTimeCount) + nBlockTimeAveragePrev; }</span>
<span class="nc" id="L1040">                    nBlockTimeAveragePrev = nBlockTimeAverage;</span>
                }
<span class="nc" id="L1042">                nBlockTimeCount2++;</span>
<span class="nc" id="L1043">                nBlockTimeSum2 += Diff;</span>
            }
<span class="nc" id="L1045">            LastBlockTime = BlockReading.getHeader().getTimeSeconds();</span>

            //if (BlockReading-&gt;pprev == NULL)
            try {
<span class="nc" id="L1049">                StoredBlock BlockReadingPrev = blockStore.get(BlockReading.getHeader().getPrevBlockHash());</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">                if (BlockReadingPrev == null)</span>
                {
                    //assert(BlockReading); break;
<span class="nc" id="L1053">                    return;</span>
                }
<span class="nc" id="L1055">                BlockReading = BlockReadingPrev;</span>
            }
<span class="nc" id="L1057">            catch(BlockStoreException x)</span>
            {
<span class="nc" id="L1059">                return;</span>
<span class="nc" id="L1060">            }</span>
        }

<span class="nc" id="L1063">        BigInteger bnNew = PastDifficultyAverage;</span>
<span class="nc bnc" id="L1064" title="All 4 branches missed.">        if (nBlockTimeCount != 0 &amp;&amp; nBlockTimeCount2 != 0) {</span>
<span class="nc" id="L1065">            double SmartAverage = (((nBlockTimeAverage)*0.7)+((nBlockTimeSum2 / nBlockTimeCount2)*0.3));</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">            if(SmartAverage &lt; 1) SmartAverage = 1;</span>
<span class="nc" id="L1067">            double Shift = CoinDefinition.TARGET_SPACING/SmartAverage;</span>

<span class="nc" id="L1069">            long nActualTimespan = (long)((CountBlocks*CoinDefinition.TARGET_SPACING)/Shift);</span>
<span class="nc" id="L1070">            long nTargetTimespan = (CountBlocks*CoinDefinition.TARGET_SPACING);</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">            if (nActualTimespan &lt; nTargetTimespan/3)</span>
<span class="nc" id="L1072">                nActualTimespan = nTargetTimespan/3;</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">            if (nActualTimespan &gt; nTargetTimespan*3)</span>
<span class="nc" id="L1074">                nActualTimespan = nTargetTimespan*3;</span>

            // Retarget
<span class="nc" id="L1077">            bnNew = bnNew.multiply(BigInteger.valueOf(nActualTimespan));</span>
<span class="nc" id="L1078">            bnNew = bnNew.divide(BigInteger.valueOf(nTargetTimespan));</span>
        }
<span class="nc" id="L1080">        verifyDifficulty(bnNew, storedPrev, nextBlock);</span>

        /*if (bnNew &gt; bnProofOfWorkLimit){
            bnNew = bnProofOfWorkLimit;
        }

        return bnNew.GetCompact();*/
<span class="nc" id="L1087">    }</span>
    private void DarkGravityWave(StoredBlock storedPrev, Block nextBlock) {
    /* current difficulty formula, limecoin - DarkGravity, written by Evan Duffield - evan@limecoin.io */
<span class="nc" id="L1090">        StoredBlock BlockLastSolved = storedPrev;</span>
<span class="nc" id="L1091">        StoredBlock BlockReading = storedPrev;</span>
<span class="nc" id="L1092">        Block BlockCreating = nextBlock;</span>
        //BlockCreating = BlockCreating;
<span class="nc" id="L1094">        long nBlockTimeAverage = 0;</span>
<span class="nc" id="L1095">        long nBlockTimeAveragePrev = 0;</span>
<span class="nc" id="L1096">        long nBlockTimeCount = 0;</span>
<span class="nc" id="L1097">        long nBlockTimeSum2 = 0;</span>
<span class="nc" id="L1098">        long nBlockTimeCount2 = 0;</span>
<span class="nc" id="L1099">        long LastBlockTime = 0;</span>
<span class="nc" id="L1100">        long PastBlocksMin = 14;</span>
<span class="nc" id="L1101">        long PastBlocksMax = 140;</span>
<span class="nc" id="L1102">        long CountBlocks = 0;</span>
<span class="nc" id="L1103">        BigInteger PastDifficultyAverage = BigInteger.valueOf(0);</span>
<span class="nc" id="L1104">        BigInteger PastDifficultyAveragePrev = BigInteger.valueOf(0);</span>

        //if (BlockLastSolved == NULL || BlockLastSolved-&gt;nHeight == 0 || BlockLastSolved-&gt;nHeight &lt; PastBlocksMin) { return bnProofOfWorkLimit.GetCompact(); }
<span class="nc bnc" id="L1107" title="All 6 branches missed.">        if (BlockLastSolved == null || BlockLastSolved.getHeight() == 0 || (long)BlockLastSolved.getHeight() &lt; PastBlocksMin)</span>
<span class="nc" id="L1108">        { verifyDifficulty(params.getMaxTarget(), storedPrev, nextBlock); }</span>

<span class="nc bnc" id="L1110" title="All 4 branches missed.">        for (int i = 1; BlockReading != null &amp;&amp; BlockReading.getHeight() &gt; 0; i++) {</span>
<span class="nc bnc" id="L1111" title="All 4 branches missed.">            if (PastBlocksMax &gt; 0 &amp;&amp; i &gt; PastBlocksMax)</span>
            {
<span class="nc" id="L1113">                break;</span>
            }
<span class="nc" id="L1115">            CountBlocks++;</span>

<span class="nc bnc" id="L1117" title="All 2 branches missed.">            if(CountBlocks &lt;= PastBlocksMin) {</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                if (CountBlocks == 1) { PastDifficultyAverage = BlockReading.getHeader().getDifficultyTargetAsInteger(); }</span>
                else
                {
                    //PastDifficultyAverage = ((CBigNum().SetCompact(BlockReading-&gt;nBits) - PastDifficultyAveragePrev) / CountBlocks) + PastDifficultyAveragePrev;
<span class="nc" id="L1122">                    PastDifficultyAverage = BlockReading.getHeader().getDifficultyTargetAsInteger().subtract(PastDifficultyAveragePrev).divide(BigInteger.valueOf(CountBlocks)).add(PastDifficultyAveragePrev);</span>

                }
<span class="nc" id="L1125">                PastDifficultyAveragePrev = PastDifficultyAverage;</span>
            }

<span class="nc bnc" id="L1128" title="All 2 branches missed.">            if(LastBlockTime &gt; 0){</span>
<span class="nc" id="L1129">                long Diff = (LastBlockTime - BlockReading.getHeader().getTimeSeconds());</span>
                //if(Diff &lt; 0)
                //   Diff = 0;
<span class="nc bnc" id="L1132" title="All 2 branches missed.">                if(nBlockTimeCount &lt;= PastBlocksMin) {</span>
<span class="nc" id="L1133">                    nBlockTimeCount++;</span>

<span class="nc bnc" id="L1135" title="All 2 branches missed.">                    if (nBlockTimeCount == 1) { nBlockTimeAverage = Diff; }</span>
<span class="nc" id="L1136">                    else { nBlockTimeAverage = ((Diff - nBlockTimeAveragePrev) / nBlockTimeCount) + nBlockTimeAveragePrev; }</span>
<span class="nc" id="L1137">                    nBlockTimeAveragePrev = nBlockTimeAverage;</span>
                }
<span class="nc" id="L1139">                nBlockTimeCount2++;</span>
<span class="nc" id="L1140">                nBlockTimeSum2 += Diff;</span>
            }
<span class="nc" id="L1142">            LastBlockTime = BlockReading.getHeader().getTimeSeconds();</span>

            //if (BlockReading-&gt;pprev == NULL)
            try {
<span class="nc" id="L1146">                StoredBlock BlockReadingPrev = blockStore.get(BlockReading.getHeader().getPrevBlockHash());</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">                if (BlockReadingPrev == null)</span>
                {
                    //assert(BlockReading); break;
<span class="nc" id="L1150">                    return;</span>
                }
<span class="nc" id="L1152">                BlockReading = BlockReadingPrev;</span>
            }
<span class="nc" id="L1154">            catch(BlockStoreException x)</span>
            {
<span class="nc" id="L1156">                return;</span>
<span class="nc" id="L1157">            }</span>
        }

<span class="nc" id="L1160">        BigInteger bnNew = PastDifficultyAverage;</span>
<span class="nc bnc" id="L1161" title="All 4 branches missed.">        if (nBlockTimeCount != 0 &amp;&amp; nBlockTimeCount2 != 0) {</span>
<span class="nc" id="L1162">            double SmartAverage = ((((double)nBlockTimeAverage)*0.7)+(((double)nBlockTimeSum2 / (double)nBlockTimeCount2)*0.3));</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">            if(SmartAverage &lt; 1) SmartAverage = 1;</span>
<span class="nc" id="L1164">            double Shift = CoinDefinition.TARGET_SPACING/SmartAverage;</span>

<span class="nc" id="L1166">            double fActualTimespan = (((double)CountBlocks*(double)CoinDefinition.TARGET_SPACING)/Shift);</span>
<span class="nc" id="L1167">            double fTargetTimespan = ((double)CountBlocks*CoinDefinition.TARGET_SPACING);</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">            if (fActualTimespan &lt; fTargetTimespan/3)</span>
<span class="nc" id="L1169">                fActualTimespan = fTargetTimespan/3;</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">            if (fActualTimespan &gt; fTargetTimespan*3)</span>
<span class="nc" id="L1171">                fActualTimespan = fTargetTimespan*3;</span>

<span class="nc" id="L1173">            long nActualTimespan = (long)fActualTimespan;</span>
<span class="nc" id="L1174">            long nTargetTimespan = (long)fTargetTimespan;</span>

            // Retarget
<span class="nc" id="L1177">            bnNew = bnNew.multiply(BigInteger.valueOf(nActualTimespan));</span>
<span class="nc" id="L1178">            bnNew = bnNew.divide(BigInteger.valueOf(nTargetTimespan));</span>
        }
<span class="nc" id="L1180">        verifyDifficulty(bnNew, storedPrev, nextBlock);</span>

        /*if (bnNew &gt; bnProofOfWorkLimit){
            bnNew = bnProofOfWorkLimit;
        }

        return bnNew.GetCompact();*/
<span class="nc" id="L1187">    }</span>
    private void DarkGravityWave3(StoredBlock storedPrev, Block nextBlock) {
        /* current difficulty formula, darkcoin - DarkGravity v3, written by Evan Duffield - evan@darkcoin.io */
<span class="nc" id="L1190">        StoredBlock BlockLastSolved = storedPrev;</span>
<span class="nc" id="L1191">        StoredBlock BlockReading = storedPrev;</span>
<span class="nc" id="L1192">        Block BlockCreating = nextBlock;</span>
<span class="nc" id="L1193">        BlockCreating = BlockCreating;</span>
<span class="nc" id="L1194">        long nActualTimespan = 0;</span>
<span class="nc" id="L1195">        long LastBlockTime = 0;</span>
<span class="nc" id="L1196">        long PastBlocksMin = 24;</span>
<span class="nc" id="L1197">        long PastBlocksMax = 24;</span>
<span class="nc" id="L1198">        long CountBlocks = 0;</span>
<span class="nc" id="L1199">        BigInteger PastDifficultyAverage = BigInteger.ZERO;</span>
<span class="nc" id="L1200">        BigInteger PastDifficultyAveragePrev = BigInteger.ZERO;</span>

<span class="nc bnc" id="L1202" title="All 6 branches missed.">        if (BlockLastSolved == null || BlockLastSolved.getHeight() == 0 || BlockLastSolved.getHeight() &lt; PastBlocksMin) {</span>
<span class="nc" id="L1203">            verifyDifficulty(params.getMaxTarget(), storedPrev, nextBlock);</span>
<span class="nc" id="L1204">            return;</span>
        }

<span class="nc bnc" id="L1207" title="All 4 branches missed.">        for (int i = 1; BlockReading != null &amp;&amp; BlockReading.getHeight() &gt; 0; i++) {</span>
<span class="nc bnc" id="L1208" title="All 4 branches missed.">            if (PastBlocksMax &gt; 0 &amp;&amp; i &gt; PastBlocksMax) { break; }</span>
<span class="nc" id="L1209">            CountBlocks++;</span>

<span class="nc bnc" id="L1211" title="All 2 branches missed.">            if(CountBlocks &lt;= PastBlocksMin) {</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">                if (CountBlocks == 1) { PastDifficultyAverage = BlockReading.getHeader().getDifficultyTargetAsInteger(); }</span>
<span class="nc" id="L1213">                else { PastDifficultyAverage = ((PastDifficultyAveragePrev.multiply(BigInteger.valueOf(CountBlocks)).add(BlockReading.getHeader().getDifficultyTargetAsInteger()).divide(BigInteger.valueOf(CountBlocks + 1)))); }</span>
<span class="nc" id="L1214">                PastDifficultyAveragePrev = PastDifficultyAverage;</span>
            }

<span class="nc bnc" id="L1217" title="All 2 branches missed.">            if(LastBlockTime &gt; 0){</span>
<span class="nc" id="L1218">                long Diff = (LastBlockTime - BlockReading.getHeader().getTimeSeconds());</span>
<span class="nc" id="L1219">                nActualTimespan += Diff;</span>
            }
<span class="nc" id="L1221">            LastBlockTime = BlockReading.getHeader().getTimeSeconds();</span>

            try {
<span class="nc" id="L1224">                StoredBlock BlockReadingPrev = blockStore.get(BlockReading.getHeader().getPrevBlockHash());</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">                if (BlockReadingPrev == null)</span>
                {
                    //assert(BlockReading); break;
<span class="nc" id="L1228">                    return;</span>
                }
<span class="nc" id="L1230">                BlockReading = BlockReadingPrev;</span>
            }
<span class="nc" id="L1232">            catch(BlockStoreException x)</span>
            {
<span class="nc" id="L1234">                return;</span>
<span class="nc" id="L1235">            }</span>
        }

<span class="nc" id="L1238">        BigInteger bnNew= PastDifficultyAverage;</span>

<span class="nc" id="L1240">        long nTargetTimespan = CountBlocks*params.TARGET_SPACING;//nTargetSpacing;</span>

<span class="nc bnc" id="L1242" title="All 2 branches missed.">        if (nActualTimespan &lt; nTargetTimespan/3)</span>
<span class="nc" id="L1243">            nActualTimespan = nTargetTimespan/3;</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">        if (nActualTimespan &gt; nTargetTimespan*3)</span>
<span class="nc" id="L1245">            nActualTimespan = nTargetTimespan*3;</span>

        // Retarget
<span class="nc" id="L1248">        bnNew = bnNew.multiply(BigInteger.valueOf(nActualTimespan));</span>
<span class="nc" id="L1249">        bnNew = bnNew.divide(BigInteger.valueOf(nTargetTimespan));</span>
<span class="nc" id="L1250">        verifyDifficulty(bnNew, storedPrev, nextBlock);</span>
        
<span class="nc" id="L1252">    }</span>


    private void checkDifficultyTransitions_V1(StoredBlock storedPrev, Block nextBlock) throws BlockStoreException, VerificationException {
        //checkState(lock.isHeldByCurrentThread());
<span class="nc" id="L1257">        Block prev = storedPrev.getHeader();</span>

        // Is this supposed to be a difficulty transition point?
<span class="nc bnc" id="L1260" title="All 2 branches missed.">        if ((storedPrev.getHeight() + 1) % params.getInterval() != 0) {</span>

            // TODO: Refactor this hack after 0.5 is released and we stop supporting deserialization compatibility.
            // This should be a method of the NetworkParameters, which should in turn be using singletons and a subclass
            // for each network type. Then each network can define its own difficulty transition rules.
<span class="nc bnc" id="L1265" title="All 4 branches missed.">            if (params.getId().equals(NetworkParameters.ID_TESTNET) &amp;&amp; nextBlock.getTime().after(testnetDiffDate)) {</span>
<span class="nc" id="L1266">                checkTestnetDifficulty(storedPrev, prev, nextBlock);</span>
<span class="nc" id="L1267">                return;</span>
            }

            // No ... so check the difficulty didn't actually change.
<span class="nc bnc" id="L1271" title="All 2 branches missed.">            if (nextBlock.getDifficultyTarget() != prev.getDifficultyTarget()) {</span>
                //todo: furszy: check difficulty transition commented.
<span class="nc" id="L1273">                log.debug(&quot;Unexpected change in difficulty at height &quot; + storedPrev.getHeight());</span>
<span class="nc" id="L1274">                return;</span>
                //throw new VerificationException(&quot;Unexpected change in difficulty at height &quot; + storedPrev.getHeight() +
                //        &quot;: &quot; + Long.toHexString(nextBlock.getDifficultyTarget()) + &quot; vs &quot; +
                //        Long.toHexString(prev.getDifficultyTarget()));
            }
<span class="nc" id="L1279">            return;</span>
        }

        // We need to find a block far back in the chain. It's OK that this is expensive because it only occurs every
        // two weeks after the initial block chain download.
<span class="nc" id="L1284">        long now = System.currentTimeMillis();</span>
<span class="nc" id="L1285">        StoredBlock cursor = blockStore.get(prev.getHash());</span>

<span class="nc" id="L1287">        int blockstogoback = params.getInterval() - 1;</span>
<span class="nc bnc" id="L1288" title="All 2 branches missed.">        if(storedPrev.getHeight()+1 != params.getInterval())</span>
<span class="nc" id="L1289">            blockstogoback = params.getInterval();</span>

<span class="nc bnc" id="L1291" title="All 2 branches missed.">        for (int i = 0; i &lt; blockstogoback; i++) {</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">            if (cursor == null) {</span>
                // This should never happen. If it does, it means we are following an incorrect or busted chain.
<span class="nc" id="L1294">                throw new VerificationException(</span>
                        &quot;Difficulty transition point but we did not find a way back to the genesis block.&quot;);
            }
<span class="nc" id="L1297">            cursor = blockStore.get(cursor.getHeader().getPrevBlockHash());</span>
        }
<span class="nc" id="L1299">        long elapsed = System.currentTimeMillis() - now;</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">        if (elapsed &gt; 50)</span>
<span class="nc" id="L1301">            log.info(&quot;Difficulty transition traversal took {}msec&quot;, elapsed);</span>

<span class="nc" id="L1303">        Block blockIntervalAgo = cursor.getHeader();</span>
<span class="nc" id="L1304">        int timespan = (int) (prev.getTimeSeconds() - blockIntervalAgo.getTimeSeconds());</span>
        // Limit the adjustment step.
<span class="nc" id="L1306">        final int targetTimespan = params.getTargetTimespan();</span>
<span class="nc bnc" id="L1307" title="All 2 branches missed.">        if (timespan &lt; targetTimespan / 4)</span>
<span class="nc" id="L1308">            timespan = targetTimespan / 4;</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">        if (timespan &gt; targetTimespan * 4)</span>
<span class="nc" id="L1310">            timespan = targetTimespan * 4;</span>

<span class="nc" id="L1312">        BigInteger newTarget = Utils.decodeCompactBits(prev.getDifficultyTarget());</span>
<span class="nc" id="L1313">        newTarget = newTarget.multiply(BigInteger.valueOf(timespan));</span>
<span class="nc" id="L1314">        newTarget = newTarget.divide(BigInteger.valueOf(targetTimespan));</span>

<span class="nc bnc" id="L1316" title="All 2 branches missed.">        if (newTarget.compareTo(params.getMaxTarget()) &gt; 0) {</span>
<span class="nc" id="L1317">            log.info(&quot;Difficulty hit proof of work limit: {}&quot;, newTarget.toString(16));</span>
<span class="nc" id="L1318">            newTarget = params.getMaxTarget();</span>
        }

<span class="nc" id="L1321">        int accuracyBytes = (int) (nextBlock.getDifficultyTarget() &gt;&gt;&gt; 24) - 3;</span>
<span class="nc" id="L1322">        long receivedTargetCompact = nextBlock.getDifficultyTarget();</span>

        // The calculated difficulty is to a higher precision than received, so reduce here.
<span class="nc" id="L1325">        BigInteger mask = BigInteger.valueOf(0xFFFFFFL).shiftLeft(accuracyBytes * 8);</span>
<span class="nc" id="L1326">        newTarget = newTarget.and(mask);</span>
<span class="nc" id="L1327">        long newTargetCompact = Utils.encodeCompactBits(newTarget);</span>

<span class="nc bnc" id="L1329" title="All 2 branches missed.">        if (newTargetCompact != receivedTargetCompact)</span>
<span class="nc" id="L1330">            throw new VerificationException(&quot;Network provided difficulty bits do not match what was calculated: &quot; +</span>
                    newTargetCompact + &quot; vs &quot; + receivedTargetCompact);
<span class="nc" id="L1332">    }</span>

    private void checkDifficultyTransitions_V2(StoredBlock storedPrev, Block nextBlock) throws BlockStoreException, VerificationException {
<span class="nc" id="L1335">        final long      	BlocksTargetSpacing			= (long)(2.5 * 60); // 10 minutes</span>
<span class="nc" id="L1336">        int         		TimeDaySeconds				= 60 * 60 * 24;</span>
<span class="nc" id="L1337">        long				PastSecondsMin				= TimeDaySeconds / 40;</span>
<span class="nc" id="L1338">        long				PastSecondsMax				= TimeDaySeconds * 7;</span>
<span class="nc" id="L1339">        long				PastBlocksMin				= PastSecondsMin / BlocksTargetSpacing;   //? blocks</span>
<span class="nc" id="L1340">        long				PastBlocksMax				= PastSecondsMax / BlocksTargetSpacing;   //? blocks</span>

        //if(!fgw.isNativeLibraryLoaded())
            //long start = System.currentTimeMillis();
<span class="nc" id="L1344">            KimotoGravityWell(storedPrev, nextBlock, BlocksTargetSpacing, PastBlocksMin, PastBlocksMax);</span>
            //long end1 = System.currentTimeMillis();
            //if(kgw.isNativeLibraryLoaded())
        //else
            //    KimotoGravityWell_N(storedPrev, nextBlock, BlocksTargetSpacing, PastBlocksMin, PastBlocksMax);
            //long end2 = System.currentTimeMillis();
            //if(kgw.isNativeLibraryLoaded())
        //    KimotoGravityWell_N2(storedPrev, nextBlock, BlocksTargetSpacing, PastBlocksMin, PastBlocksMax);
        /*long end3 = System.currentTimeMillis();

        long java = end1 - start;
        long n1 = end2 - end1;
        long n2 = end3 - end2;
        if(i &gt; 20)
        {
            j += java;
            N += n1;
            N2 += n2;
            if(i != 0 &amp;&amp; ((i % 10) == 0))
             //log.info(&quot;KGW 10 blocks: J={}; N={} -%.0f%; N2={} -%.0f%&quot;, java, n1, ((double)(java-n1))/java*100, n2, ((double)(java-n2))/java*100);
                 log.info(&quot;KGW {} blocks: J={}; N={} -{}%; N2={} -{}%&quot;, i-20, j, N, ((double)(j-N))/j*100, N2, ((double)(j-N2))/j*100);
        }
        ++i;*/
<span class="nc" id="L1367">    }</span>

    private void KimotoGravityWell(StoredBlock storedPrev, Block nextBlock, long TargetBlocksSpacingSeconds, long PastBlocksMin, long PastBlocksMax)  throws BlockStoreException, VerificationException {
	/* current difficulty formula, megacoin - kimoto gravity well */
        //const CBlockIndex  *BlockLastSolved				= pindexLast;
        //const CBlockIndex  *BlockReading				= pindexLast;
        //const CBlockHeader *BlockCreating				= pblock;
<span class="nc" id="L1374">        StoredBlock         BlockLastSolved             = storedPrev;</span>
<span class="nc" id="L1375">        StoredBlock         BlockReading                = storedPrev;</span>
<span class="nc" id="L1376">        Block               BlockCreating               = nextBlock;</span>

<span class="nc" id="L1378">        BlockCreating				= BlockCreating;</span>
<span class="nc" id="L1379">        long				PastBlocksMass				= 0;</span>
<span class="nc" id="L1380">        long				PastRateActualSeconds		= 0;</span>
<span class="nc" id="L1381">        long				PastRateTargetSeconds		= 0;</span>
<span class="nc" id="L1382">        double				PastRateAdjustmentRatio		= 1f;</span>
<span class="nc" id="L1383">        BigInteger			PastDifficultyAverage = BigInteger.valueOf(0);</span>
<span class="nc" id="L1384">        BigInteger			PastDifficultyAveragePrev = BigInteger.valueOf(0);;</span>
        double				EventHorizonDeviation;
        double				EventHorizonDeviationFast;
        double				EventHorizonDeviationSlow;

<span class="nc" id="L1389">        long start = System.currentTimeMillis();</span>

<span class="nc bnc" id="L1391" title="All 6 branches missed.">        if (BlockLastSolved == null || BlockLastSolved.getHeight() == 0 || (long)BlockLastSolved.getHeight() &lt; PastBlocksMin)</span>
<span class="nc" id="L1392">        { verifyDifficulty(params.getMaxTarget(), storedPrev, nextBlock); }</span>

<span class="nc" id="L1394">        int i = 0;</span>
<span class="nc" id="L1395">        long LatestBlockTime = BlockLastSolved.getHeader().getTimeSeconds();</span>

<span class="nc bnc" id="L1397" title="All 4 branches missed.">        for (i = 1; BlockReading != null &amp;&amp; BlockReading.getHeight() &gt; 0; i++) {</span>
<span class="nc bnc" id="L1398" title="All 4 branches missed.">            if (PastBlocksMax &gt; 0 &amp;&amp; i &gt; PastBlocksMax) { break; }</span>
<span class="nc" id="L1399">            PastBlocksMass++;</span>

<span class="nc bnc" id="L1401" title="All 2 branches missed.">            if (i == 1)	{ PastDifficultyAverage = BlockReading.getHeader().getDifficultyTargetAsInteger(); }</span>
<span class="nc" id="L1402">            else		{ PastDifficultyAverage = ((BlockReading.getHeader().getDifficultyTargetAsInteger().subtract(PastDifficultyAveragePrev)).divide(BigInteger.valueOf(i)).add(PastDifficultyAveragePrev)); }</span>
<span class="nc" id="L1403">            PastDifficultyAveragePrev = PastDifficultyAverage;</span>


<span class="nc bnc" id="L1406" title="All 4 branches missed.">            if (BlockReading.getHeight() &gt; 646120 &amp;&amp; LatestBlockTime &lt; BlockReading.getHeader().getTimeSeconds()) {</span>
                //eliminates the ability to go back in time
<span class="nc" id="L1408">                LatestBlockTime = BlockReading.getHeader().getTimeSeconds();</span>
            }

<span class="nc" id="L1411">            PastRateActualSeconds			= BlockLastSolved.getHeader().getTimeSeconds() - BlockReading.getHeader().getTimeSeconds();</span>
<span class="nc" id="L1412">            PastRateTargetSeconds			= TargetBlocksSpacingSeconds * PastBlocksMass;</span>
<span class="nc" id="L1413">            PastRateAdjustmentRatio			= 1.0f;</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">            if (BlockReading.getHeight() &gt; 646120){</span>
                //this should slow down the upward difficulty change
<span class="nc bnc" id="L1416" title="All 2 branches missed.">                if (PastRateActualSeconds &lt; 5) { PastRateActualSeconds = 5; }</span>
            }
            else {
<span class="nc bnc" id="L1419" title="All 2 branches missed.">                if (PastRateActualSeconds &lt; 0) { PastRateActualSeconds = 0; }</span>
            }
<span class="nc bnc" id="L1421" title="All 4 branches missed.">            if (PastRateActualSeconds != 0 &amp;&amp; PastRateTargetSeconds != 0) {</span>
<span class="nc" id="L1422">                PastRateAdjustmentRatio			= (double)PastRateTargetSeconds / PastRateActualSeconds;</span>
            }
<span class="nc" id="L1424">            EventHorizonDeviation			= 1 + (0.7084 * java.lang.Math.pow((Double.valueOf(PastBlocksMass)/Double.valueOf(28.2)), -1.228));</span>
<span class="nc" id="L1425">            EventHorizonDeviationFast		= EventHorizonDeviation;</span>
<span class="nc" id="L1426">            EventHorizonDeviationSlow		= 1 / EventHorizonDeviation;</span>

<span class="nc bnc" id="L1428" title="All 2 branches missed.">            if (PastBlocksMass &gt;= PastBlocksMin) {</span>
<span class="nc bnc" id="L1429" title="All 4 branches missed.">                if ((PastRateAdjustmentRatio &lt;= EventHorizonDeviationSlow) || (PastRateAdjustmentRatio &gt;= EventHorizonDeviationFast))</span>
                {
                    /*assert(BlockReading)*/;
<span class="nc" id="L1432">                    break;</span>
                }
            }
<span class="nc" id="L1435">            StoredBlock BlockReadingPrev = blockStore.get(BlockReading.getHeader().getPrevBlockHash());</span>
<span class="nc bnc" id="L1436" title="All 2 branches missed.">            if (BlockReadingPrev == null)</span>
            {
                //assert(BlockReading);
                //Since we are using the checkpoint system, there may not be enough blocks to do this diff adjust, so skip until we do
                //break;
<span class="nc" id="L1441">                return;</span>
            }
<span class="nc" id="L1443">            BlockReading = BlockReadingPrev;</span>
        }

        /*CBigNum bnNew(PastDifficultyAverage);
        if (PastRateActualSeconds != 0 &amp;&amp; PastRateTargetSeconds != 0) {
            bnNew *= PastRateActualSeconds;
            bnNew /= PastRateTargetSeconds;
        } */
        //log.info(&quot;KGW-J, {}, {}, {}&quot;, storedPrev.getHeight(), i, System.currentTimeMillis() - start);
<span class="nc" id="L1452">        BigInteger newDifficulty = PastDifficultyAverage;</span>
<span class="nc bnc" id="L1453" title="All 4 branches missed.">        if (PastRateActualSeconds != 0 &amp;&amp; PastRateTargetSeconds != 0) {</span>
<span class="nc" id="L1454">            newDifficulty = newDifficulty.multiply(BigInteger.valueOf(PastRateActualSeconds));</span>
<span class="nc" id="L1455">            newDifficulty = newDifficulty.divide(BigInteger.valueOf(PastRateTargetSeconds));</span>
        }

<span class="nc bnc" id="L1458" title="All 2 branches missed.">        if (newDifficulty.compareTo(params.getMaxTarget()) &gt; 0) {</span>
<span class="nc" id="L1459">            log.info(&quot;Difficulty hit proof of work limit: {}&quot;, newDifficulty.toString(16));</span>
<span class="nc" id="L1460">            newDifficulty = params.getMaxTarget();</span>
        }


        //log.info(&quot;KGW-j Difficulty Calculated: {}&quot;, newDifficulty.toString(16));
<span class="nc" id="L1465">        verifyDifficulty(newDifficulty, storedPrev, nextBlock);</span>

<span class="nc" id="L1467">    }</span>

    static double ConvertBitsToDouble(long nBits){
<span class="nc" id="L1470">        long nShift = (nBits &gt;&gt; 24) &amp; 0xff;</span>

<span class="nc" id="L1472">        double dDiff =</span>
                (double)0x0000ffff / (double)(nBits &amp; 0x00ffffff);

<span class="nc bnc" id="L1475" title="All 2 branches missed.">        while (nShift &lt; 29)</span>
        {
<span class="nc" id="L1477">            dDiff *= 256.0;</span>
<span class="nc" id="L1478">            nShift++;</span>
        }
<span class="nc bnc" id="L1480" title="All 2 branches missed.">        while (nShift &gt; 29)</span>
        {
<span class="nc" id="L1482">            dDiff /= 256.0;</span>
<span class="nc" id="L1483">            nShift--;</span>
        }

<span class="nc" id="L1486">        return dDiff;</span>
    }

    private void verifyDifficulty(BigInteger calcDiff, StoredBlock storedPrev, Block nextBlock)
    {
<span class="nc bnc" id="L1491" title="All 2 branches missed.">        if (calcDiff.compareTo(params.getMaxTarget()) &gt; 0) {</span>
<span class="nc" id="L1492">            log.info(&quot;Difficulty hit proof of work limit: {}&quot;, calcDiff.toString(16));</span>
<span class="nc" id="L1493">            calcDiff = params.getMaxTarget();</span>
        }
<span class="nc" id="L1495">        int accuracyBytes = (int) (nextBlock.getDifficultyTarget() &gt;&gt;&gt; 24) - 3;</span>
<span class="nc" id="L1496">        BigInteger receivedDifficulty = nextBlock.getDifficultyTargetAsInteger();</span>

        // The calculated difficulty is to a higher precision than received, so reduce here.
<span class="nc" id="L1499">        BigInteger mask = BigInteger.valueOf(0xFFFFFFL).shiftLeft(accuracyBytes * 8);</span>
<span class="nc" id="L1500">        calcDiff = calcDiff.and(mask);</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">        if(params.getId().compareTo(params.ID_TESTNET) == 0)</span>
        {
<span class="nc bnc" id="L1503" title="All 2 branches missed.">            if (calcDiff.compareTo(receivedDifficulty) != 0)</span>
<span class="nc" id="L1504">                throw new VerificationException(&quot;Network provided difficulty bits do not match what was calculated: &quot; +</span>
<span class="nc" id="L1505">                        receivedDifficulty.toString(16) + &quot; vs &quot; + calcDiff.toString(16));</span>
        }
        else
        {



<span class="nc" id="L1512">            int height = storedPrev.getHeight() + 1;</span>
            ///if(System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;windows&quot;))
            //{
<span class="nc bnc" id="L1515" title="All 2 branches missed.">            if(height &lt;= 68589)</span>
            {
<span class="nc" id="L1517">                long nBitsNext = nextBlock.getDifficultyTarget();</span>

<span class="nc" id="L1519">                long calcDiffBits = (accuracyBytes+3) &lt;&lt; 24;</span>
<span class="nc" id="L1520">                calcDiffBits |= calcDiff.shiftRight(accuracyBytes*8).longValue();</span>

<span class="nc" id="L1522">                double n1 = ConvertBitsToDouble(calcDiffBits);</span>
<span class="nc" id="L1523">                double n2 = ConvertBitsToDouble(nBitsNext);</span>




<span class="nc bnc" id="L1528" title="All 2 branches missed.">                if(java.lang.Math.abs(n1-n2) &gt; n1*0.2)</span>
<span class="nc" id="L1529">                              throw new VerificationException(&quot;Network provided difficulty bits do not match what was calculated: &quot; +</span>
<span class="nc" id="L1530">                                receivedDifficulty.toString(16) + &quot; vs &quot; + calcDiff.toString(16));</span>


<span class="nc" id="L1533">            }</span>
            else
            {
<span class="nc bnc" id="L1536" title="All 2 branches missed.">                    if (calcDiff.compareTo(receivedDifficulty) != 0)</span>
<span class="nc" id="L1537">                        throw new VerificationException(&quot;Network provided difficulty bits do not match what was calculated: &quot; +</span>
<span class="nc" id="L1538">                                receivedDifficulty.toString(16) + &quot; vs &quot; + calcDiff.toString(16));</span>
            }



            /*
            if(height &gt;= 34140)
                {
                    long nBitsNext = nextBlock.getDifficultyTarget();

                    long calcDiffBits = (accuracyBytes+3) &lt;&lt; 24;
                    calcDiffBits |= calcDiff.shiftRight(accuracyBytes*8).longValue();

                    double n1 = ConvertBitsToDouble(calcDiffBits);
                    double n2 = ConvertBitsToDouble(nBitsNext);

                    if(height &lt;= 45000) {


                        if(java.lang.Math.abs(n1-n2) &gt; n1*0.2)
                            throw new VerificationException(&quot;Network provided difficulty bits do not match what was calculated: &quot; +
                                    receivedDifficulty.toString(16) + &quot; vs &quot; + calcDiff.toString(16));


                    }
                    else if(java.lang.Math.abs(n1-n2) &gt; n1*0.005)
                        throw new VerificationException(&quot;Network provided difficulty bits do not match what was calculated: &quot; +
                                receivedDifficulty.toString(16) + &quot; vs &quot; + calcDiff.toString(16));

                }
                else
                {
                    if (calcDiff.compareTo(receivedDifficulty) != 0)
                        throw new VerificationException(&quot;Network provided difficulty bits do not match what was calculated: &quot; +
                                receivedDifficulty.toString(16) + &quot; vs &quot; + calcDiff.toString(16));
                }
            */

            //}
            /*else
            {

            if(height &gt;= 34140 &amp;&amp; height &lt;= 45000)
            {
                long nBitsNext = nextBlock.getDifficultyTarget();

                long calcDiffBits = (accuracyBytes+3) &lt;&lt; 24;
                calcDiffBits |= calcDiff.shiftRight(accuracyBytes*8).longValue();

                double n1 = ConvertBitsToDouble(calcDiffBits);
                double n2 = ConvertBitsToDouble(nBitsNext);

                if(java.lang.Math.abs(n1-n2) &gt; n1*0.2)
                    throw new VerificationException(&quot;Network provided difficulty bits do not match what was calculated: &quot; +
                            receivedDifficulty.toString(16) + &quot; vs &quot; + calcDiff.toString(16));

            }
            else
            {
                if (calcDiff.compareTo(receivedDifficulty) != 0)
                    throw new VerificationException(&quot;Network provided difficulty bits do not match what was calculated: &quot; +
                            receivedDifficulty.toString(16) + &quot; vs &quot; + calcDiff.toString(16));
            }

            }*/
        }
<span class="nc" id="L1604">    }</span>

    private void checkTestnetDifficulty(StoredBlock storedPrev, Block prev, Block next) throws VerificationException, BlockStoreException {
<span class="nc" id="L1607">        checkState(lock.isHeldByCurrentThread());</span>
        // After 15th February 2012 the rules on the testnet change to avoid people running up the difficulty
        // and then leaving, making it too hard to mine a block. On non-difficulty transition points, easy
        // blocks are allowed if there has been a span of 20 minutes without one.
<span class="nc" id="L1611">        final long timeDelta = next.getTimeSeconds() - prev.getTimeSeconds();</span>
        // There is an integer underflow bug in bitcoin-qt that means mindiff blocks are accepted when time
        // goes backwards.
<span class="nc bnc" id="L1614" title="All 4 branches missed.">        if (timeDelta &gt;= 0 &amp;&amp; timeDelta &lt;= NetworkParameters.TARGET_SPACING * 2) {</span>
            // Walk backwards until we find a block that doesn't have the easiest proof of work, then check
            // that difficulty is equal to that one.
<span class="nc" id="L1617">            StoredBlock cursor = storedPrev;</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">            while (!cursor.getHeader().equals(params.getGenesisBlock()) &amp;&amp;</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">                   cursor.getHeight() % params.getInterval() != 0 &amp;&amp;</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">                   cursor.getHeader().getDifficultyTargetAsInteger().equals(params.getMaxTarget()))</span>
<span class="nc" id="L1621">                cursor = cursor.getPrev(blockStore);</span>
<span class="nc" id="L1622">            BigInteger cursorTarget = cursor.getHeader().getDifficultyTargetAsInteger();</span>
<span class="nc" id="L1623">            BigInteger newTarget = next.getDifficultyTargetAsInteger();</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">            if (!cursorTarget.equals(newTarget))</span>
<span class="nc" id="L1625">                throw new VerificationException(&quot;Testnet block transition that is not allowed: &quot; +</span>
<span class="nc" id="L1626">                    Long.toHexString(cursor.getHeader().getDifficultyTarget()) + &quot; vs &quot; +</span>
<span class="nc" id="L1627">                    Long.toHexString(next.getDifficultyTarget()));</span>
        }
<span class="nc" id="L1629">    }</span>


    /**
     * Returns the block at the head of the current best chain. This is the block which represents the greatest
     * amount of cumulative work done.
     */
    public StoredBlock getChainHead() {
<span class="fc" id="L1637">        synchronized (chainHeadLock) {</span>
<span class="fc" id="L1638">            return chainHead;</span>
<span class="nc" id="L1639">        }</span>
    }

    /**
     * An orphan block is one that does not connect to the chain anywhere (ie we can't find its parent, therefore
     * it's an orphan). Typically this occurs when we are downloading the chain and didn't reach the head yet, and/or
     * if a block is solved whilst we are downloading. It's possible that we see a small amount of orphan blocks which
     * chain together, this method tries walking backwards through the known orphan blocks to find the bottom-most.
     *
     * @return from or one of froms parents, or null if &quot;from&quot; does not identify an orphan block
     */
    @Nullable
    public Block getOrphanRoot(Sha256Hash from) {
<span class="nc" id="L1652">        lock.lock();</span>
        try {
<span class="nc" id="L1654">            OrphanBlock cursor = orphanBlocks.get(from);</span>
<span class="nc bnc" id="L1655" title="All 2 branches missed.">            if (cursor == null)</span>
<span class="nc" id="L1656">                return null;</span>
            OrphanBlock tmp;
<span class="nc bnc" id="L1658" title="All 2 branches missed.">            while ((tmp = orphanBlocks.get(cursor.block.getPrevBlockHash())) != null) {</span>
<span class="nc" id="L1659">                cursor = tmp;</span>
            }
<span class="nc" id="L1661">            return cursor.block;</span>
        } finally {
<span class="nc" id="L1663">            lock.unlock();</span>
<span class="nc" id="L1664">        }</span>
    }

    /** Returns true if the given block is currently in the orphan blocks list. */
    public boolean isOrphan(Sha256Hash block) {
<span class="nc" id="L1669">        lock.lock();</span>
        try {
<span class="nc" id="L1671">            return orphanBlocks.containsKey(block);</span>
        } finally {
<span class="nc" id="L1673">            lock.unlock();</span>
<span class="nc" id="L1674">        }</span>
    }

    /**
     * Returns an estimate of when the given block will be reached, assuming a perfect 10 minute average for each
     * block. This is useful for turning transaction lock times into human readable times. Note that a height in
     * the past will still be estimated, even though the time of solving is actually known (we won't scan backwards
     * through the chain to obtain the right answer).
     */
    public Date estimateBlockTime(int height) {
<span class="fc" id="L1684">        synchronized (chainHeadLock) {</span>
<span class="fc" id="L1685">            long offset = height - chainHead.getHeight();</span>
<span class="fc" id="L1686">            long headTime = chainHead.getHeader().getTimeSeconds();</span>
<span class="fc" id="L1687">            long estimated = (headTime * 1000) + (1000L * 60L * 10L * offset);</span>
<span class="fc" id="L1688">            return new Date(estimated);</span>
<span class="nc" id="L1689">        }</span>
    }

    /**
     * Returns a future that completes when the block chain has reached the given height. Yields the
     * {@link StoredBlock} of the block that reaches that height first. The future completes on a peer thread.
     */
    public ListenableFuture&lt;StoredBlock&gt; getHeightFuture(final int height) {
<span class="fc" id="L1697">        final SettableFuture&lt;StoredBlock&gt; result = SettableFuture.create();</span>
<span class="fc" id="L1698">        addNewBestBlockListener(Threading.SAME_THREAD, new NewBestBlockListener() {</span>
            @Override
            public void notifyNewBestBlock(StoredBlock block) throws VerificationException {
<span class="nc bnc" id="L1701" title="All 2 branches missed.">                if (block.getHeight() &gt;= height) {</span>
<span class="nc" id="L1702">                    removeNewBestBlockListener(this);</span>
<span class="nc" id="L1703">                    result.set(block);</span>
                }
<span class="nc" id="L1705">            }</span>
        });
<span class="fc" id="L1707">        return result;</span>
    }



    /**
     * The false positive rate is the average over all blockchain transactions of:
     *
     * - 1.0 if the transaction was false-positive (was irrelevant to all listeners)
     * - 0.0 if the transaction was relevant or filtered out
     */
    public double getFalsePositiveRate() {
<span class="fc" id="L1719">        return falsePositiveRate;</span>
    }

    /*
     * We completed handling of a filtered block. Update false-positive estimate based
     * on the total number of transactions in the original block.
     *
     * count includes filtered transactions, transactions that were passed in and were relevant
     * and transactions that were false positives (i.e. includes all transactions in the block).
     */
    protected void trackFilteredTransactions(int count) {
        // Track non-false-positives in batch.  Each non-false-positive counts as
        // 0.0 towards the estimate.
        //
        // This is slightly off because we are applying false positive tracking before non-FP tracking,
        // which counts FP as if they came at the beginning of the block.  Assuming uniform FP
        // spread in a block, this will somewhat underestimate the FP rate (5% for 1000 tx block).
<span class="fc" id="L1736">        double alphaDecay = Math.pow(1 - FP_ESTIMATOR_ALPHA, count);</span>

        // new_rate = alpha_decay * new_rate
<span class="fc" id="L1739">        falsePositiveRate = alphaDecay * falsePositiveRate;</span>

<span class="fc" id="L1741">        double betaDecay = Math.pow(1 - FP_ESTIMATOR_BETA, count);</span>

        // trend = beta * (new_rate - old_rate) + beta_decay * trend
<span class="fc" id="L1744">        falsePositiveTrend =</span>
                FP_ESTIMATOR_BETA * count * (falsePositiveRate - previousFalsePositiveRate) +
                betaDecay * falsePositiveTrend;

        // new_rate += alpha_decay * trend
<span class="fc" id="L1749">        falsePositiveRate += alphaDecay * falsePositiveTrend;</span>

        // Stash new_rate in old_rate
<span class="fc" id="L1752">        previousFalsePositiveRate = falsePositiveRate;</span>
<span class="fc" id="L1753">    }</span>

    /* Irrelevant transactions were received.  Update false-positive estimate. */
    void trackFalsePositives(int count) {
        // Track false positives in batch by adding alpha to the false positive estimate once per count.
        // Each false positive counts as 1.0 towards the estimate.
<span class="fc" id="L1759">        falsePositiveRate += FP_ESTIMATOR_ALPHA * count;</span>
<span class="fc bfc" id="L1760" title="All 2 branches covered.">        if (count &gt; 0)</span>
<span class="fc" id="L1761">            log.debug(&quot;{} false positives, current rate = {} trend = {}&quot;, count, falsePositiveRate, falsePositiveTrend);</span>
<span class="fc" id="L1762">    }</span>

    /** Resets estimates of false positives. Used when the filter is sent to the peer. */
    public void resetFalsePositiveEstimate() {
<span class="fc" id="L1766">        falsePositiveRate = 0;</span>
<span class="fc" id="L1767">        falsePositiveTrend = 0;</span>
<span class="fc" id="L1768">        previousFalsePositiveRate = 0;</span>
<span class="fc" id="L1769">    }</span>

    protected VersionTally getVersionTally() {
<span class="fc" id="L1772">        return versionTally;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>