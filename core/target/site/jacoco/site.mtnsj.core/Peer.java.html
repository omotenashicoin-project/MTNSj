<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Peer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mtnsj</a> &gt; <a href="index.source.html" class="el_package">site.mtnsj.core</a> &gt; <span class="el_source">Peer.java</span></div><h1>Peer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package site.mtnsj.core;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.common.base.Throwables;
import site.mtnsj.core.listeners.*;
import site.mtnsj.net.StreamConnection;
import site.mtnsj.store.BlockStore;
import site.mtnsj.store.BlockStoreException;
import site.mtnsj.utils.ListenerRegistration;
import site.mtnsj.utils.Threading;
import site.mtnsj.wallet.Wallet;

import com.google.common.collect.Lists;
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.SettableFuture;
import net.jcip.annotations.GuardedBy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

/**
 * &lt;p&gt;A Peer handles the high level communication with a Bitcoin node, extending a {@link PeerSocketHandler} which
 * handles low-level message (de)serialization.&lt;/p&gt;
 *
 * &lt;p&gt;Note that timeouts are handled by the extended
 * {@link site.mtnsj.net.AbstractTimeoutHandler} and timeout is automatically disabled (using
 * {@link site.mtnsj.net.AbstractTimeoutHandler#setTimeoutEnabled(boolean)}) once the version
 * handshake completes.&lt;/p&gt;
 */
public class Peer extends PeerSocketHandler {
<span class="fc" id="L61">    private static final Logger log = LoggerFactory.getLogger(Peer.class);</span>

<span class="fc" id="L63">    protected final ReentrantLock lock = Threading.lock(&quot;peer&quot;);</span>

    private final NetworkParameters params;
    private final AbstractBlockChain blockChain;
    private final Context context;

<span class="fc" id="L69">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;BlocksDownloadedEventListener&gt;&gt; blocksDownloadedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;BlocksDownloadedEventListener&gt;&gt;();
<span class="fc" id="L71">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;ChainDownloadStartedEventListener&gt;&gt; chainDownloadStartedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;ChainDownloadStartedEventListener&gt;&gt;();
<span class="fc" id="L73">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerConnectedEventListener&gt;&gt; connectedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerConnectedEventListener&gt;&gt;();
<span class="fc" id="L75">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerDisconnectedEventListener&gt;&gt; disconnectedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerDisconnectedEventListener&gt;&gt;();
<span class="fc" id="L77">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;GetDataEventListener&gt;&gt; getDataEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;GetDataEventListener&gt;&gt;();
<span class="fc" id="L79">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PreMessageReceivedEventListener&gt;&gt; preMessageReceivedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;PreMessageReceivedEventListener&gt;&gt;();
<span class="fc" id="L81">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;OnTransactionBroadcastListener&gt;&gt; onTransactionEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;OnTransactionBroadcastListener&gt;&gt;();
    // Whether to try and download blocks and transactions from this peer. Set to false by PeerGroup if not the
    // primary peer. This is to avoid redundant work and concurrency problems with downloading the same chain
    // in parallel.
    private volatile boolean vDownloadData;
    // The version data to announce to the other side of the connections we make: useful for setting our &quot;user agent&quot;
    // equivalent and other things.
    private final VersionMessage versionMessage;
    // Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
    private volatile int vDownloadTxDependencyDepth;
    // How many block messages the peer has announced to us. Peers only announce blocks that attach to their best chain
    // so we can use this to calculate the height of the peers chain, by adding it to the initial height in the version
    // message. This method can go wrong if the peer re-orgs onto a shorter (but harder) chain, however, this is rare.
<span class="fc" id="L95">    private final AtomicInteger blocksAnnounced = new AtomicInteger();</span>
    // Each wallet added to the peer will be notified of downloaded transaction data.
    private final CopyOnWriteArrayList&lt;Wallet&gt; wallets;
    // A time before which we only download block headers, after that point we download block bodies.
    @GuardedBy(&quot;lock&quot;) private long fastCatchupTimeSecs;
    // Whether we are currently downloading headers only or block bodies. Starts at true. If the fast catchup time is
    // set AND our best block is before that date, switch to false until block headers beyond that point have been
    // received at which point it gets set to true again. This isn't relevant unless vDownloadData is true.
<span class="fc" id="L103">    @GuardedBy(&quot;lock&quot;) private boolean downloadBlockBodies = true;</span>
    // Whether to request filtered blocks instead of full blocks if the protocol version allows for them.
<span class="fc" id="L105">    @GuardedBy(&quot;lock&quot;) private boolean useFilteredBlocks = false;</span>
    // The current Bloom filter set on the connection, used to tell the remote peer what transactions to send us.
    private volatile BloomFilter vBloomFilter;
    // The last filtered block we received, we're waiting to fill it out with transactions.
<span class="fc" id="L109">    private FilteredBlock currentFilteredBlock = null;</span>
    // How many filtered blocks have been received during the lifetime of this connection. Used to decide when to
    // refresh the server-side side filter by sending a new one (it degrades over time as false positives are added
    // on the remote side, see BIP 37 for a discussion of this).
    // TODO: Is this still needed? It should not be since the auto FP tracking logic was added.
    private int filteredBlocksReceived;
    // If non-null, we should discard incoming filtered blocks because we ran out of keys and are awaiting a new filter
    // to be calculated by the PeerGroup. The discarded block hashes should be added here so we can re-request them
    // once we've recalculated and resent a new filter.
    @GuardedBy(&quot;lock&quot;) @Nullable private List&lt;Sha256Hash&gt; awaitingFreshFilter;
    // How frequently to refresh the filter. This should become dynamic in future and calculated depending on the
    // actual false positive rate. For now a good value was determined empirically around January 2013.
    private static final int RESEND_BLOOM_FILTER_BLOCK_COUNT = 25000;
    // Keeps track of things we requested internally with getdata but didn't receive yet, so we can avoid re-requests.
    // It's not quite the same as getDataFutures, as this is used only for getdatas done as part of downloading
    // the chain and so is lighter weight (we just keep a bunch of hashes not futures).
    //
    // It is important to avoid a nasty edge case where we can end up with parallel chain downloads proceeding
    // simultaneously if we were to receive a newly solved block whilst parts of the chain are streaming to us.
<span class="fc" id="L128">    private final HashSet&lt;Sha256Hash&gt; pendingBlockDownloads = new HashSet&lt;Sha256Hash&gt;();</span>
    // Keep references to TransactionConfidence objects for transactions that were announced by a remote peer, but
    // which we haven't downloaded yet. These objects are de-duplicated by the TxConfidenceTable class.
    // Once the tx is downloaded (by some peer), the Transaction object that is created will have a reference to
    // the confidence object held inside it, and it's then up to the event listeners that receive the Transaction
    // to keep it pinned to the root set if they care about this data.
<span class="fc" id="L134">    @SuppressWarnings(&quot;MismatchedQueryAndUpdateOfCollection&quot;)</span>
    private final HashSet&lt;TransactionConfidence&gt; pendingTxDownloads = new HashSet&lt;TransactionConfidence&gt;();
    // The lowest version number we're willing to accept. Lower than this will result in an immediate disconnect.
    private volatile int vMinProtocolVersion;

    // When an API user explicitly requests a block or transaction from a peer, the InventoryItem is put here
    // whilst waiting for the response. Is not used for downloads Peer generates itself.
    private static class GetDataRequest {
<span class="nc" id="L142">        public GetDataRequest(Sha256Hash hash, SettableFuture future) {</span>
<span class="nc" id="L143">            this.hash = hash;</span>
<span class="nc" id="L144">            this.future = future;</span>
<span class="nc" id="L145">        }</span>
        final Sha256Hash hash;
        final SettableFuture future;
    }
    // TODO: The types/locking should be rationalised a bit.
    private final CopyOnWriteArrayList&lt;GetDataRequest&gt; getDataFutures;
    @GuardedBy(&quot;getAddrFutures&quot;) private final LinkedList&lt;SettableFuture&lt;AddressMessage&gt;&gt; getAddrFutures;
    @Nullable @GuardedBy(&quot;lock&quot;) private LinkedList&lt;SettableFuture&lt;UTXOsMessage&gt;&gt; getutxoFutures;

    // Outstanding pings against this peer and how long the last one took to complete.
<span class="fc" id="L155">    private final ReentrantLock lastPingTimesLock = new ReentrantLock();</span>
<span class="fc" id="L156">    @GuardedBy(&quot;lastPingTimesLock&quot;) private long[] lastPingTimes = null;</span>
    private final CopyOnWriteArrayList&lt;PendingPing&gt; pendingPings;
    private static final int PING_MOVING_AVERAGE_WINDOW = 20;

    private volatile VersionMessage vPeerVersionMessage;

    // A settable future which completes (with this) when the connection is open
<span class="fc" id="L163">    private final SettableFuture&lt;Peer&gt; connectionOpenFuture = SettableFuture.create();</span>
<span class="fc" id="L164">    private final SettableFuture&lt;Peer&gt; outgoingVersionHandshakeFuture = SettableFuture.create();</span>
<span class="fc" id="L165">    private final SettableFuture&lt;Peer&gt; incomingVersionHandshakeFuture = SettableFuture.create();</span>
<span class="fc" id="L166">    private final ListenableFuture&lt;Peer&gt; versionHandshakeFuture = Futures.transform(</span>
<span class="fc" id="L167">            Futures.allAsList(outgoingVersionHandshakeFuture, incomingVersionHandshakeFuture),</span>
<span class="fc" id="L168">            new Function&lt;List&lt;Peer&gt;, Peer&gt;() {</span>

                @Override
                @Nullable
                public Peer apply(@Nullable List&lt;Peer&gt; peers) {
<span class="nc" id="L173">                    checkNotNull(peers);</span>
<span class="nc bnc" id="L174" title="All 4 branches missed.">                    checkState(peers.size() == 2 &amp;&amp; peers.get(0) == peers.get(1));</span>
<span class="nc" id="L175">                    return peers.get(0);</span>
                }
            });

    /**
     * &lt;p&gt;Construct a peer that reads/writes from the given block chain.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this does &lt;b&gt;NOT&lt;/b&gt; make a connection to the given remoteAddress, it only creates a handler for a
     * connection. If you want to create a one-off connection, create a Peer and pass it to
     * {@link site.mtnsj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     * or
     * {@link site.mtnsj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.&lt;/p&gt;
     *
     * &lt;p&gt;The remoteAddress provided should match the remote address of the peer which is being connected to, and is
     * used to keep track of which peers relayed transactions and offer more descriptive logging.&lt;/p&gt;
     */
    public Peer(NetworkParameters params, VersionMessage ver, @Nullable AbstractBlockChain chain, PeerAddress remoteAddress) {
<span class="nc" id="L192">        this(params, ver, remoteAddress, chain);</span>
<span class="nc" id="L193">    }</span>

    /**
     * &lt;p&gt;Construct a peer that reads/writes from the given block chain. Transactions stored in a {@link site.mtnsj.core.TxConfidenceTable}
     * will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
     * the transaction is valid.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this does &lt;b&gt;NOT&lt;/b&gt; make a connection to the given remoteAddress, it only creates a handler for a
     * connection. If you want to create a one-off connection, create a Peer and pass it to
     * {@link site.mtnsj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     * or
     * {@link site.mtnsj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.&lt;/p&gt;
     *
     * &lt;p&gt;The remoteAddress provided should match the remote address of the peer which is being connected to, and is
     * used to keep track of which peers relayed transactions and offer more descriptive logging.&lt;/p&gt;
     */
    public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddress,
                @Nullable AbstractBlockChain chain) {
<span class="fc" id="L211">        this(params, ver, remoteAddress, chain, Integer.MAX_VALUE);</span>
<span class="fc" id="L212">    }</span>

    /**
     * &lt;p&gt;Construct a peer that reads/writes from the given block chain. Transactions stored in a {@link site.mtnsj.core.TxConfidenceTable}
     * will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
     * the transaction is valid.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this does &lt;b&gt;NOT&lt;/b&gt; make a connection to the given remoteAddress, it only creates a handler for a
     * connection. If you want to create a one-off connection, create a Peer and pass it to
     * {@link site.mtnsj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     * or
     * {@link site.mtnsj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.&lt;/p&gt;
     *
     * &lt;p&gt;The remoteAddress provided should match the remote address of the peer which is being connected to, and is
     * used to keep track of which peers relayed transactions and offer more descriptive logging.&lt;/p&gt;
     */
    public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddress,
                @Nullable AbstractBlockChain chain, int downloadTxDependencyDepth) {
<span class="fc" id="L230">        super(params, remoteAddress);</span>
<span class="fc" id="L231">        this.params = Preconditions.checkNotNull(params);</span>
<span class="fc" id="L232">        this.versionMessage = Preconditions.checkNotNull(ver);</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        this.vDownloadTxDependencyDepth = chain != null ? downloadTxDependencyDepth : 0;</span>
<span class="fc" id="L234">        this.blockChain = chain;  // Allowed to be null.</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        this.vDownloadData = chain != null;</span>
<span class="fc" id="L236">        this.getDataFutures = new CopyOnWriteArrayList&lt;GetDataRequest&gt;();</span>
<span class="fc" id="L237">        this.getAddrFutures = new LinkedList&lt;SettableFuture&lt;AddressMessage&gt;&gt;();</span>
<span class="fc" id="L238">        this.fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();</span>
<span class="fc" id="L239">        this.pendingPings = new CopyOnWriteArrayList&lt;PendingPing&gt;();</span>
<span class="fc" id="L240">        this.vMinProtocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.PONG);</span>
<span class="fc" id="L241">        this.wallets = new CopyOnWriteArrayList&lt;Wallet&gt;();</span>
<span class="fc" id="L242">        this.context = Context.get();</span>

<span class="fc" id="L244">        this.versionHandshakeFuture.addListener(new Runnable() {</span>
            @Override
            public void run() {
<span class="nc" id="L247">                versionHandshakeComplete();</span>
<span class="nc" id="L248">            }</span>
        }, Threading.SAME_THREAD);
<span class="fc" id="L250">    }</span>

    /**
     * &lt;p&gt;Construct a peer that reads/writes from the given chain. Automatically creates a VersionMessage for you from
     * the given software name/version strings, which should be something like &quot;MySimpleTool&quot;, &quot;1.0&quot; and which will tell
     * the remote node to relay transaction inv messages before it has received a filter.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this does &lt;b&gt;NOT&lt;/b&gt; make a connection to the given remoteAddress, it only creates a handler for a
     * connection. If you want to create a one-off connection, create a Peer and pass it to
     * {@link site.mtnsj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     * or
     * {@link site.mtnsj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.&lt;/p&gt;
     *
     * &lt;p&gt;The remoteAddress provided should match the remote address of the peer which is being connected to, and is
     * used to keep track of which peers relayed transactions and offer more descriptive logging.&lt;/p&gt;
     */
    public Peer(NetworkParameters params, AbstractBlockChain blockChain, PeerAddress peerAddress, String thisSoftwareName, String thisSoftwareVersion) {
<span class="nc" id="L267">        this(params, new VersionMessage(params, blockChain.getBestChainHeight()), blockChain, peerAddress);</span>
<span class="nc" id="L268">        this.versionMessage.appendToSubVer(thisSoftwareName, thisSoftwareVersion, null);</span>
<span class="nc" id="L269">    }</span>

    /** Deprecated: use the more specific event handler methods instead */
    @Deprecated @SuppressWarnings(&quot;deprecation&quot;)
    public void addEventListener(AbstractPeerEventListener listener) {
<span class="nc" id="L274">        addBlocksDownloadedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L275">        addChainDownloadStartedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L276">        addConnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L277">        addDisconnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L278">        addGetDataEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L279">        addOnTransactionBroadcastListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L280">        addPreMessageReceivedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L281">    }</span>

    /** Deprecated: use the more specific event handler methods instead */
    @Deprecated
    public void addEventListener(AbstractPeerEventListener listener, Executor executor) {
<span class="nc" id="L286">        addBlocksDownloadedEventListener(executor, listener);</span>
<span class="nc" id="L287">        addChainDownloadStartedEventListener(executor, listener);</span>
<span class="nc" id="L288">        addConnectedEventListener(executor, listener);</span>
<span class="nc" id="L289">        addDisconnectedEventListener(executor, listener);</span>
<span class="nc" id="L290">        addGetDataEventListener(executor, listener);</span>
<span class="nc" id="L291">        addOnTransactionBroadcastListener(executor, listener);</span>
<span class="nc" id="L292">        addPreMessageReceivedEventListener(executor, listener);</span>
<span class="nc" id="L293">    }</span>

    /** Deprecated: use the more specific event handler methods instead */
    @Deprecated
    public void removeEventListener(AbstractPeerEventListener listener) {
<span class="nc" id="L298">        removeBlocksDownloadedEventListener(listener);</span>
<span class="nc" id="L299">        removeChainDownloadStartedEventListener(listener);</span>
<span class="nc" id="L300">        removeConnectedEventListener(listener);</span>
<span class="nc" id="L301">        removeDisconnectedEventListener(listener);</span>
<span class="nc" id="L302">        removeGetDataEventListener(listener);</span>
<span class="nc" id="L303">        removeOnTransactionBroadcastListener(listener);</span>
<span class="nc" id="L304">        removePreMessageReceivedEventListener(listener);</span>
<span class="nc" id="L305">    }</span>

    /** Registers a listener that is invoked when new blocks are downloaded. */
    public void addBlocksDownloadedEventListener(BlocksDownloadedEventListener listener) {
<span class="fc" id="L309">        addBlocksDownloadedEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L310">    }</span>

    /** Registers a listener that is invoked when new blocks are downloaded. */
    public void addBlocksDownloadedEventListener(Executor executor, BlocksDownloadedEventListener listener) {
<span class="fc" id="L314">        blocksDownloadedEventListeners.add(new ListenerRegistration(listener, executor));</span>
<span class="fc" id="L315">    }</span>

    /** Registers a listener that is invoked when a blockchain downloaded starts. */
    public void addChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener) {
<span class="nc" id="L319">        addChainDownloadStartedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L320">    }</span>

    /** Registers a listener that is invoked when a blockchain downloaded starts. */
    public void addChainDownloadStartedEventListener(Executor executor, ChainDownloadStartedEventListener listener) {
<span class="nc" id="L324">        chainDownloadStartedEventListeners.add(new ListenerRegistration(listener, executor));</span>
<span class="nc" id="L325">    }</span>

    /** Registers a listener that is invoked when a peer is connected. */
    public void addConnectedEventListener(PeerConnectedEventListener listener) {
<span class="fc" id="L329">        addConnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L330">    }</span>

    /** Registers a listener that is invoked when a peer is connected. */
    public void addConnectedEventListener(Executor executor, PeerConnectedEventListener listener) {
<span class="fc" id="L334">        connectedEventListeners.add(new ListenerRegistration(listener, executor));</span>
<span class="fc" id="L335">    }</span>

    /** Registers a listener that is invoked when a peer is disconnected. */
    public void addDisconnectedEventListener(PeerDisconnectedEventListener listener) {
<span class="nc" id="L339">        addDisconnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L340">    }</span>

    /** Registers a listener that is invoked when a peer is disconnected. */
    public void addDisconnectedEventListener(Executor executor, PeerDisconnectedEventListener listener) {
<span class="fc" id="L344">        disconnectedEventListeners.add(new ListenerRegistration(listener, executor));</span>
<span class="fc" id="L345">    }</span>

    /** Registers a listener that is called when messages are received. */
    public void addGetDataEventListener(GetDataEventListener listener) {
<span class="nc" id="L349">        addGetDataEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L350">    }</span>

    /** Registers a listener that is called when messages are received. */
    public void addGetDataEventListener(Executor executor, GetDataEventListener listener) {
<span class="nc" id="L354">        getDataEventListeners.add(new ListenerRegistration&lt;GetDataEventListener&gt;(listener, executor));</span>
<span class="nc" id="L355">    }</span>

    /** Registers a listener that is called when a transaction is broadcast across the network */
    public void addOnTransactionBroadcastListener(OnTransactionBroadcastListener listener) {
<span class="nc" id="L359">        addOnTransactionBroadcastListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L360">    }</span>

    /** Registers a listener that is called when a transaction is broadcast across the network */
    public void addOnTransactionBroadcastListener(Executor executor, OnTransactionBroadcastListener listener) {
<span class="nc" id="L364">        onTransactionEventListeners.add(new ListenerRegistration&lt;OnTransactionBroadcastListener&gt;(listener, executor));</span>
<span class="nc" id="L365">    }</span>

    /** Registers a listener that is called immediately before a message is received */
    public void addPreMessageReceivedEventListener(PreMessageReceivedEventListener listener) {
<span class="nc" id="L369">        addPreMessageReceivedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L370">    }</span>

    /** Registers a listener that is called immediately before a message is received */
    public void addPreMessageReceivedEventListener(Executor executor, PreMessageReceivedEventListener listener) {
<span class="nc" id="L374">        preMessageReceivedEventListeners.add(new ListenerRegistration&lt;PreMessageReceivedEventListener&gt;(listener, executor));</span>
<span class="nc" id="L375">    }</span>

    public boolean removeBlocksDownloadedEventListener(BlocksDownloadedEventListener listener) {
<span class="fc" id="L378">        return ListenerRegistration.removeFromList(listener, blocksDownloadedEventListeners);</span>
    }

    public boolean removeChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener) {
<span class="nc" id="L382">        return ListenerRegistration.removeFromList(listener, chainDownloadStartedEventListeners);</span>
    }

    public boolean removeConnectedEventListener(PeerConnectedEventListener listener) {
<span class="nc" id="L386">        return ListenerRegistration.removeFromList(listener, connectedEventListeners);</span>
    }

    public boolean removeDisconnectedEventListener(PeerDisconnectedEventListener listener) {
<span class="nc" id="L390">        return ListenerRegistration.removeFromList(listener, disconnectedEventListeners);</span>
    }

    public boolean removeGetDataEventListener(GetDataEventListener listener) {
<span class="fc" id="L394">        return ListenerRegistration.removeFromList(listener, getDataEventListeners);</span>
    }

    public boolean removeOnTransactionBroadcastListener(OnTransactionBroadcastListener listener) {
<span class="nc" id="L398">        return ListenerRegistration.removeFromList(listener, onTransactionEventListeners);</span>
    }

    public boolean removePreMessageReceivedEventListener(PreMessageReceivedEventListener listener) {
<span class="nc" id="L402">        return ListenerRegistration.removeFromList(listener, preMessageReceivedEventListeners);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L407">        PeerAddress addr = getAddress();</span>
        // if null, it's a user-provided NetworkConnection object
<span class="nc bnc" id="L409" title="All 2 branches missed.">        return addr == null ? &quot;Peer()&quot; : addr.toString();</span>
    }

    @Override
    protected void timeoutOccurred() {
<span class="fc" id="L414">        super.timeoutOccurred();</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">        if (!connectionOpenFuture.isDone()) {</span>
<span class="fc" id="L416">            connectionClosed();  // Invoke the event handlers to tell listeners e.g. PeerGroup that we never managed to connect.</span>
        }
<span class="fc" id="L418">    }</span>

    @Override
    public void connectionClosed() {
<span class="fc bfc" id="L422" title="All 2 branches covered.">        for (final ListenerRegistration&lt;PeerDisconnectedEventListener&gt; registration : disconnectedEventListeners) {</span>
<span class="fc" id="L423">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L426">                    registration.listener.onPeerDisconnected(Peer.this, 0);</span>
<span class="fc" id="L427">                }</span>
            });
<span class="fc" id="L429">        }</span>
<span class="fc" id="L430">    }</span>

    @Override
    public void connectionOpened() {
        // Announce ourselves. This has to come first to connect to clients beyond v0.3.20.2 which wait to hear
        // from us until they send their version message back.
<span class="nc" id="L436">        PeerAddress address = getAddress();</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">        log.info(&quot;Announcing to {} as: {}&quot;, address == null ? &quot;Peer&quot; : address.toSocketAddress(), versionMessage.subVer);</span>
<span class="nc" id="L438">        sendMessage(versionMessage);</span>
<span class="nc" id="L439">        connectionOpenFuture.set(this);</span>
        // When connecting, the remote peer sends us a version message with various bits of
        // useful data in it. We need to know the peer protocol version before we can talk to it.
<span class="nc" id="L442">    }</span>

    /**
     * Provides a ListenableFuture that can be used to wait for the socket to connect.  A socket connection does not
     * mean that protocol handshake has occurred.
     */
    public ListenableFuture&lt;Peer&gt; getConnectionOpenFuture() {
<span class="nc" id="L449">        return connectionOpenFuture;</span>
    }

    public ListenableFuture&lt;Peer&gt; getVersionHandshakeFuture() {
<span class="nc" id="L453">        return versionHandshakeFuture;</span>
    }

<span class="fc" id="L456">    static long startTime = 0;</span>
<span class="fc" id="L457">    static double dataReceived = 0f;</span>
<span class="fc" id="L458">    static long count = 1;</span>
    @Override
    protected void processMessage(Message m) throws Exception {
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if(startTime == 0)</span>
<span class="nc" id="L462">            startTime = Utils.currentTimeMillis();</span>
        else
        {
<span class="nc" id="L465">            long current = Utils.currentTimeMillis();</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            if (m!=null) {</span>
<span class="nc" id="L467">                dataReceived += m.getMessageSize();</span>

<span class="nc bnc" id="L469" title="All 2 branches missed.">                if (count % 50 == 0) {</span>
                    //log.info(&quot;[bandwidth] &quot; + (dataReceived / 1024 / 1024) + &quot; MiB in &quot; + (current - startTime) / 1000 + &quot; s:&quot; + (dataReceived / 1024) / (current - startTime) * 1000 + &quot; KB/s , msgType: &quot; + m.toString());
                }
<span class="nc" id="L472">                count++;</span>
            }
        }

        // Allow event listeners to filter the message stream. Listeners are allowed to drop messages by
        // returning null.
<span class="nc bnc" id="L478" title="All 2 branches missed.">        for (ListenerRegistration&lt;PreMessageReceivedEventListener&gt; registration : preMessageReceivedEventListeners) {</span>
            // Skip any listeners that are supposed to run in another thread as we don't want to block waiting
            // for it, which might cause circular deadlock.
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (registration.executor == Threading.SAME_THREAD) {</span>
<span class="nc" id="L482">                m = registration.listener.onPreMessageReceived(this, m);</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">                if (m == null) break;</span>
            }
<span class="nc" id="L485">        }</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">        if (m == null) return;</span>

        //System.out.println(&quot;process message: &quot;+m.getClass());

        // If we are in the middle of receiving transactions as part of a filtered block push from the remote node,
        // and we receive something that's not a transaction, then we're done.
<span class="nc bnc" id="L492" title="All 4 branches missed.">        if (currentFilteredBlock != null &amp;&amp; !(m instanceof Transaction)) {</span>
<span class="nc" id="L493">            endFilteredBlock(currentFilteredBlock);</span>
<span class="nc" id="L494">            currentFilteredBlock = null;</span>
        }

        // No further communication is possible until version handshake is complete.
<span class="nc bnc" id="L498" title="All 6 branches missed.">        if (!(m instanceof VersionMessage || m instanceof VersionAck || m instanceof GetSporksMessage </span>
<span class="nc bnc" id="L499" title="All 4 branches missed.">                || (versionHandshakeFuture.isDone() &amp;&amp; !versionHandshakeFuture.isCancelled()))) {</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            String reason = &quot;  &quot; + ((m instanceof RejectMessage) ? ((RejectMessage) m).getReasonString() : &quot;&quot;);</span>
<span class="nc" id="L501">            throw new ProtocolException(</span>
<span class="nc" id="L502">                    &quot;Received &quot; + m.getClass().getSimpleName() + &quot; before version handshake is complete.&quot;+ reason);</span>
        }

<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (m instanceof Ping) {</span>
<span class="nc" id="L506">            processPing((Ping) m);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        } else if (m instanceof Pong) {</span>
<span class="nc" id="L508">            processPong((Pong) m);</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">        } else if (m instanceof NotFoundMessage) {</span>
            // This is sent to us when we did a getdata on some transactions that aren't in the peers memory pool.
            // Because NotFoundMessage is a subclass of InventoryMessage, the test for it must come before the next.
<span class="nc" id="L512">            processNotFoundMessage((NotFoundMessage) m);</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">        } else if (m instanceof InventoryMessage) {</span>
<span class="nc" id="L514">            processInv((InventoryMessage) m);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">        } else if (m instanceof Block) {</span>
<span class="nc" id="L516">            processBlock((Block) m);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">        } else if (m instanceof FilteredBlock) {</span>
<span class="nc" id="L518">            startFilteredBlock((FilteredBlock) m);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">        } else if (m instanceof TransactionLockRequest) {</span>
            //processTransactionLockRequest((TransactionLockRequest) m);
<span class="nc bnc" id="L521" title="All 2 branches missed.">            if (context.instantSend!=null) {</span>
<span class="nc" id="L522">                context.instantSend.processTxLockRequest((TransactionLockRequest) m);</span>
            }
<span class="nc" id="L524">            processTransaction((TransactionLockRequest)m);</span>

<span class="nc bnc" id="L526" title="All 2 branches missed.">        } else if (m instanceof Transaction) {</span>
            try {
<span class="nc" id="L528">                processTransaction((Transaction) m);</span>
<span class="nc" id="L529">            }catch (VerificationException.DuplicatedOutPoint e){</span>
<span class="nc" id="L530">                log.error(&quot;Duplicated output, could be a zcspend output..&quot;,e);</span>
<span class="nc" id="L531">            }</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">        } else if (m instanceof GetDataMessage) {</span>
<span class="nc" id="L533">            processGetData((GetDataMessage) m);</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">        } else if (m instanceof AddressMessage) {</span>
            // We don't care about addresses of the network right now. But in future,
            // we should save them in the wallet so we don't put too much load on the seed nodes and can
            // properly explore the network.
<span class="nc" id="L538">            processAddressMessage((AddressMessage) m);</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">        } else if (m instanceof HeadersMessage) {</span>
<span class="nc" id="L540">            processHeaders((HeadersMessage) m);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">        } else if (m instanceof AlertMessage) {</span>
<span class="nc" id="L542">            processAlert((AlertMessage) m);</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">        } else if (m instanceof VersionMessage) {</span>
<span class="nc" id="L544">            processVersionMessage((VersionMessage) m);</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">        } else if (m instanceof VersionAck) {</span>
<span class="nc" id="L546">            processVersionAck((VersionAck) m);</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">        } else if (m instanceof UTXOsMessage) {</span>
<span class="nc" id="L548">            processUTXOMessage((UTXOsMessage) m);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">        } else if (m instanceof RejectMessage) {</span>
<span class="nc" id="L550">            log.error(&quot;{} {}: Received {}&quot;, this, getPeerVersionMessage().subVer, m);</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">        } else if(m instanceof DarkSendQueue) {</span>
            //do nothing
<span class="nc bnc" id="L553" title="All 2 branches missed.">        } else if(m instanceof MasternodeBroadcast) {</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">            if(!context.isLiteMode()) {</span>
                //todo: process master nodes messages
                //context.masternodeManager.processMasternodeBroadcast((MasternodeBroadcast) m);
            }
        }
<span class="nc bnc" id="L559" title="All 2 branches missed.">        else if(m instanceof MasternodePing) {</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">            if(!context.isLiteMode()) {</span>
                //todo: process master nodes messages
                //context.masternodeManager.processMasternodePing(this, (MasternodePing) m);
            }
        }
<span class="nc bnc" id="L565" title="All 2 branches missed.">        else if(m instanceof SporkMessage)</span>
        {
            // todo furszy: commented for now.
<span class="nc bnc" id="L568" title="All 2 branches missed.">            if (context.sporkManager!=null)</span>
<span class="nc" id="L569">                context.sporkManager.processSpork(this, (SporkMessage)m);</span>
        }
<span class="nc bnc" id="L571" title="All 2 branches missed.">        else if(m instanceof TransactionLockVote) {</span>
            // todo furszy: commented for now
<span class="nc bnc" id="L573" title="All 2 branches missed.">            if (context.instantSend!=null)</span>
<span class="nc" id="L574">                context.instantSend.processTransactionLockVoteMessage(this, (TransactionLockVote)m);</span>
        }
<span class="nc bnc" id="L576" title="All 2 branches missed.">        else if(m instanceof SyncStatusCount) {</span>
            // todo furszy: check mtns masternodes
<span class="nc bnc" id="L578" title="All 2 branches missed.">            if (context.masternodeSync!=null) {</span>
                //todo: process master nodes messages
                //context.masternodeSync.processSyncStatusCount(this, (SyncStatusCount) m);
            }
        }
        else
        {
<span class="nc" id="L585">            log.warn(&quot;{}: Received unhandled message: {}&quot;, this, m);</span>
        }
<span class="nc" id="L587">    }</span>

    protected void processUTXOMessage(UTXOsMessage m) {
<span class="nc" id="L590">        SettableFuture&lt;UTXOsMessage&gt; future = null;</span>
<span class="nc" id="L591">        lock.lock();</span>
        try {
<span class="nc bnc" id="L593" title="All 2 branches missed.">            if (getutxoFutures != null)</span>
<span class="nc" id="L594">                future = getutxoFutures.pollFirst();</span>
        } finally {
<span class="nc" id="L596">            lock.unlock();</span>
<span class="nc" id="L597">        }</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">        if (future != null)</span>
<span class="nc" id="L599">            future.set(m);</span>
<span class="nc" id="L600">    }</span>

    private void processAddressMessage(AddressMessage m) {
        SettableFuture&lt;AddressMessage&gt; future;
<span class="nc" id="L604">        synchronized (getAddrFutures) {</span>
<span class="nc" id="L605">            future = getAddrFutures.poll();</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">            if (future == null)  // Not an addr message we are waiting for.</span>
<span class="nc" id="L607">                return;</span>
<span class="nc" id="L608">        }</span>
<span class="nc" id="L609">        future.set(m);</span>
<span class="nc" id="L610">    }</span>

    private void processVersionMessage(VersionMessage m) throws ProtocolException {
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (vPeerVersionMessage != null)</span>
<span class="nc" id="L614">            throw new ProtocolException(&quot;Got two version messages from peer&quot;);</span>
<span class="nc" id="L615">        vPeerVersionMessage = m;</span>
        // Switch to the new protocol version.
<span class="nc" id="L617">        long peerTime = vPeerVersionMessage.time * 1000;</span>
<span class="nc" id="L618">        log.info(&quot;{}: Got version={}, subVer='{}', services=0x{}, time={}, blocks={}&quot;,</span>
                this,
<span class="nc" id="L620">                vPeerVersionMessage.clientVersion,</span>
                vPeerVersionMessage.subVer,
<span class="nc" id="L622">                vPeerVersionMessage.localServices,</span>
<span class="nc" id="L623">                String.format(Locale.US, &quot;%tF %tT&quot;, peerTime, peerTime),</span>
<span class="nc" id="L624">                vPeerVersionMessage.bestHeight);</span>
        // mtnsj is a client mode implementation. That means there's not much point in us talking to other client
        // mode nodes because we can't download the data from them we need to find/verify transactions. Some bogus
        // implementations claim to have a block chain in their services field but then report a height of zero, filter
        // them out here.
<span class="nc bnc" id="L629" title="All 2 branches missed.">        if (!vPeerVersionMessage.hasBlockChain() ||</span>
<span class="nc bnc" id="L630" title="All 4 branches missed.">                (!params.allowEmptyPeerChain() &amp;&amp; vPeerVersionMessage.bestHeight == 0)) {</span>
            // Shut down the channel gracefully.
<span class="nc" id="L632">            log.info(&quot;{}: Peer does not have a copy of the block chain.&quot;, this);</span>
<span class="nc" id="L633">            close();</span>
<span class="nc" id="L634">            return;</span>
        }
<span class="nc bnc" id="L636" title="All 2 branches missed.">        if (vPeerVersionMessage.bestHeight &lt; 0)</span>
            // In this case, it's a protocol violation.
<span class="nc" id="L638">            throw new ProtocolException(&quot;Peer reports invalid best height: &quot; + vPeerVersionMessage.bestHeight);</span>
        // Now it's our turn ...
        // Send an ACK message stating we accept the peers protocol version.
<span class="nc" id="L641">        sendMessage(new VersionAck());</span>
<span class="nc" id="L642">        log.debug(&quot;{}: Incoming version handshake complete.&quot;, this);</span>
<span class="nc" id="L643">        incomingVersionHandshakeFuture.set(this);</span>
<span class="nc" id="L644">    }</span>

    private void processVersionAck(VersionAck m) throws ProtocolException {
<span class="nc bnc" id="L647" title="All 2 branches missed.">        if (vPeerVersionMessage == null) {</span>
<span class="nc" id="L648">            throw new ProtocolException(&quot;got a version ack before version&quot;);</span>
        }
<span class="nc bnc" id="L650" title="All 2 branches missed.">        if (outgoingVersionHandshakeFuture.isDone()) {</span>
<span class="nc" id="L651">            throw new ProtocolException(&quot;got more than one version ack&quot;);</span>
        }
<span class="nc" id="L653">        log.debug(&quot;{}: Outgoing version handshake complete.&quot;, this);</span>
<span class="nc" id="L654">        outgoingVersionHandshakeFuture.set(this);</span>
<span class="nc" id="L655">    }</span>

    private void versionHandshakeComplete() {
<span class="nc" id="L658">        log.debug(&quot;{}: Handshake complete.&quot;, this);</span>
<span class="nc" id="L659">        setTimeoutEnabled(false);</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">        for (final ListenerRegistration&lt;PeerConnectedEventListener&gt; registration : connectedEventListeners) {</span>
<span class="nc" id="L661">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L664">                    registration.listener.onPeerConnected(Peer.this, 1);</span>
<span class="nc" id="L665">                }</span>
            });
<span class="nc" id="L667">        }</span>
        // We check min version after onPeerConnected as channel.close() will
        // call onPeerDisconnected, and we should probably call onPeerConnected first.
<span class="nc" id="L670">        final int version = vMinProtocolVersion;</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">        if (vPeerVersionMessage.clientVersion &lt; version) {</span>
<span class="nc" id="L672">            log.warn(&quot;Connected to a peer speaking protocol version {} but need {}, closing&quot;,</span>
<span class="nc" id="L673">                    vPeerVersionMessage.clientVersion, version);</span>
<span class="nc" id="L674">            close();</span>
        }
<span class="nc" id="L676">    }</span>

    protected void startFilteredBlock(FilteredBlock m) {
        // Filtered blocks come before the data that they refer to, so stash it here and then fill it out as
        // messages stream in. We'll call endFilteredBlock when a non-tx message arrives (eg, another
        // FilteredBlock) or when a tx that isn't needed by that block is found. A ping message is sent after
        // a getblocks, to force the non-tx message path.
<span class="nc" id="L683">        currentFilteredBlock = m;</span>
        // Potentially refresh the server side filter. Because the remote node adds hits back into the filter
        // to save round-tripping back through us, the filter degrades over time as false positives get added,
        // triggering yet more false positives. We refresh it every so often to get the FP rate back down.
<span class="nc" id="L687">        filteredBlocksReceived++;</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (filteredBlocksReceived % RESEND_BLOOM_FILTER_BLOCK_COUNT == RESEND_BLOOM_FILTER_BLOCK_COUNT - 1) {</span>
<span class="nc" id="L689">            sendMessage(vBloomFilter);</span>
        }
<span class="nc" id="L691">    }</span>

    protected void processNotFoundMessage(NotFoundMessage m) {
        // This is received when we previously did a getdata but the peer couldn't find what we requested in it's
        // memory pool. Typically, because we are downloading dependencies of a relevant transaction and reached
        // the bottom of the dependency tree (where the unconfirmed transactions connect to transactions that are
        // in the chain).
        //
        // We go through and cancel the pending getdata futures for the items we were told weren't found.
<span class="nc bnc" id="L700" title="All 2 branches missed.">        for (GetDataRequest req : getDataFutures) {</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">            for (InventoryItem item : m.getItems()) {</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">                if (item.hash.equals(req.hash)) {</span>
<span class="nc" id="L703">                    log.info(&quot;{}: Bottomed out dep tree at {}&quot;, this, req.hash);</span>
<span class="nc" id="L704">                    req.future.cancel(true);</span>
<span class="nc" id="L705">                    getDataFutures.remove(req);</span>
<span class="nc" id="L706">                    break;</span>
                }
<span class="nc" id="L708">            }</span>
<span class="nc" id="L709">        }</span>
<span class="nc" id="L710">    }</span>

    protected void processAlert(AlertMessage m) {
        try {
<span class="nc bnc" id="L714" title="All 2 branches missed.">            if (m.isSignatureValid()) {</span>
<span class="nc" id="L715">                log.info(&quot;Received alert from peer {}: {}&quot;, this, m.getStatusBar());</span>
            } else {
<span class="nc" id="L717">                log.warn(&quot;Received alert with invalid signature from peer {}: {}&quot;, this, m.getStatusBar());</span>
            }
<span class="nc" id="L719">        } catch (Throwable t) {</span>
            // Signature checking can FAIL on Android platforms before Gingerbread apparently due to bugs in their
            // BigInteger implementations! See https://github.com/bitcoinj/bitcoinj/issues/526 for discussion. As
            // alerts are just optional and not that useful, we just swallow the error here.
<span class="nc" id="L723">            log.error(&quot;Failed to check signature: bug in platform libraries?&quot;, t);</span>
<span class="nc" id="L724">        }</span>
<span class="nc" id="L725">    }</span>

    protected void processHeaders(HeadersMessage m) throws ProtocolException {
        // Runs in network loop thread for this peer.
        //
        // This method can run if a peer just randomly sends us a &quot;headers&quot; message (should never happen), or more
        // likely when we've requested them as part of chain download using fast catchup. We need to add each block to
        // the chain if it pre-dates the fast catchup time. If we go past it, we can stop processing the headers and
        // request the full blocks from that point on instead.
        boolean downloadBlockBodies;
        long fastCatchupTimeSecs;

<span class="nc" id="L737">        lock.lock();</span>
        try {
<span class="nc bnc" id="L739" title="All 2 branches missed.">            if (blockChain == null) {</span>
                // Can happen if we are receiving unrequested data, or due to programmer error.
<span class="nc" id="L741">                log.warn(&quot;Received headers when Peer is not configured with a chain.&quot;);</span>
<span class="nc" id="L742">                return;</span>
            }
<span class="nc" id="L744">            fastCatchupTimeSecs = this.fastCatchupTimeSecs;</span>
<span class="nc" id="L745">            downloadBlockBodies = this.downloadBlockBodies;</span>
        } finally {
<span class="nc" id="L747">            lock.unlock();</span>
<span class="nc" id="L748">        }</span>

        try {
<span class="nc bnc" id="L751" title="All 2 branches missed.">            checkState(!downloadBlockBodies, toString());</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">            for (int i = 0; i &lt; m.getBlockHeaders().size(); i++) {</span>
<span class="nc" id="L753">                Block header = m.getBlockHeaders().get(i);</span>
                // Process headers until we pass the fast catchup time, or are about to catch up with the head
                // of the chain - always process the last block as a full/filtered block to kick us out of the
                // fast catchup mode (in which we ignore new blocks).
<span class="nc bnc" id="L757" title="All 2 branches missed.">                boolean passedTime = header.getTimeSeconds() &gt;= fastCatchupTimeSecs;</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">                boolean reachedTop = blockChain.getBestChainHeight() &gt;= vPeerVersionMessage.bestHeight;</span>
<span class="nc bnc" id="L759" title="All 4 branches missed.">                if (!passedTime &amp;&amp; !reachedTop) {</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">                    if (!vDownloadData) {</span>
                        // Not download peer anymore, some other peer probably became better.
<span class="nc" id="L762">                        log.info(&quot;Lost download peer status, throwing away downloaded headers.&quot;);</span>
<span class="nc" id="L763">                        return;</span>
                    }
<span class="nc bnc" id="L765" title="All 2 branches missed.">                    if (blockChain.add(header)) {</span>
                        // The block was successfully linked into the chain. Notify the user of our progress.
<span class="nc" id="L767">                        invokeOnBlocksDownloaded(header, null);</span>
                    } else {
                        // This block is unconnected - we don't know how to get from it back to the genesis block yet.
                        // That must mean that the peer is buggy or malicious because we specifically requested for
                        // headers that are part of the best chain.
<span class="nc" id="L772">                        throw new ProtocolException(&quot;Got unconnected header from peer: &quot; + header.getHashAsString());</span>
                    }
                } else {
<span class="nc" id="L775">                    lock.lock();</span>
                    try {
<span class="nc" id="L777">                        log.info(&quot;Passed the fast catchup time, discarding {} headers and requesting full blocks&quot;,</span>
<span class="nc" id="L778">                                m.getBlockHeaders().size() - i);</span>
<span class="nc" id="L779">                        this.downloadBlockBodies = true;</span>
                        // Prevent this request being seen as a duplicate.
<span class="nc" id="L781">                        this.lastGetBlocksBegin = Sha256Hash.ZERO_HASH;</span>
<span class="nc" id="L782">                        blockChainDownloadLocked(Sha256Hash.ZERO_HASH);</span>
                    } finally {
<span class="nc" id="L784">                        lock.unlock();</span>
<span class="nc" id="L785">                    }</span>
<span class="nc" id="L786">                    return;</span>
                }
            }
            // We added all headers in the message to the chain. Request some more if we got up to the limit, otherwise
            // we are at the end of the chain.
<span class="nc bnc" id="L791" title="All 2 branches missed.">            if (m.getBlockHeaders().size() &gt;= HeadersMessage.MAX_HEADERS) {</span>
<span class="nc" id="L792">                lock.lock();</span>
                try {
<span class="nc" id="L794">                    blockChainDownloadLocked(Sha256Hash.ZERO_HASH);</span>
                } finally {
<span class="nc" id="L796">                    lock.unlock();</span>
<span class="nc" id="L797">                }</span>
            }
<span class="nc" id="L799">        } catch (VerificationException e) {</span>
<span class="nc" id="L800">            log.warn(&quot;Block header verification failed&quot;, e);</span>
<span class="nc" id="L801">        } catch (PrunedException e) {</span>
            // Unreachable when in SPV mode.
<span class="nc" id="L803">            throw new RuntimeException(e);</span>
<span class="nc" id="L804">        }</span>
<span class="nc" id="L805">    }</span>

    protected void processGetData(GetDataMessage getdata) {
<span class="nc" id="L808">        log.info(&quot;{}: Received getdata message: {}&quot;, getAddress(), getdata.toString());</span>
<span class="nc" id="L809">        ArrayList&lt;Message&gt; items = new ArrayList&lt;Message&gt;();</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">        for (ListenerRegistration&lt;GetDataEventListener&gt; registration : getDataEventListeners) {</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">            if (registration.executor != Threading.SAME_THREAD) continue;</span>
<span class="nc" id="L812">            List&lt;Message&gt; listenerItems = registration.listener.getData(this, getdata);</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">            if (listenerItems == null) continue;</span>
<span class="nc" id="L814">            items.addAll(listenerItems);</span>
<span class="nc" id="L815">        }</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">        if (items.isEmpty()) {</span>
<span class="nc" id="L817">            return;</span>
        }
<span class="nc" id="L819">        log.info(&quot;{}: Sending {} items gathered from listeners to peer&quot;, getAddress(), items.size());</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">        for (Message item : items) {</span>
<span class="nc" id="L821">            sendMessage(item);</span>
<span class="nc" id="L822">        }</span>
<span class="nc" id="L823">    }</span>

    protected void processTransaction(final Transaction tx) throws VerificationException {
        // Check a few basic syntax issues to ensure the received TX isn't nonsense.
        try {
<span class="nc" id="L828">            tx.verify();</span>
<span class="nc" id="L829">        }catch (VerificationException.CoinbaseScriptSizeOutOfRange e){</span>
<span class="nc" id="L830">            log.error(&quot;CoinbaseScriptSizeOutOfRange, txId &quot;+tx.getHashAsString(),e.getMessage());</span>
<span class="nc" id="L831">            return;</span>
<span class="nc" id="L832">        }</span>
<span class="nc" id="L833">        lock.lock();</span>
        try {
<span class="nc" id="L835">            log.debug(&quot;{}: Received tx {}&quot;, getAddress(), tx.getHashAsString());</span>
            // Label the transaction as coming in from the P2P network (as opposed to being created by us, direct import,
            // etc). This helps the wallet decide how to risk analyze it later.
            //
            // Additionally, by invoking tx.getConfidence(), this tx now pins the confidence data into the heap, meaning
            // we can stop holding a reference to the confidence object ourselves. It's up to event listeners on the
            // Peer to stash the tx object somewhere if they want to keep receiving updates about network propagation
            // and so on.
<span class="nc" id="L843">            TransactionConfidence confidence = tx.getConfidence();</span>
<span class="nc" id="L844">            confidence.setSource(TransactionConfidence.Source.NETWORK);</span>

            //MTNS Specific
            // todo furszy: commented dash instantSend for now.
<span class="nc bnc" id="L848" title="All 2 branches missed.">            if (context.instantSend!=null)</span>
<span class="nc" id="L849">                context.instantSend.syncTransaction(tx, null);</span>

<span class="nc" id="L851">            pendingTxDownloads.remove(confidence);</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">            if (maybeHandleRequestedData(tx)) {</span>
<span class="nc" id="L853">                return;</span>
            }
<span class="nc bnc" id="L855" title="All 2 branches missed.">            if (currentFilteredBlock != null) {</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">                if (!currentFilteredBlock.provideTransaction(tx)) {</span>
                    // Got a tx that didn't fit into the filtered block, so we must have received everything.
<span class="nc" id="L858">                    endFilteredBlock(currentFilteredBlock);</span>
<span class="nc" id="L859">                    currentFilteredBlock = null;</span>
                }
                // Don't tell wallets or listeners about this tx as they'll learn about it when the filtered block is
                // fully downloaded instead.
<span class="nc" id="L863">                return;</span>
            }
            // It's a broadcast transaction. Tell all wallets about this tx so they can check if it's relevant or not.
<span class="nc bnc" id="L866" title="All 2 branches missed.">            for (final Wallet wallet : wallets) {</span>
                try {
<span class="nc bnc" id="L868" title="All 2 branches missed.">                    if (wallet.isPendingTransactionRelevant(tx)) {</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">                        if (vDownloadTxDependencyDepth &gt; 0) {</span>
                            // This transaction seems interesting to us, so let's download its dependencies. This has
                            // several purposes: we can check that the sender isn't attacking us by engaging in protocol
                            // abuse games, like depending on a time-locked transaction that will never confirm, or
                            // building huge chains of unconfirmed transactions (again - so they don't confirm and the
                            // money can be taken back with a Finney attack). Knowing the dependencies also lets us
                            // store them in a serialized wallet so we always have enough data to re-announce to the
                            // network and get the payment into the chain, in case the sender goes away and the network
                            // starts to forget.
                            //
                            // TODO: Not all the above things are implemented.
                            //
                            // Note that downloading of dependencies can end up walking around 15 minutes back even
                            // through transactions that have confirmed, as getdata on the remote peer also checks
                            // relay memory not only the mempool. Unfortunately we have no way to know that here. In
                            // practice it should not matter much.
<span class="nc" id="L885">                            Futures.addCallback(downloadDependencies(tx), new FutureCallback&lt;List&lt;Transaction&gt;&gt;() {</span>
                                @Override
                                public void onSuccess(List&lt;Transaction&gt; dependencies) {
                                    try {
<span class="nc" id="L889">                                        log.info(&quot;{}: Dependency download complete!&quot;, getAddress());</span>
<span class="nc" id="L890">                                        wallet.receivePending(tx, dependencies);</span>

<span class="nc bnc" id="L892" title="All 2 branches missed.">                                        if(tx instanceof TransactionLockRequest)</span>
                                        {
<span class="nc" id="L894">                                            context.instantSend.acceptLockRequest((TransactionLockRequest)tx);</span>
                                        }
<span class="nc" id="L896">                                    } catch (VerificationException e) {</span>
<span class="nc" id="L897">                                        log.error(&quot;{}: Wallet failed to process pending transaction {}&quot;, getAddress(), tx.getHash());</span>
<span class="nc" id="L898">                                        log.error(&quot;Error was: &quot;, e);</span>
                                        // Not much more we can do at this point.
<span class="nc" id="L900">                                    }</span>
<span class="nc" id="L901">                                }</span>

                                @Override
                                public void onFailure(Throwable throwable) {
<span class="nc" id="L905">                                    log.error(&quot;Could not download dependencies of tx {}&quot;, tx.getHashAsString());</span>
<span class="nc" id="L906">                                    log.error(&quot;Error was: &quot;, throwable);</span>
                                    // Not much more we can do at this point.
<span class="nc" id="L908">                                }</span>
                            });
                        } else {
<span class="nc" id="L911">                            wallet.receivePending(tx, null);</span>

<span class="nc bnc" id="L913" title="All 2 branches missed.">                            if(tx instanceof TransactionLockRequest) {</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">                                if (context.instantSend!=null)</span>
<span class="nc" id="L915">                                    context.instantSend.acceptLockRequest((TransactionLockRequest)tx);</span>
                            }
                        }
                    }
<span class="nc" id="L919">                } catch (VerificationException e) {</span>
<span class="nc" id="L920">                    log.error(&quot;Wallet failed to verify tx&quot;, e);</span>
                    // Carry on, listeners may still want to know.
<span class="nc" id="L922">                }</span>
<span class="nc" id="L923">            }</span>
        } finally {
<span class="nc" id="L925">            lock.unlock();</span>
<span class="nc" id="L926">        }</span>
        // Tell all listeners about this tx so they can decide whether to keep it or not. If no listener keeps a
        // reference around then the memory pool will forget about it after a while too because it uses weak references.
<span class="nc bnc" id="L929" title="All 2 branches missed.">        for (final ListenerRegistration&lt;OnTransactionBroadcastListener&gt; registration : onTransactionEventListeners) {</span>
<span class="nc" id="L930">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L933">                    registration.listener.onTransaction(Peer.this, tx);</span>
<span class="nc" id="L934">                }</span>
            });
<span class="nc" id="L936">        }</span>
<span class="nc" id="L937">    }</span>



    /**
     * &lt;p&gt;Returns a future that wraps a list of all transactions that the given transaction depends on, recursively.
     * Only transactions in peers memory pools are included; the recursion stops at transactions that are in the
     * current best chain. So it doesn't make much sense to provide a tx that was already in the best chain and
     * a precondition checks this.&lt;/p&gt;
     *
     * &lt;p&gt;For example, if tx has 2 inputs that connect to transactions A and B, and transaction B is unconfirmed and
     * has one input connecting to transaction C that is unconfirmed, and transaction C connects to transaction D
     * that is in the chain, then this method will return either {B, C} or {C, B}. No ordering is guaranteed.&lt;/p&gt;
     *
     * &lt;p&gt;This method is useful for apps that want to learn about how long an unconfirmed transaction might take
     * to confirm, by checking for unexpectedly time locked transactions, unusually deep dependency trees or fee-paying
     * transactions that depend on unconfirmed free transactions.&lt;/p&gt;
     *
     * &lt;p&gt;Note that dependencies downloaded this way will not trigger the onTransaction method of event listeners.&lt;/p&gt;
     */
    public ListenableFuture&lt;List&lt;Transaction&gt;&gt; downloadDependencies(Transaction tx) {
<span class="nc" id="L958">        TransactionConfidence.ConfidenceType txConfidence = tx.getConfidence().getConfidenceType();</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">        Preconditions.checkArgument(txConfidence != TransactionConfidence.ConfidenceType.BUILDING);</span>
<span class="nc" id="L960">        log.info(&quot;{}: Downloading dependencies of {}&quot;, getAddress(), tx.getHashAsString());</span>
<span class="nc" id="L961">        final LinkedList&lt;Transaction&gt; results = new LinkedList&lt;Transaction&gt;();</span>
        // future will be invoked when the entire dependency tree has been walked and the results compiled.
<span class="nc" id="L963">        final ListenableFuture&lt;Object&gt; future = downloadDependenciesInternal(vDownloadTxDependencyDepth, 0, tx,</span>
                new Object(), results);
<span class="nc" id="L965">        final SettableFuture&lt;List&lt;Transaction&gt;&gt; resultFuture = SettableFuture.create();</span>
<span class="nc" id="L966">        Futures.addCallback(future, new FutureCallback&lt;Object&gt;() {</span>
            @Override
            public void onSuccess(Object ignored) {
<span class="nc" id="L969">                resultFuture.set(results);</span>
<span class="nc" id="L970">            }</span>

            @Override
            public void onFailure(Throwable throwable) {
<span class="nc" id="L974">                resultFuture.setException(throwable);</span>
<span class="nc" id="L975">            }</span>
        });
<span class="nc" id="L977">        return resultFuture;</span>
    }

    // The marker object in the future returned is the same as the parameter. It is arbitrary and can be anything.
    protected ListenableFuture&lt;Object&gt; downloadDependenciesInternal(final int maxDepth, final int depth,
            final Transaction tx, final Object marker, final List&lt;Transaction&gt; results) {

<span class="nc" id="L984">        final SettableFuture&lt;Object&gt; resultFuture = SettableFuture.create();</span>
<span class="nc" id="L985">        final Sha256Hash rootTxHash = tx.getHash();</span>
        // We want to recursively grab its dependencies. This is so listeners can learn important information like
        // whether a transaction is dependent on a timelocked transaction or has an unexpectedly deep dependency tree
        // or depends on a no-fee transaction.

        // We may end up requesting transactions that we've already downloaded and thrown away here.
<span class="nc" id="L991">        Set&lt;Sha256Hash&gt; needToRequest = new CopyOnWriteArraySet&lt;Sha256Hash&gt;();</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">        for (TransactionInput input : tx.getInputs()) {</span>
            // There may be multiple inputs that connect to the same transaction.
<span class="nc" id="L994">            needToRequest.add(input.getOutpoint().getHash());</span>
<span class="nc" id="L995">        }</span>
<span class="nc" id="L996">        lock.lock();</span>
        try {
            // Build the request for the missing dependencies.
<span class="nc" id="L999">            List&lt;ListenableFuture&lt;Transaction&gt;&gt; futures = Lists.newArrayList();</span>
<span class="nc" id="L1000">            GetDataMessage getdata = new GetDataMessage(params);</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">            if (needToRequest.size() &gt; 1)</span>
<span class="nc" id="L1002">                log.info(&quot;{}: Requesting {} transactions for depth {} dep resolution&quot;, getAddress(), needToRequest.size(), depth + 1);</span>
<span class="nc bnc" id="L1003" title="All 2 branches missed.">            for (Sha256Hash hash : needToRequest) {</span>
<span class="nc" id="L1004">                getdata.addTransaction(hash);</span>
<span class="nc" id="L1005">                GetDataRequest req = new GetDataRequest(hash, SettableFuture.create());</span>
<span class="nc" id="L1006">                futures.add(req.future);</span>
<span class="nc" id="L1007">                getDataFutures.add(req);</span>
<span class="nc" id="L1008">            }</span>
<span class="nc" id="L1009">            ListenableFuture&lt;List&lt;Transaction&gt;&gt; successful = Futures.successfulAsList(futures);</span>
<span class="nc" id="L1010">            Futures.addCallback(successful, new FutureCallback&lt;List&lt;Transaction&gt;&gt;() {</span>
                @Override
                public void onSuccess(List&lt;Transaction&gt; transactions) {
                    // Once all transactions either were received, or we know there are no more to come ...
                    // Note that transactions will contain &quot;null&quot; for any positions that weren't successful.
<span class="nc" id="L1015">                    List&lt;ListenableFuture&lt;Object&gt;&gt; childFutures = Lists.newLinkedList();</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">                    for (Transaction tx : transactions) {</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">                        if (tx == null) continue;</span>
<span class="nc" id="L1018">                        log.info(&quot;{}: Downloaded dependency of {}: {}&quot;, getAddress(), rootTxHash, tx.getHashAsString());</span>
<span class="nc" id="L1019">                        results.add(tx);</span>
                        // Now recurse into the dependencies of this transaction too.
<span class="nc bnc" id="L1021" title="All 2 branches missed.">                        if (depth + 1 &lt; maxDepth)</span>
<span class="nc" id="L1022">                            childFutures.add(downloadDependenciesInternal(maxDepth, depth + 1, tx, marker, results));</span>
<span class="nc" id="L1023">                    }</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                    if (childFutures.size() == 0) {</span>
                        // Short-circuit: we're at the bottom of this part of the tree.
<span class="nc" id="L1026">                        resultFuture.set(marker);</span>
                    } else {
                        // There are some children to download. Wait until it's done (and their children and their
                        // children...) to inform the caller that we're finished.
<span class="nc" id="L1030">                        Futures.addCallback(Futures.successfulAsList(childFutures), new FutureCallback&lt;List&lt;Object&gt;&gt;() {</span>
                            @Override
                            public void onSuccess(List&lt;Object&gt; objects) {
<span class="nc" id="L1033">                                resultFuture.set(marker);</span>
<span class="nc" id="L1034">                            }</span>

                            @Override
                            public void onFailure(Throwable throwable) {
<span class="nc" id="L1038">                                resultFuture.setException(throwable);</span>
<span class="nc" id="L1039">                            }</span>
                        });
                    }
<span class="nc" id="L1042">                }</span>

                @Override
                public void onFailure(Throwable throwable) {
<span class="nc" id="L1046">                    resultFuture.setException(throwable);</span>
<span class="nc" id="L1047">                }</span>
            });
            // Start the operation.
<span class="nc" id="L1050">            sendMessage(getdata);</span>
<span class="nc" id="L1051">        } catch (Exception e) {</span>
<span class="nc" id="L1052">            log.error(&quot;{}: Couldn't send getdata in downloadDependencies({})&quot;, this, tx.getHash());</span>
<span class="nc" id="L1053">            resultFuture.setException(e);</span>
<span class="nc" id="L1054">            return resultFuture;</span>
        } finally {
<span class="nc" id="L1056">            lock.unlock();</span>
<span class="nc" id="L1057">        }</span>
<span class="nc" id="L1058">        return resultFuture;</span>
    }

    protected void processBlock(Block m) {
<span class="nc bnc" id="L1062" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1063">            log.debug(&quot;{}: Received broadcast block {}&quot;, getAddress(), m.getHashAsString());</span>
        }
        // Was this block requested by getBlock()?
<span class="nc bnc" id="L1066" title="All 2 branches missed.">        if (maybeHandleRequestedData(m)) return;</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">        if (blockChain == null) {</span>
<span class="nc" id="L1068">            log.debug(&quot;Received block but was not configured with an AbstractBlockChain&quot;);</span>
<span class="nc" id="L1069">            return;</span>
        }
        // Did we lose download peer status after requesting block data?
<span class="nc bnc" id="L1072" title="All 2 branches missed.">        if (!vDownloadData) {</span>
<span class="nc" id="L1073">            log.debug(&quot;{}: Received block we did not ask for: {}&quot;, getAddress(), m.getHashAsString());</span>
<span class="nc" id="L1074">            return;</span>
        }
<span class="nc" id="L1076">        pendingBlockDownloads.remove(m.getHash());</span>
        try {
            // Otherwise it's a block sent to us because the peer thought we needed it, so add it to the block chain.
<span class="nc bnc" id="L1079" title="All 2 branches missed.">            if (blockChain.add(m)) {</span>
                // The block was successfully linked into the chain. Notify the user of our progress.
<span class="nc" id="L1081">                invokeOnBlocksDownloaded(m, null);</span>
            } else {
                // This block is an orphan - we don't know how to get from it back to the genesis block yet. That
                // must mean that there are blocks we are missing, so do another getblocks with a new block locator
                // to ask the peer to send them to us. This can happen during the initial block chain download where
                // the peer will only send us 500 at a time and then sends us the head block expecting us to request
                // the others.
                //
                // We must do two things here:
                // (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set
                // (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                //
                // The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                // we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the
                // chain twice (or more!) on the same connection! The block chain would filter out the duplicates but
                // only at a huge speed penalty. By finding the orphan root we ensure every getblocks looks the same
                // no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
                //
                // We only do this if we are not currently downloading headers. If we are then we don't want to kick
                // off a request for lots more headers in parallel.
<span class="nc" id="L1101">                lock.lock();</span>
                try {
                    //todo: furszy check this please..
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                    if (downloadBlockBodies) {</span>
<span class="nc" id="L1105">                        final Block orphanRoot = checkNotNull(blockChain.getOrphanRoot(m.getHash()));</span>
<span class="nc" id="L1106">                        blockChainDownloadLocked(orphanRoot.getHash());</span>
<span class="nc" id="L1107">                    } else {</span>
<span class="nc" id="L1108">                        log.info(&quot;Did not start chain download on solved block due to in-flight header download.&quot;);</span>
<span class="nc" id="L1109">                        blockChainDownloadLocked(Sha256Hash.ZERO_HASH); // continue headers downloading</span>
                    }
                } finally {
<span class="nc" id="L1112">                    lock.unlock();</span>
<span class="nc" id="L1113">                }</span>
            }
<span class="nc" id="L1115">        } catch (VerificationException e) {</span>
            // We don't want verification failures to kill the thread.
<span class="nc" id="L1117">            log.warn(&quot;{}: Block verification failed&quot;, getAddress(), e);</span>
<span class="nc" id="L1118">        } catch (PrunedException e) {</span>
            // Unreachable when in SPV mode.
<span class="nc" id="L1120">            throw new RuntimeException(e);</span>
<span class="nc" id="L1121">        }</span>
<span class="nc" id="L1122">    }</span>

    // TODO: Fix this duplication.
    protected void endFilteredBlock(FilteredBlock m) {
<span class="nc bnc" id="L1126" title="All 2 branches missed.">        if (log.isDebugEnabled())</span>
<span class="nc" id="L1127">            log.debug(&quot;{}: Received broadcast filtered block {}&quot;, getAddress(), m.getHash().toString());</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">        if (!vDownloadData) {</span>
<span class="nc" id="L1129">            log.debug(&quot;{}: Received block we did not ask for: {}&quot;, getAddress(), m.getHash().toString());</span>
<span class="nc" id="L1130">            return;</span>
        }
<span class="nc bnc" id="L1132" title="All 2 branches missed.">        if (blockChain == null) {</span>
<span class="nc" id="L1133">            log.debug(&quot;Received filtered block but was not configured with an AbstractBlockChain&quot;);</span>
<span class="nc" id="L1134">            return;</span>
        }
        // Note that we currently do nothing about peers which maliciously do not include transactions which
        // actually match our filter or which simply do not send us all the transactions we need: it can be fixed
        // by cross-checking peers against each other.
<span class="nc" id="L1139">        pendingBlockDownloads.remove(m.getBlockHeader().getHash());</span>
        try {
            // It's a block sent to us because the peer thought we needed it, so maybe add it to the block chain.
            // The FilteredBlock m here contains a list of hashes, and may contain Transaction objects for a subset
            // of the hashes (those that were sent to us by the remote peer). Any hashes that haven't had a tx
            // provided in processTransaction are ones that were announced to us previously via an 'inv' so the
            // assumption is we have already downloaded them and either put them in the wallet, or threw them away
            // for being false positives.
            //
            // TODO: Fix the following protocol race.
            // It is possible for this code to go wrong such that we miss a confirmation. If the remote peer announces
            // a relevant transaction via an 'inv' and then it immediately announces the block that confirms
            // the tx before we had a chance to download it+its dependencies and provide them to the wallet, then we
            // will add the block to the chain here without the tx being in the wallet and thus it will miss its
            // confirmation and become stuck forever. The fix is to notice that there's a pending getdata for a tx
            // that appeared in this block and delay processing until it arrived ... it's complicated by the fact that
            // the data may be requested by a different peer to this one.

            // Ask each wallet attached to the peer/blockchain if this block exhausts the list of data items
            // (keys/addresses) that were used to calculate the previous filter. If so, then it's possible this block
            // is only partial. Check for discarding first so we don't check for exhaustion on blocks we already know
            // we're going to discard, otherwise redundant filters might end up being queued and calculated.
<span class="nc" id="L1161">            lock.lock();</span>
            try {
<span class="nc bnc" id="L1163" title="All 2 branches missed.">                if (awaitingFreshFilter != null) {</span>
<span class="nc" id="L1164">                    log.info(&quot;Discarding block {} because we're still waiting for a fresh filter&quot;, m.getHash());</span>
                    // We must record the hashes of blocks we discard because you cannot do getblocks twice on the same
                    // range of blocks and get an inv both times, due to the codepath in Bitcoin Core hitting
                    // CPeer::PushInventory() which checks CPeer::setInventoryKnown and thus deduplicates.
<span class="nc" id="L1168">                    awaitingFreshFilter.add(m.getHash());</span>
<span class="nc" id="L1169">                    return;   // Chain download process is restarted via a call to setBloomFilter.</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">                } else if (checkForFilterExhaustion(m)) {</span>
<span class="nc" id="L1171">                    System.out.println(&quot;#### checkForFilterExhaustion true&quot;);</span>
                    // Yes, so we must abandon the attempt to process this block and any further blocks we receive,
                    // then wait for the Bloom filter to be recalculated, sent to this peer and for the peer to acknowledge
                    // that the new filter is now in use (which we have to simulate with a ping/pong), and then we can
                    // safely restart the chain download with the new filter that contains a new set of lookahead keys.
<span class="nc" id="L1176">                    log.info(&quot;Bloom filter exhausted whilst processing block {}, discarding&quot;, m.getHash());</span>
<span class="nc" id="L1177">                    awaitingFreshFilter = new LinkedList&lt;Sha256Hash&gt;();</span>
<span class="nc" id="L1178">                    awaitingFreshFilter.add(m.getHash());</span>
<span class="nc" id="L1179">                    awaitingFreshFilter.addAll(blockChain.drainOrphanBlocks());</span>
<span class="nc" id="L1180">                    return;   // Chain download process is restarted via a call to setBloomFilter.</span>
                }
            } finally {
<span class="nc" id="L1183">                lock.unlock();</span>
<span class="nc" id="L1184">            }</span>

<span class="nc bnc" id="L1186" title="All 2 branches missed.">            if (blockChain.add(m)) {</span>
                // The block was successfully linked into the chain. Notify the user of our progress.
<span class="nc" id="L1188">                invokeOnBlocksDownloaded(m.getBlockHeader(), m);</span>
            } else {
                // This block is an orphan - we don't know how to get from it back to the genesis block yet. That
                // must mean that there are blocks we are missing, so do another getblocks with a new block locator
                // to ask the peer to send them to us. This can happen during the initial block chain download where
                // the peer will only send us 500 at a time and then sends us the head block expecting us to request
                // the others.
                //
                // We must do two things here:
                // (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set
                // (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                //
                // The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                // we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the
                // chain twice (or more!) on the same connection! The block chain would filter out the duplicates but
                // only at a huge speed penalty. By finding the orphan root we ensure every getblocks looks the same
                // no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
<span class="nc" id="L1205">                lock.lock();</span>
                try {
<span class="nc" id="L1207">                    final Block orphanRoot = checkNotNull(blockChain.getOrphanRoot(m.getHash()));</span>
<span class="nc" id="L1208">                    blockChainDownloadLocked(orphanRoot.getHash());</span>
                } finally {
<span class="nc" id="L1210">                    lock.unlock();</span>
<span class="nc" id="L1211">                }</span>
            }
<span class="nc" id="L1213">        } catch (VerificationException e) {</span>
            // We don't want verification failures to kill the thread.
<span class="nc" id="L1215">            log.warn(&quot;{}: FilteredBlock verification failed&quot;, getAddress(), e);</span>
<span class="nc" id="L1216">        } catch (PrunedException e) {</span>
            // We pruned away some of the data we need to properly handle this block. We need to request the needed
            // data from the remote peer and fix things. Or just give up.
            // TODO: Request e.getHash() and submit it to the block store before any other blocks
<span class="nc" id="L1220">            throw new RuntimeException(e);</span>
<span class="nc" id="L1221">        }</span>
<span class="nc" id="L1222">    }</span>

    private boolean checkForFilterExhaustion(FilteredBlock m) {
<span class="nc" id="L1225">        boolean exhausted = false;</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">        for (Wallet wallet : wallets) {</span>
<span class="nc" id="L1227">            exhausted |= wallet.checkForFilterExhaustion(m);</span>
<span class="nc" id="L1228">        }</span>
<span class="nc" id="L1229">        return exhausted;</span>
    }

    private boolean maybeHandleRequestedData(Message m) {
<span class="nc" id="L1233">        boolean found = false;</span>
<span class="nc" id="L1234">        Sha256Hash hash = m.getHash();</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">        for (GetDataRequest req : getDataFutures) {</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">            if (hash.equals(req.hash)) {</span>
<span class="nc" id="L1237">                req.future.set(m);</span>
<span class="nc" id="L1238">                getDataFutures.remove(req);</span>
<span class="nc" id="L1239">                found = true;</span>
                // Keep going in case there are more.
            }
<span class="nc" id="L1242">        }</span>
<span class="nc" id="L1243">        return found;</span>
    }

    private void invokeOnBlocksDownloaded(final Block block, @Nullable final FilteredBlock fb) {
        // It is possible for the peer block height difference to be negative when blocks have been solved and broadcast
        // since the time we first connected to the peer. However, it's weird and unexpected to receive a callback
        // with negative &quot;blocks left&quot; in this case, so we clamp to zero so the API user doesn't have to think about it.
<span class="nc" id="L1250">        final int blocksLeft = Math.max(0, (int) vPeerVersionMessage.bestHeight - checkNotNull(blockChain).getBestChainHeight());</span>
<span class="nc bnc" id="L1251" title="All 2 branches missed.">        for (final ListenerRegistration&lt;BlocksDownloadedEventListener&gt; registration : blocksDownloadedEventListeners) {</span>
<span class="nc" id="L1252">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L1255">                    registration.listener.onBlocksDownloaded(Peer.this, block, fb, blocksLeft);</span>
<span class="nc" id="L1256">                }</span>
            });
<span class="nc" id="L1258">        }</span>
<span class="nc" id="L1259">    }</span>

    //added for dash
    boolean alreadyHave(InventoryItem inv)
    {
<span class="nc bnc" id="L1264" title="All 11 branches missed.">        switch (inv.type)</span>
        {
//            case MSG_DSTX:
  //              return mapDarksendBroadcastTxes.count(inv.hash);
            case TransactionLockRequest:
<span class="nc bnc" id="L1269" title="All 2 branches missed.">                return context.instantSend.mapLockRequestAccepted.containsKey(inv.hash) ||</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">                        context.instantSend.mapLockRequestRejected.containsKey(inv.hash);</span>
            case TransactionLockVote:
<span class="nc" id="L1272">                return  context.instantSend.mapTxLockVotes.containsKey(inv.hash);</span>
            case Spork:
<span class="nc" id="L1274">                return context.sporkManager.mapSporks.containsKey(inv.hash);</span>
            case MasterNodeWinner:
                /*if(context.masternodePayments.mapMasternodePayeeVotes.containsKey(inv.hash)) {
                    context.masternodeSync.AddedMasternodeWinner(inv.hash);
                    return true;
                }*/
<span class="nc" id="L1280">                return false;</span>
            case GovernanceVote:
                /*if(budget.mapSeenMasternodeBudgetVotes.containsKey(inv.hash)) {
                    masternodeSync.AddedBudgetItem(inv.hash);
                    return true;
                }*/
<span class="nc" id="L1286">                return false;</span>
            case GovernanceObject:
               /*if(budget.mapSeenMasternodeBudgetProposals.containsKey(inv.hash)) {
                    masternodeSync.AddedBudgetItem(inv.hash);
                    return true;
                }*/
<span class="nc" id="L1292">                return false;</span>
            case BudgetFinalizedVote:
                /*if(budget.mapSeenFinalizedBudgetVotes.count(inv.hash)) {
                    masternodeSync.AddedBudgetItem(inv.hash);
                    return true;
                }*/
<span class="nc" id="L1298">                return false;</span>
            case BudgetFinalized:
                /*if(budget.mapSeenFinalizedBudgets.count(inv.hash)) {
                    masternodeSync.AddedBudgetItem(inv.hash);
                    return true;
                }*/
<span class="nc" id="L1304">                return false;</span>
            case MasterNodeAnnounce:
<span class="nc bnc" id="L1306" title="All 2 branches missed.">                if(context.masternodeManager.mapSeenMasternodeBroadcast.containsKey(inv.hash)) {</span>
<span class="nc" id="L1307">                    context.masternodeSync.addedMasternodeList(inv.hash);</span>
<span class="nc" id="L1308">                    return true;</span>
                }
<span class="nc" id="L1310">                return false;</span>
            case MasterNodePing:
<span class="nc" id="L1312">                return context.masternodeManager.mapSeenMasternodePing.containsKey(inv.hash);</span>
        }
        // Don't know what it is, just say we already got one
<span class="nc" id="L1315">        return true;</span>
    }

    protected void processInv(InventoryMessage inv) {
<span class="nc" id="L1319">        List&lt;InventoryItem&gt; items = inv.getItems();</span>

        // Separate out the blocks and transactions, we'll handle them differently
<span class="nc" id="L1322">        List&lt;InventoryItem&gt; transactions = new LinkedList&lt;InventoryItem&gt;();</span>
<span class="nc" id="L1323">        List&lt;InventoryItem&gt; blocks = new LinkedList&lt;InventoryItem&gt;();</span>
<span class="nc" id="L1324">        List&lt;InventoryItem&gt; instantxLockRequests = new LinkedList&lt;InventoryItem&gt;();</span>
<span class="nc" id="L1325">        List&lt;InventoryItem&gt; instantxLocks = new LinkedList&lt;InventoryItem&gt;();</span>
<span class="nc" id="L1326">        List&lt;InventoryItem&gt; masternodePings = new LinkedList&lt;InventoryItem&gt;();</span>
<span class="nc" id="L1327">        List&lt;InventoryItem&gt; masternodeBroadcasts = new LinkedList&lt;InventoryItem&gt;();</span>
<span class="nc" id="L1328">        List&lt;InventoryItem&gt; sporks = new LinkedList&lt;InventoryItem&gt;();</span>

        //InstantSend instantSend = InstantSend.get(blockChain);
<span class="nc" id="L1331">        log.info(&quot;inv arrived, items: &quot;+Arrays.toString(items.toArray()));</span>

<span class="nc bnc" id="L1333" title="All 2 branches missed.">        for (InventoryItem item : items) {</span>
<span class="nc bnc" id="L1334" title="All 16 branches missed.">            switch (item.type) {</span>
                case Transaction:
<span class="nc" id="L1336">                    transactions.add(item);</span>
<span class="nc" id="L1337">                    break;</span>
                case TransactionLockRequest:
                    //if(instantSend.isEnabled())
<span class="nc" id="L1340">                        instantxLockRequests.add(item);</span>
                    //transactions.add(item);
<span class="nc" id="L1342">                    break;</span>
                case Block:
<span class="nc" id="L1344">                    blocks.add(item);</span>
<span class="nc" id="L1345">                    break;</span>
                case TransactionLockVote:
                    //if(instantSend.isEnabled())
<span class="nc" id="L1348">                        instantxLocks.add(item);</span>
<span class="nc" id="L1349">                    break;</span>
                case Spork:
<span class="nc" id="L1351">                    sporks.add(item);</span>
<span class="nc" id="L1352">                    break;</span>
                case MasterNodeWinner:
<span class="nc" id="L1354">                    break;</span>
<span class="nc" id="L1355">                case MasterNodeScanningError: break;</span>
<span class="nc" id="L1356">                case GovernanceVote: break;</span>
<span class="nc" id="L1357">                case GovernanceObject: break;</span>
<span class="nc" id="L1358">                case    BudgetFinalized: break;</span>
<span class="nc" id="L1359">                case    BudgetFinalizedVote: break;</span>
<span class="nc" id="L1360">                case    MasterNodeQuarum: break;</span>
                case    MasterNodeAnnounce:
<span class="nc bnc" id="L1362" title="All 2 branches missed.">                    if(context.isLiteMode()) break;</span>
<span class="nc" id="L1363">                    masternodeBroadcasts.add(item);</span>
<span class="nc" id="L1364">                    break;</span>
                case    MasterNodePing:
<span class="nc bnc" id="L1366" title="All 2 branches missed.">                    if(context.isLiteMode()) break;</span>
<span class="nc" id="L1367">                    masternodePings.add(item);</span>
<span class="nc" id="L1368">                    break;</span>
                case DarkSendTransaction:
<span class="nc" id="L1370">                    break;</span>
                default:
                    break;
                    //throw new IllegalStateException(&quot;Not implemented: &quot; + item.type);
            }
<span class="nc" id="L1375">        }</span>

<span class="nc" id="L1377">        final boolean downloadData = this.vDownloadData;</span>

<span class="nc bnc" id="L1379" title="All 4 branches missed.">        if (transactions.size() == 0 &amp;&amp; blocks.size() == 1) {</span>
            // Single block announcement. If we're downloading the chain this is just a tickle to make us continue
            // (the block chain download protocol is very implicit and not well thought out). If we're not downloading
            // the chain then this probably means a new block was solved and the peer believes it connects to the best
            // chain, so count it. This way getBestChainHeight() can be accurate.
<span class="nc bnc" id="L1384" title="All 4 branches missed.">            if (downloadData &amp;&amp; blockChain != null) {</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">                if (!blockChain.isOrphan(blocks.get(0).hash)) {</span>
<span class="nc" id="L1386">                    blocksAnnounced.incrementAndGet();</span>
                }
            } else {
<span class="nc" id="L1389">                blocksAnnounced.incrementAndGet();</span>
            }
        }

<span class="nc" id="L1393">        GetDataMessage getdata = new GetDataMessage(params);</span>

<span class="nc" id="L1395">        Iterator&lt;InventoryItem&gt; it = transactions.iterator();</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L1397">            InventoryItem item = it.next();</span>
            // Only download the transaction if we are the first peer that saw it be advertised. Other peers will also
            // see it be advertised in inv packets asynchronously, they co-ordinate via the memory pool. We could
            // potentially download transactions faster by always asking every peer for a tx when advertised, as remote
            // peers run at different speeds. However to conserve bandwidth on mobile devices we try to only download a
            // transaction once. This means we can miss broadcasts if the peer disconnects between sending us an inv and
            // sending us the transaction: currently we'll never try to re-fetch after a timeout.
            //
            // The line below can trigger confidence listeners.
<span class="nc" id="L1406">            TransactionConfidence conf = context.getConfidenceTable().seen(item.hash, this.getAddress());</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">            if (conf.numBroadcastPeers() &gt; 1) {</span>
                // Some other peer already announced this so don't download.
<span class="nc" id="L1409">                it.remove();</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">            } else if (conf.getSource().equals(TransactionConfidence.Source.SELF)) {</span>
                // We created this transaction ourselves, so don't download.
<span class="nc" id="L1412">                it.remove();</span>
            } else {
<span class="nc" id="L1414">                log.debug(&quot;{}: getdata on tx {}&quot;, getAddress(), item.hash);</span>
<span class="nc" id="L1415">                getdata.addItem(item);</span>
                // Register with the garbage collector that we care about the confidence data for a while.
<span class="nc" id="L1417">                pendingTxDownloads.add(conf);</span>
            }
<span class="nc" id="L1419">        }</span>

<span class="nc" id="L1421">        it = instantxLockRequests.iterator();</span>
<span class="nc bnc" id="L1422" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L1423">            InventoryItem item = it.next();</span>
            // Only download the transaction if we are the first peer that saw it be advertised. Other peers will also
            // see it be advertised in inv packets asynchronously, they co-ordinate via the memory pool. We could
            // potentially download transactions faster by always asking every peer for a tx when advertised, as remote
            // peers run at different speeds. However to conserve bandwidth on mobile devices we try to only download a
            // transaction once. This means we can miss broadcasts if the peer disconnects between sending us an inv and
            // sending us the transaction: currently we'll never try to re-fetch after a timeout.
            //
            // The line below can trigger confidence listeners.
<span class="nc" id="L1432">            TransactionConfidence conf = context.getConfidenceTable().seen(item.hash, this.getAddress());</span>
<span class="nc bnc" id="L1433" title="All 2 branches missed.">            if (conf.numBroadcastPeers() &gt; 1) {</span>
                // Some other peer already announced this so don't download.
<span class="nc" id="L1435">                it.remove();</span>
<span class="nc bnc" id="L1436" title="All 2 branches missed.">            } else if (conf.getSource().equals(TransactionConfidence.Source.SELF)) {</span>
                // We created this transaction ourselves, so don't download.
<span class="nc" id="L1438">                it.remove();</span>
            } else {
<span class="nc" id="L1440">                log.debug(&quot;{}: getdata on tx {}&quot;, getAddress(), item.hash);</span>
<span class="nc" id="L1441">                getdata.addItem(item);</span>
                // Register with the garbage collector that we care about the confidence data for a while.
<span class="nc" id="L1443">                pendingTxDownloads.add(conf);</span>
            }
<span class="nc" id="L1445">        }</span>



<span class="nc" id="L1449">        it = instantxLocks.iterator();</span>
        //InstantSend instantSend = InstantSend.get(blockChain);
<span class="nc bnc" id="L1451" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L1452">            InventoryItem item = it.next();</span>

//            if(!instantSend.mapTxLockVotes.containsKey(item.hash))
            {
<span class="nc" id="L1456">                getdata.addItem(item);</span>
            }
<span class="nc" id="L1458">        }</span>

        //masternodepings

        //if(blockChain.getBestChainHeight() &gt; (this.getBestHeight() - 100))
        {

           //if(context.masternodeSync.isSynced()) {
<span class="nc" id="L1466">                it = masternodePings.iterator();</span>

<span class="nc bnc" id="L1468" title="All 2 branches missed.">                while (it.hasNext()) {</span>
<span class="nc" id="L1469">                    InventoryItem item = it.next();</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">                    if (!context.masternodeManager.mapSeenMasternodePing.containsKey(item.hash)) {</span>
                        //log.info(&quot;inv - received MasternodePing :&quot; + item.hash + &quot; new ping&quot;);
<span class="nc" id="L1472">                        getdata.addItem(item);</span>
                    } //else
                        //log.info(&quot;inv - received MasternodePing :&quot; + item.hash + &quot; already seen&quot;);
<span class="nc" id="L1475">                }</span>
           // }

<span class="nc" id="L1478">            it = masternodeBroadcasts.iterator();</span>

<span class="nc bnc" id="L1480" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc" id="L1481">                InventoryItem item = it.next();</span>
                //log.info(&quot;inv - received MasternodeBroadcast :&quot; + item.hash);

                //if(!instantSend.mapTxLockVotes.containsKey(item.hash))
                //{
<span class="nc bnc" id="L1486" title="All 2 branches missed.">                if(!alreadyHave(item))</span>
<span class="nc" id="L1487">                    getdata.addItem(item);</span>
                //}
<span class="nc" id="L1489">            }</span>
        }
<span class="nc" id="L1491">        it = sporks.iterator();</span>

<span class="nc bnc" id="L1493" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L1494">            InventoryItem item = it.next();</span>

            //if(!instantSend.mapTxLockVotes.containsKey(item.hash))
            //{
<span class="nc" id="L1498">            getdata.addItem(item);</span>
            //}
<span class="nc" id="L1500">        }</span>

        // If we are requesting filteredblocks we have to send a ping after the getdata so that we have a clear
        // end to the final FilteredBlock's transactions (in the form of a pong) sent to us
<span class="nc" id="L1504">        boolean pingAfterGetData = false;</span>

<span class="nc" id="L1506">        lock.lock();</span>
        try {
<span class="nc bnc" id="L1508" title="All 6 branches missed.">            if (blocks.size() &gt; 0 &amp;&amp; downloadData &amp;&amp; blockChain != null) {</span>
                // Ideally, we'd only ask for the data here if we actually needed it. However that can imply a lot of
                // disk IO to figure out what we've got. Normally peers will not send us inv for things we already have
                // so we just re-request it here, and if we get duplicates the block chain / wallet will filter them out.
<span class="nc bnc" id="L1512" title="All 2 branches missed.">                for (InventoryItem item : blocks) {</span>
<span class="nc bnc" id="L1513" title="All 4 branches missed.">                    if (blockChain.isOrphan(item.hash) &amp;&amp; downloadBlockBodies) {</span>
                        // If an orphan was re-advertised, ask for more blocks unless we are not currently downloading
                        // full block data because we have a getheaders outstanding.
<span class="nc" id="L1516">                        final Block orphanRoot = checkNotNull(blockChain.getOrphanRoot(item.hash));</span>
<span class="nc" id="L1517">                        blockChainDownloadLocked(orphanRoot.getHash());</span>
<span class="nc" id="L1518">                    } else {</span>
                        // Don't re-request blocks we already requested. Normally this should not happen. However there is
                        // an edge case: if a block is solved and we complete the inv&lt;-&gt;getdata&lt;-&gt;block&lt;-&gt;getblocks cycle
                        // whilst other parts of the chain are streaming in, then the new getblocks request won't match the
                        // previous one: whilst the stopHash is the same (because we use the orphan root), the start hash
                        // will be different and so the getblocks req won't be dropped as a duplicate. We'll end up
                        // requesting a subset of what we already requested, which can lead to parallel chain downloads
                        // and other nastyness. So we just do a quick removal of redundant getdatas here too.
                        //
                        // Note that as of June 2012 Bitcoin Core won't actually ever interleave blocks pushed as
                        // part of chain download with newly announced blocks, so it should always be taken care of by
                        // the duplicate check in blockChainDownloadLocked(). But Bitcoin Core may change in future so
                        // it's better to be safe here.
<span class="nc bnc" id="L1531" title="All 2 branches missed.">                        if (!pendingBlockDownloads.contains(item.hash)) {</span>
<span class="nc bnc" id="L1532" title="All 4 branches missed.">                            if (vPeerVersionMessage.isBloomFilteringSupported() &amp;&amp; useFilteredBlocks) {</span>
<span class="nc" id="L1533">                                getdata.addFilteredBlock(item.hash);</span>
<span class="nc" id="L1534">                                pingAfterGetData = true;</span>
                            } else {
<span class="nc" id="L1536">                                getdata.addItem(item);</span>
                            }
<span class="nc" id="L1538">                            pendingBlockDownloads.add(item.hash);</span>
                            //System.out.println(&quot;pending blocks: &quot;+Arrays.toString(pendingBlockDownloads.toArray()));
                        }else {
<span class="nc" id="L1541">                            getdata.addFilteredBlock(item.hash);</span>
<span class="nc" id="L1542">                            pingAfterGetData = true;</span>
                            //System.out.println(&quot;trying to continue syncing but the block is already on the pending blocks downloads list&quot;);
                        }
                    }
<span class="nc" id="L1546">                }</span>
                // If we're downloading the chain, doing a getdata on the last block we were told about will cause the
                // peer to advertize the head block to us in a single-item inv. When we download THAT, it will be an
                // orphan block, meaning we'll re-enter blockChainDownloadLocked() to trigger another getblocks between the
                // current best block we have and the orphan block. If more blocks arrive in the meantime they'll also
                // become orphan.
            }
        } finally {
<span class="nc" id="L1554">            lock.unlock();</span>
<span class="nc" id="L1555">        }</span>

<span class="nc bnc" id="L1557" title="All 2 branches missed.">        if (!getdata.getItems().isEmpty()) {</span>
            //System.out.println(&quot;sending getData for more blocks&quot;);
            // This will cause us to receive a bunch of block or tx messages.
<span class="nc" id="L1560">            sendMessage(getdata);</span>
        }else {
            //System.out.println(&quot;for some reason the getData items list is empty..&quot;);
        }

<span class="nc bnc" id="L1565" title="All 2 branches missed.">        if (pingAfterGetData)</span>
<span class="nc" id="L1566">            sendMessage(new Ping((long) (Math.random() * Long.MAX_VALUE)));</span>
<span class="nc" id="L1567">    }</span>

    /**
     * Asks the connected peer for the block of the given hash, and returns a future representing the answer.
     * If you want the block right away and don't mind waiting for it, just call .get() on the result. Your thread
     * will block until the peer answers.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    // The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning
    // ListenableFuture instead of ListenableFuture&lt;Block&gt;. This is okay as sendSingleGetData() actually returns
    // ListenableFuture&lt;Block&gt; in this context. Note that sendSingleGetData() is also used for Transactions.
    public ListenableFuture&lt;Block&gt; getBlock(Sha256Hash blockHash) {
        // This does not need to be locked.
<span class="nc" id="L1580">        log.info(&quot;Request to fetch block {}&quot;, blockHash);</span>
<span class="nc" id="L1581">        GetDataMessage getdata = new GetDataMessage(params);</span>
<span class="nc" id="L1582">        getdata.addBlock(blockHash);</span>
<span class="nc" id="L1583">        return sendSingleGetData(getdata);</span>
    }

    /**
     * Asks the connected peer for the given transaction from its memory pool. Transactions in the chain cannot be
     * retrieved this way because peers don't have a transaction ID to transaction-pos-on-disk index, and besides,
     * in future many peers will delete old transaction data they don't need.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    // The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning
    // ListenableFuture instead of ListenableFuture&lt;Transaction&gt;. This is okay as sendSingleGetData() actually returns
    // ListenableFuture&lt;Transaction&gt; in this context. Note that sendSingleGetData() is also used for Blocks.
    public ListenableFuture&lt;Transaction&gt; getPeerMempoolTransaction(Sha256Hash hash) {
        // This does not need to be locked.
        // TODO: Unit test this method.
<span class="nc" id="L1598">        log.info(&quot;Request to fetch peer mempool tx  {}&quot;, hash);</span>
<span class="nc" id="L1599">        GetDataMessage getdata = new GetDataMessage(params);</span>
<span class="nc" id="L1600">        getdata.addTransaction(hash);</span>
<span class="nc" id="L1601">        return sendSingleGetData(getdata);</span>
    }

    /** Sends a getdata with a single item in it. */
    private ListenableFuture sendSingleGetData(GetDataMessage getdata) {
        // This does not need to be locked.
<span class="nc bnc" id="L1607" title="All 2 branches missed.">        Preconditions.checkArgument(getdata.getItems().size() == 1);</span>
<span class="nc" id="L1608">        GetDataRequest req = new GetDataRequest(getdata.getItems().get(0).hash, SettableFuture.create());</span>
<span class="nc" id="L1609">        getDataFutures.add(req);</span>
<span class="nc" id="L1610">        sendMessage(getdata);</span>
<span class="nc" id="L1611">        return req.future;</span>
    }

    /** Sends a getaddr request to the peer and returns a future that completes with the answer once the peer has replied. */
    public ListenableFuture&lt;AddressMessage&gt; getAddr() {
<span class="nc" id="L1616">        SettableFuture&lt;AddressMessage&gt; future = SettableFuture.create();</span>
<span class="nc" id="L1617">        synchronized (getAddrFutures) {</span>
<span class="nc" id="L1618">            getAddrFutures.add(future);</span>
<span class="nc" id="L1619">        }</span>
<span class="nc" id="L1620">        sendMessage(new GetAddrMessage(params));</span>
<span class="nc" id="L1621">        return future;</span>
    }

    /**
     * When downloading the block chain, the bodies will be skipped for blocks created before the given date. Any
     * transactions relevant to the wallet will therefore not be found, but if you know your wallet has no such
     * transactions it doesn't matter and can save a lot of bandwidth and processing time. Note that the times of blocks
     * isn't known until their headers are available and they are requested in chunks, so some headers may be downloaded
     * twice using this scheme, but this optimization can still be a large win for newly created wallets.
     *
     * @param secondsSinceEpoch Time in seconds since the epoch or 0 to reset to always downloading block bodies.
     */
    public void setDownloadParameters(long secondsSinceEpoch, boolean useFilteredBlocks) {
<span class="nc" id="L1634">        lock.lock();</span>
        try {
<span class="nc bnc" id="L1636" title="All 2 branches missed.">            if (secondsSinceEpoch == 0) {</span>
<span class="nc" id="L1637">                fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();</span>
<span class="nc" id="L1638">                downloadBlockBodies = true;</span>
            } else {
<span class="nc" id="L1640">                fastCatchupTimeSecs = secondsSinceEpoch;</span>
                // If the given time is before the current chains head block time, then this has no effect (we already
                // downloaded everything we need).
<span class="nc bnc" id="L1643" title="All 4 branches missed.">                if (blockChain != null &amp;&amp; fastCatchupTimeSecs &gt; blockChain.getChainHead().getHeader().getTimeSeconds())</span>
<span class="nc" id="L1644">                    downloadBlockBodies = false;</span>
            }
<span class="nc" id="L1646">            this.useFilteredBlocks = useFilteredBlocks;</span>
        } finally {
<span class="nc" id="L1648">            lock.unlock();</span>
<span class="nc" id="L1649">        }</span>
<span class="nc" id="L1650">    }</span>

    /**
     * Links the given wallet to this peer. If you have multiple peers, you should use a {@link PeerGroup} to manage
     * them and use the {@link PeerGroup#addWallet(Wallet)} method instead of registering the wallet with each peer
     * independently, otherwise the wallet will receive duplicate notifications.
     */
    public void addWallet(Wallet wallet) {
<span class="nc" id="L1658">        wallets.add(wallet);</span>
<span class="nc" id="L1659">    }</span>

    /** Unlinks the given wallet from peer. See {@link Peer#addWallet(Wallet)}. */
    public void removeWallet(Wallet wallet) {
<span class="nc" id="L1663">        wallets.remove(wallet);</span>
<span class="nc" id="L1664">    }</span>

    // Keep track of the last request we made to the peer in blockChainDownloadLocked so we can avoid redundant and harmful
    // getblocks requests.
    @GuardedBy(&quot;lock&quot;)
    private Sha256Hash lastGetBlocksBegin, lastGetBlocksEnd;

    @GuardedBy(&quot;lock&quot;)
    private void blockChainDownloadLocked(Sha256Hash toHash) {
        //System.out.println(&quot;### blockChainDownloadLocked&quot;);
<span class="nc" id="L1674">        checkState(lock.isHeldByCurrentThread());</span>
        // The block chain download process is a bit complicated. Basically, we start with one or more blocks in a
        // chain that we have from a previous session. We want to catch up to the head of the chain BUT we don't know
        // where that chain is up to or even if the top block we have is even still in the chain - we
        // might have got ourselves onto a fork that was later resolved by the network.
        //
        // To solve this, we send the peer a block locator which is just a list of block hashes. It contains the
        // blocks we know about, but not all of them, just enough of them so the peer can figure out if we did end up
        // on a fork and if so, what the earliest still valid block we know about is likely to be.
        //
        // Once it has decided which blocks we need, it will send us an inv with up to 500 block messages. We may
        // have some of them already if we already have a block chain and just need to catch up. Once we request the
        // last block, if there are still more to come it sends us an &quot;inv&quot; containing only the hash of the head
        // block.
        //
        // That causes us to download the head block but then we find (in processBlock) that we can't connect
        // it to the chain yet because we don't have the intermediate blocks. So we rerun this function building a
        // new block locator describing where we're up to.
        //
        // The getblocks with the new locator gets us another inv with another bunch of blocks. We download them once
        // again. This time when the peer sends us an inv with the head block, we already have it so we won't download
        // it again - but we recognize this case as special and call back into blockChainDownloadLocked to continue the
        // process.
        //
        // So this is a complicated process but it has the advantage that we can download a chain of enormous length
        // in a relatively stateless manner and with constant memory usage.
        //
        // All this is made more complicated by the desire to skip downloading the bodies of blocks that pre-date the
        // 'fast catchup time', which is usually set to the creation date of the earliest key in the wallet. Because
        // we know there are no transactions using our keys before that date, we need only the headers. To do that we
        // use the &quot;getheaders&quot; command. Once we find we've gone past the target date, we throw away the downloaded
        // headers and then request the blocks from that point onwards. &quot;getheaders&quot; does not send us an inv, it just
        // sends us the data we requested in a &quot;headers&quot; message.

        // TODO: Block locators should be abstracted out rather than special cased here.
<span class="nc" id="L1709">        List&lt;Sha256Hash&gt; blockLocator = new ArrayList&lt;Sha256Hash&gt;(51);</span>
        // For now we don't do the exponential thinning as suggested here:
        //
        //   https://en.bitcoin.it/wiki/Protocol_specification#getblocks
        //
        // This is because it requires scanning all the block chain headers, which is very slow. Instead we add the top
        // 100 block headers. If there is a re-org deeper than that, we'll end up downloading the entire chain. We
        // must always put the genesis block as the first entry.
<span class="nc" id="L1717">        BlockStore store = checkNotNull(blockChain).getBlockStore();</span>
<span class="nc" id="L1718">        StoredBlock chainHead = blockChain.getChainHead();</span>
<span class="nc" id="L1719">        Sha256Hash chainHeadHash = chainHead.getHeader().getHash();</span>
        // Did we already make this request? If so, don't do it again.
<span class="nc bnc" id="L1721" title="All 4 branches missed.">        if (Objects.equal(lastGetBlocksBegin, chainHeadHash) &amp;&amp; Objects.equal(lastGetBlocksEnd, toHash)) {</span>
<span class="nc" id="L1722">            log.info(&quot;blockChainDownloadLocked({}): ignoring duplicated request: {}&quot;, toHash, chainHeadHash);</span>
<span class="nc bnc" id="L1723" title="All 2 branches missed.">            for (Sha256Hash hash : pendingBlockDownloads)</span>
<span class="nc" id="L1724">                log.info(&quot;Pending block download: {}&quot;, hash);</span>
<span class="nc" id="L1725">            log.info(Throwables.getStackTraceAsString(new Throwable()));</span>
<span class="nc" id="L1726">            return;</span>
        }
<span class="nc bnc" id="L1728" title="All 2 branches missed.">        if (log.isDebugEnabled())</span>
<span class="nc" id="L1729">            log.debug(&quot;{}: blockChainDownloadLocked({}) current head = {}&quot;,</span>
<span class="nc" id="L1730">                    this, toHash, chainHead.getHeader().getHashAsString());</span>
<span class="nc" id="L1731">        StoredBlock cursor = chainHead;</span>
<span class="nc bnc" id="L1732" title="All 4 branches missed.">        for (int i = 100; cursor != null &amp;&amp; i &gt; 0; i--) {</span>
<span class="nc" id="L1733">            blockLocator.add(cursor.getHeader().getHash());</span>
            try {
<span class="nc" id="L1735">                cursor = cursor.getPrev(store);</span>
<span class="nc" id="L1736">            } catch (BlockStoreException e) {</span>
<span class="nc" id="L1737">                log.error(&quot;Failed to walk the block chain whilst constructing a locator&quot;);</span>
<span class="nc" id="L1738">                throw new RuntimeException(e);</span>
<span class="nc" id="L1739">            }</span>
        }
        // Only add the locator if we didn't already do so. If the chain is &lt; 50 blocks we already reached it.
<span class="nc bnc" id="L1742" title="All 2 branches missed.">        if (cursor != null)</span>
<span class="nc" id="L1743">            blockLocator.add(params.getGenesisBlock().getHash());</span>

        // Record that we requested this range of blocks so we can filter out duplicate requests in the event of a
        // block being solved during chain download.
<span class="nc" id="L1747">        lastGetBlocksBegin = chainHeadHash;</span>
<span class="nc" id="L1748">        lastGetBlocksEnd = toHash;</span>

<span class="nc bnc" id="L1750" title="All 2 branches missed.">        if (downloadBlockBodies) {</span>
<span class="nc" id="L1751">            GetBlocksMessage message = new GetBlocksMessage(params, blockLocator, toHash);</span>
<span class="nc" id="L1752">            sendMessage(message);</span>
<span class="nc" id="L1753">        } else {</span>
            // Downloading headers for a while instead of full blocks.
<span class="nc" id="L1755">            GetHeadersMessage message = new GetHeadersMessage(params, blockLocator, toHash);</span>
<span class="nc" id="L1756">            sendMessage(message);</span>
        }
<span class="nc" id="L1758">    }</span>

    /**
     * Starts an asynchronous download of the block chain. The chain download is deemed to be complete once we've
     * downloaded the same number of blocks that the peer advertised having in its version handshake message.
     */
    public void startBlockChainDownload() {
<span class="fc" id="L1765">        setDownloadData(true);</span>
        // TODO: peer might still have blocks that we don't have, and even have a heavier
        // chain even if the chain block count is lower.
<span class="nc" id="L1768">        final int blocksLeft = getPeerBlockHeightDifference();</span>
<span class="nc bnc" id="L1769" title="All 2 branches missed.">        if (blocksLeft &gt;= 0) {</span>
<span class="nc bnc" id="L1770" title="All 2 branches missed.">            for (final ListenerRegistration&lt;ChainDownloadStartedEventListener&gt; registration : chainDownloadStartedEventListeners) {</span>
<span class="nc" id="L1771">                registration.executor.execute(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="nc" id="L1774">                        registration.listener.onChainDownloadStarted(Peer.this, blocksLeft);</span>
<span class="nc" id="L1775">                    }</span>
                });
<span class="nc" id="L1777">            }</span>
            // When we just want as many blocks as possible, we can set the target hash to zero.
<span class="nc" id="L1779">            lock.lock();</span>
            try {
<span class="nc" id="L1781">                blockChainDownloadLocked(Sha256Hash.ZERO_HASH);</span>
            } finally {
<span class="nc" id="L1783">                lock.unlock();</span>
<span class="nc" id="L1784">            }</span>
        }
<span class="nc" id="L1786">    }</span>

    private class PendingPing {
        // The future that will be invoked when the pong is heard back.
        public SettableFuture&lt;Long&gt; future;
        // The random nonce that lets us tell apart overlapping pings/pongs.
        public final long nonce;
        // Measurement of the time elapsed.
        public final long startTimeMsec;

<span class="nc" id="L1796">        public PendingPing(long nonce) {</span>
<span class="nc" id="L1797">            future = SettableFuture.create();</span>
<span class="nc" id="L1798">            this.nonce = nonce;</span>
<span class="nc" id="L1799">            startTimeMsec = Utils.currentTimeMillis();</span>
<span class="nc" id="L1800">        }</span>

        public void complete() {
<span class="nc bnc" id="L1803" title="All 2 branches missed.">            if (!future.isDone()) {</span>
<span class="nc" id="L1804">                Long elapsed = Utils.currentTimeMillis() - startTimeMsec;</span>
<span class="nc" id="L1805">                Peer.this.addPingTimeData(elapsed);</span>
<span class="nc" id="L1806">                log.debug(&quot;{}: ping time is {} msec&quot;, Peer.this.toString(), elapsed);</span>
<span class="nc" id="L1807">                future.set(elapsed);</span>
            }
<span class="nc" id="L1809">        }</span>
    }

    /** Adds a ping time sample to the averaging window. */
    private void addPingTimeData(long sample) {
<span class="nc" id="L1814">        lastPingTimesLock.lock();</span>
        try {
<span class="nc bnc" id="L1816" title="All 2 branches missed.">            if (lastPingTimes == null) {</span>
<span class="nc" id="L1817">                lastPingTimes = new long[PING_MOVING_AVERAGE_WINDOW];</span>
                // Initialize the averaging window to the first sample.
<span class="nc" id="L1819">                Arrays.fill(lastPingTimes, sample);</span>
            } else {
                // Shift all elements backwards by one.
<span class="nc" id="L1822">                System.arraycopy(lastPingTimes, 1, lastPingTimes, 0, lastPingTimes.length - 1);</span>
                // And append the new sample to the end.
<span class="nc" id="L1824">                lastPingTimes[lastPingTimes.length - 1] = sample;</span>
            }
        } finally {
<span class="nc" id="L1827">            lastPingTimesLock.unlock();</span>
<span class="nc" id="L1828">        }</span>
<span class="nc" id="L1829">    }</span>

    /**
     * Sends the peer a ping message and returns a future that will be invoked when the pong is received back.
     * The future provides a number which is the number of milliseconds elapsed between the ping and the pong.
     * Once the pong is received the value returned by {@link site.mtnsj.core.Peer#getLastPingTime()} is
     * updated.
     * @throws ProtocolException if the peer version is too low to support measurable pings.
     */
    public ListenableFuture&lt;Long&gt; ping() throws ProtocolException {
<span class="nc" id="L1839">        return ping((long) (Math.random() * Long.MAX_VALUE));</span>
    }

    protected ListenableFuture&lt;Long&gt; ping(long nonce) throws ProtocolException {
<span class="nc" id="L1843">        final VersionMessage ver = vPeerVersionMessage;</span>
<span class="nc bnc" id="L1844" title="All 2 branches missed.">        if (!ver.isPingPongSupported())</span>
<span class="nc" id="L1845">            throw new ProtocolException(&quot;Peer version is too low for measurable pings: &quot; + ver);</span>
<span class="nc" id="L1846">        PendingPing pendingPing = new PendingPing(nonce);</span>
<span class="nc" id="L1847">        pendingPings.add(pendingPing);</span>
<span class="nc" id="L1848">        sendMessage(new Ping(pendingPing.nonce));</span>
<span class="nc" id="L1849">        return pendingPing.future;</span>
    }

    /**
     * Returns the elapsed time of the last ping/pong cycle. If {@link site.mtnsj.core.Peer#ping()} has never
     * been called or we did not hear back the &quot;pong&quot; message yet, returns {@link Long#MAX_VALUE}.
     */
    public long getLastPingTime() {
<span class="nc" id="L1857">        lastPingTimesLock.lock();</span>
        try {
<span class="nc bnc" id="L1859" title="All 2 branches missed.">            if (lastPingTimes == null)</span>
<span class="nc" id="L1860">                return Long.MAX_VALUE;</span>
<span class="nc" id="L1861">            return lastPingTimes[lastPingTimes.length - 1];</span>
        } finally {
<span class="nc" id="L1863">            lastPingTimesLock.unlock();</span>
<span class="nc" id="L1864">        }</span>
    }

    /**
     * Returns a moving average of the last N ping/pong cycles. If {@link site.mtnsj.core.Peer#ping()} has never
     * been called or we did not hear back the &quot;pong&quot; message yet, returns {@link Long#MAX_VALUE}. The moving average
     * window is 5 buckets.
     */
    public long getPingTime() {
<span class="nc" id="L1873">        lastPingTimesLock.lock();</span>
        try {
<span class="nc bnc" id="L1875" title="All 2 branches missed.">            if (lastPingTimes == null)</span>
<span class="nc" id="L1876">                return Long.MAX_VALUE;</span>
<span class="nc" id="L1877">            long sum = 0;</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">            for (long i : lastPingTimes) sum += i;</span>
<span class="nc" id="L1879">            return (long)((double) sum / lastPingTimes.length);</span>
        } finally {
<span class="nc" id="L1881">            lastPingTimesLock.unlock();</span>
<span class="nc" id="L1882">        }</span>
    }

    private void processPing(Ping m) {
<span class="nc bnc" id="L1886" title="All 2 branches missed.">        if (m.hasNonce())</span>
<span class="nc" id="L1887">            sendMessage(new Pong(m.getNonce()));</span>
<span class="nc" id="L1888">    }</span>

    protected void processPong(Pong m) {
        // Iterates over a snapshot of the list, so we can run unlocked here.
<span class="nc bnc" id="L1892" title="All 2 branches missed.">        for (PendingPing ping : pendingPings) {</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">            if (m.getNonce() == ping.nonce) {</span>
<span class="nc" id="L1894">                pendingPings.remove(ping);</span>
                // This line may trigger an event listener that re-runs ping().
<span class="nc" id="L1896">                ping.complete();</span>
<span class="nc" id="L1897">                return;</span>
            }
<span class="nc" id="L1899">        }</span>
<span class="nc" id="L1900">    }</span>

    /**
     * Returns the difference between our best chain height and the peers, which can either be positive if we are
     * behind the peer, or negative if the peer is ahead of us.
     */
    public int getPeerBlockHeightDifference() {
<span class="nc" id="L1907">        checkNotNull(blockChain, &quot;No block chain configured&quot;);</span>
        // Chain will overflow signed int blocks in ~41,000 years.
<span class="nc" id="L1909">        int chainHeight = (int) getBestHeight();</span>
        // chainHeight should not be zero/negative because we shouldn't have given the user a Peer that is to another
        // client-mode node, nor should it be unconnected. If that happens it means the user overrode us somewhere or
        // there is a bug in the peer management code.
<span class="nc bnc" id="L1913" title="All 4 branches missed.">        checkState(params.allowEmptyPeerChain() || chainHeight &gt; 0, &quot;Connected to peer with zero/negative chain height&quot;, chainHeight);</span>
<span class="nc" id="L1914">        return chainHeight - blockChain.getBestChainHeight();</span>
    }

    private boolean isNotFoundMessageSupported() {
<span class="nc bnc" id="L1918" title="All 2 branches missed.">        return vPeerVersionMessage.clientVersion &gt;= NotFoundMessage.MIN_PROTOCOL_VERSION;</span>
    }

    /**
     * Returns true if this peer will try and download things it is sent in &quot;inv&quot; messages. Normally you only need
     * one peer to be downloading data. Defaults to true.
     */
    public boolean isDownloadData() {
<span class="nc" id="L1926">        return vDownloadData;</span>
    }

    /**
     * If set to false, the peer won't try and fetch blocks and transactions it hears about. Normally, only one
     * peer should download missing blocks. Defaults to true. Changing this value from false to true may trigger
     * a request to the remote peer for the contents of its memory pool, if Bloom filtering is active.
     */
    public void setDownloadData(boolean downloadData) {
<span class="fc" id="L1935">        this.vDownloadData = downloadData;</span>
<span class="fc" id="L1936">    }</span>

    /** Returns version data announced by the remote peer. */
    public VersionMessage getPeerVersionMessage() {
<span class="fc" id="L1940">        return vPeerVersionMessage;</span>
    }

    /** Returns version data we announce to our remote peers. */
    public VersionMessage getVersionMessage() {
<span class="nc" id="L1945">        return versionMessage;</span>
    }

    /**
     * @return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since.
     */
    public long getBestHeight() {
<span class="nc" id="L1952">        return vPeerVersionMessage.bestHeight + blocksAnnounced.get();</span>
    }

    /**
     * The minimum P2P protocol version that is accepted. If the peer speaks a protocol version lower than this, it
     * will be disconnected.
     * @return true if the peer was disconnected as a result
     */
    public boolean setMinProtocolVersion(int minProtocolVersion) {
<span class="fc" id="L1961">        this.vMinProtocolVersion = minProtocolVersion;</span>
<span class="fc" id="L1962">        VersionMessage ver = getPeerVersionMessage();</span>
<span class="pc bpc" id="L1963" title="3 of 4 branches missed.">        if (ver != null &amp;&amp; ver.clientVersion &lt; minProtocolVersion) {</span>
<span class="nc" id="L1964">            log.warn(&quot;{}: Disconnecting due to new min protocol version {}, got: {}&quot;, this, minProtocolVersion, ver.clientVersion);</span>
<span class="nc" id="L1965">            close();</span>
<span class="nc" id="L1966">            return true;</span>
        }
<span class="fc" id="L1968">        return false;</span>
    }

    /**
     * &lt;p&gt;Sets a Bloom filter on this connection. This will cause the given {@link BloomFilter} object to be sent to the
     * remote peer and if either a memory pool has been set using the constructor or the
     * vDownloadData property is true, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any
     * pending transactions that may be relevant.&lt;/p&gt;
     *
     * &lt;p&gt;The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.
     * This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers
     * and multiple wallets together.&lt;/p&gt;
     *
     * &lt;p&gt;Therefore, you should not use this method if your app uses a {@link PeerGroup}. It is called for you.&lt;/p&gt;
     *
     * &lt;p&gt;If the remote peer doesn't support Bloom filtering, then this call is ignored. Once set you presently cannot
     * unset a filter, though the underlying p2p protocol does support it.&lt;/p&gt;
     */
    public void setBloomFilter(BloomFilter filter) {
<span class="nc" id="L1987">        setBloomFilter(filter, true);</span>
<span class="nc" id="L1988">    }</span>

    /**
     * &lt;p&gt;Sets a Bloom filter on this connection. This will cause the given {@link BloomFilter} object to be sent to the
     * remote peer and if requested, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any
     * pending transactions that may be relevant.&lt;/p&gt;
     *
     * &lt;p&gt;The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.
     * This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers
     * and multiple wallets together.&lt;/p&gt;
     *
     * &lt;p&gt;Therefore, you should not use this method if your app uses a {@link PeerGroup}. It is called for you.&lt;/p&gt;
     *
     * &lt;p&gt;If the remote peer doesn't support Bloom filtering, then this call is ignored. Once set you presently cannot
     * unset a filter, though the underlying p2p protocol does support it.&lt;/p&gt;
     */
    public void setBloomFilter(BloomFilter filter, boolean andQueryMemPool) {
<span class="nc" id="L2005">        checkNotNull(filter, &quot;Clearing filters is not currently supported&quot;);</span>
<span class="nc" id="L2006">        final VersionMessage ver = vPeerVersionMessage;</span>
<span class="nc bnc" id="L2007" title="All 4 branches missed.">        if (ver == null || !ver.isBloomFilteringSupported())</span>
<span class="nc" id="L2008">            return;</span>
<span class="nc" id="L2009">        vBloomFilter = filter;</span>
<span class="nc bnc" id="L2010" title="All 2 branches missed.">        log.debug(&quot;{}: Sending Bloom filter{}&quot;, this, andQueryMemPool ? &quot; and querying mempool&quot; : &quot;&quot;);</span>
<span class="nc" id="L2011">        sendMessage(filter);</span>
<span class="nc bnc" id="L2012" title="All 2 branches missed.">        if (andQueryMemPool)</span>
<span class="nc" id="L2013">            sendMessage(new MemoryPoolMessage());</span>
<span class="nc" id="L2014">        maybeRestartChainDownload();</span>
<span class="nc" id="L2015">    }</span>

    private void maybeRestartChainDownload() {
<span class="nc" id="L2018">        lock.lock();</span>
        try {
<span class="nc bnc" id="L2020" title="All 2 branches missed.">            if (awaitingFreshFilter == null)</span>
<span class="nc" id="L2021">                return;</span>
<span class="nc bnc" id="L2022" title="All 2 branches missed.">            if (!vDownloadData) {</span>
                // This branch should be harmless but I want to know how often it happens in reality.
<span class="nc" id="L2024">                log.warn(&quot;Lost download peer status whilst awaiting fresh filter.&quot;);</span>
<span class="nc" id="L2025">                return;</span>
            }
            // Ping/pong to wait for blocks that are still being streamed to us to finish being downloaded and
            // discarded.
<span class="nc" id="L2029">            ping().addListener(new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L2032">                    lock.lock();</span>
<span class="nc" id="L2033">                    checkNotNull(awaitingFreshFilter);</span>
<span class="nc" id="L2034">                    GetDataMessage getdata = new GetDataMessage(params);</span>
<span class="nc bnc" id="L2035" title="All 2 branches missed.">                    for (Sha256Hash hash : awaitingFreshFilter)</span>
<span class="nc" id="L2036">                        getdata.addFilteredBlock(hash);</span>
<span class="nc" id="L2037">                    awaitingFreshFilter = null;</span>
<span class="nc" id="L2038">                    lock.unlock();</span>

<span class="nc" id="L2040">                    log.info(&quot;Restarting chain download&quot;);</span>
<span class="nc" id="L2041">                    sendMessage(getdata);</span>
                    // TODO: This bizarre ping-after-getdata hack probably isn't necessary.
                    // It's to ensure we know when the end of a filtered block stream of txns is, but we should just be
                    // able to match txns with the merkleblock. Ask Matt why it's written this way.
<span class="nc" id="L2045">                    sendMessage(new Ping((long) (Math.random() * Long.MAX_VALUE)));</span>
<span class="nc" id="L2046">                }</span>
            }, Threading.SAME_THREAD);
        } finally {
<span class="nc" id="L2049">            lock.unlock();</span>
<span class="nc" id="L2050">        }</span>
<span class="nc" id="L2051">    }</span>

    /**
     * Returns the last {@link BloomFilter} set by {@link Peer#setBloomFilter(BloomFilter)}. Bloom filters tell
     * the remote node what transactions to send us, in a compact manner.
     */
    public BloomFilter getBloomFilter() {
<span class="nc" id="L2058">        return vBloomFilter;</span>
    }

    /**
     * Sends a query to the remote peer asking for the unspent transaction outputs (UTXOs) for the given outpoints,
     * with the memory pool included. The result should be treated only as a hint: it's possible for the returned
     * outputs to be fictional and not exist in any transaction, and it's possible for them to be spent the moment
     * after the query returns. &lt;b&gt;Most peers do not support this request. You will need to connect to Bitcoin XT
     * peers if you want this to work.&lt;/b&gt;
     *
     * @throws ProtocolException if this peer doesn't support the protocol.
     */
    public ListenableFuture&lt;UTXOsMessage&gt; getUTXOs(List&lt;TransactionOutPoint&gt; outPoints) {
<span class="nc" id="L2071">        return getUTXOs(outPoints, true);</span>
    }

    /**
     * Sends a query to the remote peer asking for the unspent transaction outputs (UTXOs) for the given outpoints.
     * The result should be treated only as a hint: it's possible for the returned outputs to be fictional and not
     * exist in any transaction, and it's possible for them to be spent the moment after the query returns.
     * &lt;b&gt;Most peers do not support this request. You will need to connect to Bitcoin XT peers if you want
     * this to work.&lt;/b&gt;
     *
     * @param includeMempool If true (the default) the results take into account the contents of the memory pool too.
     * @throws ProtocolException if this peer doesn't support the protocol.
     */
    public ListenableFuture&lt;UTXOsMessage&gt; getUTXOs(List&lt;TransactionOutPoint&gt; outPoints, boolean includeMempool) {
<span class="nc" id="L2085">        lock.lock();</span>
        try {
<span class="nc" id="L2087">            VersionMessage peerVer = getPeerVersionMessage();</span>
<span class="nc bnc" id="L2088" title="All 2 branches missed.">            if (peerVer.clientVersion &lt; GetUTXOsMessage.MIN_PROTOCOL_VERSION)</span>
<span class="nc" id="L2089">                throw new ProtocolException(&quot;Peer does not support getutxos protocol version&quot;);</span>
<span class="nc bnc" id="L2090" title="All 2 branches missed.">            if ((peerVer.localServices &amp; GetUTXOsMessage.SERVICE_FLAGS_REQUIRED) != GetUTXOsMessage.SERVICE_FLAGS_REQUIRED)</span>
<span class="nc" id="L2091">                throw new ProtocolException(&quot;Peer does not support getutxos protocol flag: find Bitcoin XT nodes.&quot;);</span>
<span class="nc" id="L2092">            SettableFuture&lt;UTXOsMessage&gt; future = SettableFuture.create();</span>
            // Add to the list of in flight requests.
<span class="nc bnc" id="L2094" title="All 2 branches missed.">            if (getutxoFutures == null)</span>
<span class="nc" id="L2095">                getutxoFutures = new LinkedList&lt;SettableFuture&lt;UTXOsMessage&gt;&gt;();</span>
<span class="nc" id="L2096">            getutxoFutures.add(future);</span>
<span class="nc" id="L2097">            sendMessage(new GetUTXOsMessage(params, outPoints, includeMempool));</span>
<span class="nc" id="L2098">            return future;</span>
        } finally {
<span class="nc" id="L2100">            lock.unlock();</span>
<span class="nc" id="L2101">        }</span>
    }

    /**
     * Returns true if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     * before handing the transaction off to the wallet. The wallet can do risk analysis on pending/recent transactions
     * to try and discover if a pending tx might be at risk of double spending.
     */
    public boolean isDownloadTxDependencies() {
<span class="nc bnc" id="L2110" title="All 2 branches missed.">        return vDownloadTxDependencyDepth &gt; 0;</span>
    }

    /**
     * Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     * before handing the transaction off to the wallet. The wallet can do risk analysis on pending/recent transactions
     * to try and discover if a pending tx might be at risk of double spending.
     */
    public void setDownloadTxDependencies(boolean enable) {
<span class="nc bnc" id="L2119" title="All 2 branches missed.">        vDownloadTxDependencyDepth = enable ? Integer.MAX_VALUE : 0;</span>
<span class="nc" id="L2120">    }</span>

    /**
     * Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     * before handing the transaction off to the wallet. The wallet can do risk analysis on pending/recent transactions
     * to try and discover if a pending tx might be at risk of double spending.
     */
    public void setDownloadTxDependencies(int depth) {
<span class="nc" id="L2128">        vDownloadTxDependencyDepth = depth;</span>
<span class="nc" id="L2129">    }</span>

    //Dash Specific Code
    public void notifyLock(Transaction tx)
    {
<span class="nc bnc" id="L2134" title="All 2 branches missed.">        for(Wallet wallet : wallets)</span>
        {
<span class="nc bnc" id="L2136" title="All 2 branches missed.">            if(wallet.isTransactionRelevant(tx)){</span>
<span class="nc" id="L2137">                wallet.receiveLock(tx);</span>
            }
<span class="nc" id="L2139">        }</span>
<span class="nc" id="L2140">    }</span>
<span class="fc" id="L2141">    ArrayList&lt;String&gt; vecRequestsFulfilled = new ArrayList&lt;String&gt;();</span>

    boolean hasFulfilledRequest(String strRequest)
    {
        //BOOST_FOREACH(std::string&amp; type, vecRequestsFulfilled)
<span class="nc bnc" id="L2146" title="All 2 branches missed.">        for(String type: vecRequestsFulfilled)</span>
        {
<span class="nc bnc" id="L2148" title="All 2 branches missed.">            if(type.equals(strRequest)) return true;</span>
<span class="nc" id="L2149">        }</span>
<span class="nc" id="L2150">        return false;</span>
    }

    void clearFulfilledRequest(String strRequest)
    {
        //std::vector&lt;std::string&gt;::iterator it = vecRequestsFulfilled.begin();
<span class="nc" id="L2156">        Iterator&lt;String&gt; it = vecRequestsFulfilled.iterator();</span>
<span class="nc bnc" id="L2157" title="All 2 branches missed.">        while(it.hasNext()){</span>
<span class="nc bnc" id="L2158" title="All 2 branches missed.">            if(it.next().equals(strRequest)) {</span>
<span class="nc" id="L2159">                it.remove();</span>
<span class="nc" id="L2160">                return;</span>
            }
        }
<span class="nc" id="L2163">    }</span>

    void fulfilledRequest(String strRequest)
    {
<span class="nc bnc" id="L2167" title="All 2 branches missed.">        if(hasFulfilledRequest(strRequest)) return;</span>
<span class="nc" id="L2168">        vecRequestsFulfilled.add(strRequest);</span>
<span class="nc" id="L2169">    }</span>

<span class="fc" id="L2171">    boolean fDarkSendMaster = false;</span>
<span class="nc" id="L2172">    public boolean isDarkSendMaster() { return fDarkSendMaster; }</span>

<span class="fc" id="L2174">    int masternodeListCount = -1;</span>
<span class="nc" id="L2175">    public int getMasternodeListCount() { return masternodeListCount; }</span>
<span class="nc" id="L2176">    public void setMasternodeListCount(int count) { masternodeListCount = count; }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>