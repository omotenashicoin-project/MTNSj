<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Block.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mtnsj</a> &gt; <a href="index.source.html" class="el_package">site.mtnsj.core</a> &gt; <span class="el_source">Block.java</span></div><h1>Block.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2011 Google Inc.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package site.mtnsj.core;

import com.google.common.annotations.*;
import com.google.common.base.*;
import com.google.common.collect.*;
import site.mtnsj.script.*;
import org.slf4j.*;
import com.hashengineering.crypto.Skein;
import javax.annotation.*;
import java.io.*;
import java.math.*;
import java.util.*;

import static site.mtnsj.core.Coin.*;
import static site.mtnsj.core.Sha256Hash.*;

//import com.sun.xml.internal.ws.api.config.management.policy.ManagedServiceAssertion;

/**
 * &lt;p&gt;A block is a group of transactions, and is one of the fundamental data structures of the Bitcoin system.
 * It records a set of {@link Transaction}s together with some data that links it into a place in the global block
 * chain, and proves that a difficult calculation was done over its contents. See
 * &lt;a href=&quot;http://www.bitcoin.org/bitcoin.pdf&quot;&gt;the Bitcoin technical paper&lt;/a&gt; for
 * more detail on blocks. &lt;p/&gt;
 *
 * &lt;p&gt;To get a block, you can either build one from the raw bytes you can get from another implementation, or request one
 * specifically using {@link Peer#getBlock(Sha256Hash)}, or grab one from a downloaded {@link BlockChain}.&lt;/p&gt;
 * 
 * &lt;p&gt;Instances of this class are not safe for use by multiple threads.&lt;/p&gt;
 */
public class Block extends Message {

    /**
     * Flags used to control which elements of block validation are done on
     * received blocks.
     */
<span class="pc" id="L54">    public enum VerifyFlag {</span>
        /** Check that block height is in coinbase transaction (BIP 34). */
<span class="fc" id="L56">        HEIGHT_IN_COINBASE</span>
    }

<span class="fc" id="L59">    private static final Logger log = LoggerFactory.getLogger(Block.class);</span>

    /** How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. */
    public static final int HEADER_SIZE = 80;
    /*** Zerocoin blocks header size */
    public static final int ZEROCOIN_HEADER_SIZE = 112;

    static final long ALLOWED_TIME_DRIFT = 2 * 60 * 60; // Same value as Bitcoin Core.

    /**
     * Zerocoin block version
     * Includes an accumulator on the block.
     */
    // kaniTODO do not support zero coin
    public static final long ZEROCOIN_BLOCK_VERSION = 4;

    public static final boolean ACTIVATE_ZEROCOIN = false; 

    /**
     * A constant shared by the entire network: how large in bytes a block is allowed to be. One day we may have to
     * upgrade everyone to change this, so Bitcoin can continue to grow. For now it exists as an anti-DoS measure to
     * avoid somebody creating a titanically huge but valid block and forcing everyone to download/store it forever.
     */
    public static final int MAX_BLOCK_SIZE = CoinDefinition.MAX_BLOCK_SIZE; //1 * 1000 * 1000;
    /**
     * A &quot;sigop&quot; is a signature verification operation. Because they're expensive we also impose a separate limit on
     * the number in a block to prevent somebody mining a huge block that has way more sigops than normal, so is very
     * expensive/slow to verify.
     */
    public static final int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE / 50;

    /** A value for difficultyTarget (nBits) that allows half of all possible hash solutions. Used in unit testing. */
    public static final long EASIEST_DIFFICULTY_TARGET = 0x207fFFFFL;

    /** Value to use if the block height is unknown */
    public static final int BLOCK_HEIGHT_UNKNOWN = -1;
    /** Height of the first block */
    public static final int BLOCK_HEIGHT_GENESIS = 0;

    public static final long BLOCK_VERSION_GENESIS = 1;
    /** Block version introduced in BIP 34: Height in coinbase */
    public static final long BLOCK_VERSION_BIP34 = 2;
    /** Block version introduced in BIP 66: Strict DER signatures */
    public static final long BLOCK_VERSION_BIP66 = 3;
    /** Block version introduced in BIP 65: OP_CHECKLOCKTIMEVERIFY */
    public static final long BLOCK_VERSION_BIP65 = 4;

    // Fields defined as part of the protocol format.
    private long version;
    private Sha256Hash prevBlockHash;
    private Sha256Hash merkleRoot;
    private long time;
    private long difficultyTarget; // &quot;nBits&quot;
    private long nonce;

    // TODO: Get rid of all the direct accesses to this field. It's a long-since unnecessary holdover from the Dalvik days.
    /** If null, it means this object holds only the headers. */
    @Nullable List&lt;Transaction&gt; transactions;

    /** Stores the hash of the block. If null, getHash() will recalculate it. */
    private Sha256Hash hash;

    /**
     * Zerocoin accumulator
     */
    private Sha256Hash zeroCoinAccumulator;

    protected boolean headerBytesValid;
    protected boolean transactionBytesValid;

    // Blocks can be encoded in a way that will use more bytes than is optimal (due to VarInts having multiple encodings)
    // MAX_BLOCK_SIZE must be compared to the optimal encoding, not the actual encoding, so when parsing, we keep track
    // of the size of the ideal encoding in addition to the actual message size (which Message needs)
    protected int optimalEncodingMessageSize;

    /** Special case constructor, used for the genesis node, cloneAsHeader and unit tests. */
    Block(NetworkParameters params, long setVersion) {
<span class="fc" id="L136">        super(params);</span>
        // Set up a few basic things. We are not complete after this though.
<span class="fc" id="L138">        version = setVersion;</span>
<span class="fc" id="L139">        difficultyTarget = 0x1e0fffffL;</span>
<span class="fc" id="L140">        time = System.currentTimeMillis() / 1000;</span>
<span class="fc" id="L141">        prevBlockHash = Sha256Hash.ZERO_HASH;</span>

<span class="fc" id="L143">        length = getHeaderSize();</span>
<span class="fc" id="L144">    }</span>

    /**
     * Constructs a block object from the Bitcoin wire format.
     * @deprecated Use {@link BitcoinSerializer#makeBlock(byte[])} instead.
     */
    @Deprecated
    public Block(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
<span class="nc" id="L152">        super(params, payloadBytes, 0, params.getDefaultSerializer(), payloadBytes.length);</span>
<span class="nc" id="L153">    }</span>

    /**
     * Construct a block object from the Bitcoin wire format.
     * @param params NetworkParameters object.
     * @param payloadBytes the payload to extract the block from.
     * @param serializer the serializer to use for this message.
     * @param length The length of message if known.  Usually this is provided when deserializing of the wire
     * as the length will be provided as part of the header.  If unknown then set to Message.UNKNOWN_LENGTH
     * @throws ProtocolException
     */
    public Block(NetworkParameters params, byte[] payloadBytes, MessageSerializer serializer, int length)
            throws ProtocolException {
<span class="nc" id="L166">        super(params, payloadBytes, 0, serializer, length);</span>
<span class="nc" id="L167">    }</span>

    /**
     * Construct a block object from the Bitcoin wire format.
     * @param params NetworkParameters object.
     * @param payloadBytes the payload to extract the block from.
     * @param offset The location of the first payload byte within the array.
     * @param serializer the serializer to use for this message.
     * @param length The length of message if known.  Usually this is provided when deserializing of the wire
     * as the length will be provided as part of the header.  If unknown then set to Message.UNKNOWN_LENGTH
     * @throws ProtocolException
     */
    public Block(NetworkParameters params, byte[] payloadBytes, int offset, MessageSerializer serializer, int length)
            throws ProtocolException {
<span class="fc" id="L181">        super(params, payloadBytes, offset, serializer, length);</span>
<span class="fc" id="L182">    }</span>

    /**
     * Construct a block object from the Bitcoin wire format. Used in the case of a block
     * contained within another message (i.e. for AuxPoW header).
     *
     * @param params NetworkParameters object.
     * @param payloadBytes Bitcoin protocol formatted byte array containing message content.
     * @param offset The location of the first payload byte within the array.
     * @param parent The message element which contains this block, maybe null for no parent.
     * @param serializer the serializer to use for this block.
     * @param length The length of message if known.  Usually this is provided when deserializing of the wire
     * as the length will be provided as part of the header.  If unknown then set to Message.UNKNOWN_LENGTH
     * @throws ProtocolException
     */
    public Block(NetworkParameters params, byte[] payloadBytes, int offset, @Nullable Message parent, MessageSerializer serializer, int length)
            throws ProtocolException {
        // TODO: Keep the parent
<span class="nc" id="L200">        super(params, payloadBytes, offset, serializer, length);</span>
<span class="nc" id="L201">    }</span>

    /**
     * Construct a block initialized with all the given fields.
     * @param params Which network the block is for.
     * @param version This should usually be set to 1 or 2, depending on if the height is in the coinbase input.
     * @param prevBlockHash Reference to previous block in the chain or {@link Sha256Hash#ZERO_HASH} if genesis.
     * @param merkleRoot The root of the merkle tree formed by the transactions.
     * @param time UNIX time when the block was mined.
     * @param difficultyTarget Number which this block hashes lower than.
     * @param nonce Arbitrary number to make the block hash lower than the target.
     * @param transactions List of transactions including the coinbase.
     */
    public Block(NetworkParameters params, long version, Sha256Hash prevBlockHash, Sha256Hash merkleRoot, long time,
                 long difficultyTarget, long nonce, List&lt;Transaction&gt; transactions) {
<span class="fc" id="L216">        super(params);</span>
<span class="fc" id="L217">        this.version = version;</span>
<span class="fc" id="L218">        this.prevBlockHash = prevBlockHash;</span>
<span class="fc" id="L219">        this.merkleRoot = merkleRoot;</span>
<span class="fc" id="L220">        this.time = time;</span>
<span class="fc" id="L221">        this.difficultyTarget = difficultyTarget;</span>
<span class="fc" id="L222">        this.nonce = nonce;</span>
<span class="fc" id="L223">        this.transactions = new LinkedList&lt;Transaction&gt;();</span>
<span class="fc" id="L224">        this.transactions.addAll(transactions);</span>
<span class="fc" id="L225">    }</span>


    /**
     * &lt;p&gt;A utility method that calculates how much new Bitcoin would be created by the block at the given height.
     * The inflation of Bitcoin is predictable and drops roughly every 4 years (210,000 blocks). At the dawn of
     * the system it was 50 coins per block, in late 2012 it went to 25 coins per block, and so on. The size of
     * a coinbase transaction is inflation plus fees.&lt;/p&gt;
     *
     * &lt;p&gt;The half-life is controlled by {@link site.mtnsj.core.NetworkParameters#getSubsidyDecreaseBlockCount()}.
     * &lt;/p&gt;
     */

    public Coin getBlockInflation(int height) {
        //return Utils.toNanoCoins(50, 0).shiftRight(height / context.getSubsidyDecreaseBlockCount());
<span class="fc" id="L240">        return /*Utils.toNanoCoins(*/CoinDefinition.GetBlockReward(height)/*, 0)*/;</span>
    }

    /**
     * Parse transactions from the block.
     * 
     * @param transactionsOffset Offset of the transactions within the block.
     * Useful for non-Bitcoin chains where the block header may not be a fixed
     * size.
     */
    protected void parseTransactions(final int transactionsOffset) throws ProtocolException {
<span class="fc" id="L251">        cursor = transactionsOffset;</span>
<span class="fc" id="L252">        optimalEncodingMessageSize = getHeaderSize();</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">        if (payload.length == cursor) {</span>
            // This message is just a header, it has no transactions.
<span class="fc" id="L255">            transactionBytesValid = false;</span>
<span class="fc" id="L256">            return;</span>
        }

<span class="fc" id="L259">        int numTransactions = (int) readVarInt();</span>
<span class="fc" id="L260">        optimalEncodingMessageSize += VarInt.sizeOf(numTransactions);</span>
<span class="fc" id="L261">        transactions = new ArrayList&lt;Transaction&gt;(numTransactions);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">        for (int i = 0; i &lt; numTransactions; i++) {</span>
<span class="fc" id="L263">            Transaction tx = new Transaction(params, payload, cursor, this, serializer, UNKNOWN_LENGTH);</span>
            // Label the transaction as coming from the P2P network, so code that cares where we first saw it knows.
<span class="fc" id="L265">            tx.getConfidence().setSource(TransactionConfidence.Source.NETWORK);</span>
<span class="fc" id="L266">            transactions.add(tx);</span>
<span class="fc" id="L267">            cursor += tx.getMessageSize();</span>
<span class="fc" id="L268">            optimalEncodingMessageSize += tx.getOptimalEncodingMessageSize();</span>
        }
<span class="fc" id="L270">        transactionBytesValid = serializer.isParseRetainMode();</span>
<span class="fc" id="L271">    }</span>

    private static final long START_MASTERNODE_PAYMENTS_1 = 1401033600L; //Sun, 25 May 2014 16:00:00 GMT
    private static final long START_MASTERNODE_PAYMENTS_STOP_1 = 1401134533L; // Mon, 26 May 2014 20:02:13 GMT

    private static final long START_MASTERNODE_PAYMENTS = 1403728576L; //Fri, 20 Jun 2014 16:00:00 GMT
    //private static final long START_MASTERNODE_PAYMENTS_STOP = ?

    private static final long START_MASTERNODE_PAYMENTS_TESTNET_1 = 1401757793;
    private static final long START_MASTERNODE_PAYMENTS_TESTNET = 1403568776L;

    @Override
    protected void parse() throws ProtocolException {
        try {
            // header
<span class="fc" id="L286">            cursor = offset;</span>
<span class="fc" id="L287">            version = readUint32();</span>
            //System.out.println(&quot;parse version: &quot;+version);
<span class="fc" id="L289">            prevBlockHash = readHash();</span>
            //System.out.println(&quot;parse prevBlockHash: &quot;+prevBlockHash);
<span class="fc" id="L291">            merkleRoot = readHash();</span>
            //System.out.println(&quot;parse merkleRoot: &quot;+merkleRoot);
<span class="fc" id="L293">            time = readUint32();</span>
            //System.out.println(&quot;parse time: &quot;+time);
<span class="fc" id="L295">            difficultyTarget = readUint32();</span>
            //System.out.println(&quot;parse difficultyTarget: &quot;+difficultyTarget);
<span class="fc" id="L297">            nonce = readUint32();</span>
            //System.out.println(&quot;parse nonce: &quot;+nonce);
<span class="fc" id="L299">            int headerSize = getHeaderSize();</span>
<span class="pc bpc" id="L300" title="3 of 4 branches missed.">            if (isZerocoin() &amp;&amp; length &gt;= ZEROCOIN_HEADER_SIZE) { // todoKANI do not support Zerocoin</span>
                // accumulator
<span class="nc" id="L302">                zeroCoinAccumulator = readHash(true);</span>
                //System.out.println(&quot;parse zeroCoinAccumulator: &quot;+zeroCoinAccumulator);
                //System.out.println(&quot;offset: &quot;+offset);
                //System.out.println(&quot;cursor: &quot;+cursor);
                //System.out.println(&quot;payload size: &quot;+payload.length);
                //System.out.println(&quot;Hash payload &quot;+Arrays.toString(copy));
               // hash = Sha256Hash.wrapReversed(Sha256Hash.hashTwice(copy));
               // System.out.println(&quot;zerocoin hash parsed: &quot;+hash.toString());
<span class="nc" id="L310">                hash = Sha256Hash.wrapReversed(Sha256Hash.hashTwice(payload, offset, cursor - offset));</span>
                //System.out.println(&quot;zerocoin test hash parsed 2: &quot;+hash.toString());

                //hash = Sha256Hash.wrapReversed(Sha256Hash.hashTwice(payload, offset, cursor - offset));
            } else {
<span class="fc" id="L315">                hash = Sha256Hash.wrapReversed(Skein.digest(payload, offset, cursor - offset));</span>
                //System.out.println(&quot;hash parsed: &quot;+hash.toString());
            }

<span class="fc" id="L319">            headerBytesValid = serializer.isParseRetainMode();</span>

            // transactions
<span class="fc" id="L322">            parseTransactions(offset + headerSize);</span>
<span class="fc" id="L323">            length = cursor - offset;</span>
<span class="nc" id="L324">        }catch (Exception e){</span>
<span class="nc" id="L325">            e.printStackTrace();</span>
<span class="nc" id="L326">            throw new RuntimeException(e);</span>
<span class="fc" id="L327">        }</span>
<span class="fc" id="L328">    }</span>
    
    public int getOptimalEncodingMessageSize() {
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (optimalEncodingMessageSize != 0)</span>
<span class="fc" id="L332">            return optimalEncodingMessageSize;</span>
<span class="fc" id="L333">        optimalEncodingMessageSize = bitcoinSerialize().length;</span>
<span class="fc" id="L334">        return optimalEncodingMessageSize;</span>
    }

    // default for testing
    void writeHeader(OutputStream stream) throws IOException {
<span class="fc" id="L339">        int headerSize = getHeaderSize();</span>
        //System.out.println(&quot;writeHeader header size: &quot;+headerSize);
        // try for cached write first
<span class="pc bpc" id="L342" title="5 of 6 branches missed.">        if (headerBytesValid &amp;&amp; payload != null &amp;&amp; payload.length &gt;= offset + headerSize) {</span>
<span class="nc" id="L343">            stream.write(payload, offset, headerSize);</span>
<span class="nc" id="L344">            return;</span>
        }
        // fall back to manual write
<span class="fc" id="L347">        Utils.uint32ToByteStreamLE(version, stream);</span>
        //System.out.println(&quot;writeHeader version: &quot;+version);
<span class="fc" id="L349">        stream.write(prevBlockHash.getReversedBytes());</span>
        //System.out.println(&quot;writeHeader prevBlockHash: &quot;+prevBlockHash);
<span class="fc" id="L351">        stream.write(getMerkleRoot().getReversedBytes());</span>
        //System.out.println(&quot;writeHeader merkle root: &quot;+getMerkleRoot());
<span class="fc" id="L353">        Utils.uint32ToByteStreamLE(time, stream);</span>
        //System.out.println(&quot;writeHeader time: &quot;+time);
<span class="fc" id="L355">        Utils.uint32ToByteStreamLE(difficultyTarget, stream);</span>
        //System.out.println(&quot;writeHeader difficultyTarget: &quot;+difficultyTarget);
<span class="fc" id="L357">        Utils.uint32ToByteStreamLE(nonce, stream);</span>
        //System.out.println(&quot;writeHeader nonce: &quot;+nonce);
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (isZerocoin()){</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">            byte[] accumulator = (zeroCoinAccumulator!=null)?zeroCoinAccumulator.getReversedBytes():new byte[32];</span>
<span class="nc" id="L361">            stream.write(accumulator);</span>
            //System.out.println(&quot;writeHeader zeroCoinAccumulator: &quot;+nonce);
        }
<span class="fc" id="L364">    }</span>

    public int getHeaderSize(){
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">        return isZerocoin()?ZEROCOIN_HEADER_SIZE:HEADER_SIZE;</span>
    }

    private void writeTransactions(OutputStream stream) throws IOException {
        // check for no transaction conditions first
        // must be a more efficient way to do this but I'm tired atm.
<span class="fc bfc" id="L373" title="All 2 branches covered.">        if (transactions == null) {</span>
<span class="fc" id="L374">            return;</span>
        }
<span class="fc" id="L376">        int headerSize = getHeaderSize();</span>
        // confirmed we must have transactions either cached or as objects.
<span class="pc bpc" id="L378" title="5 of 6 branches missed.">        if (transactionBytesValid &amp;&amp; payload != null &amp;&amp; payload.length &gt;= offset + length) {</span>
<span class="nc" id="L379">            stream.write(payload, offset + headerSize, length - headerSize);</span>
<span class="nc" id="L380">            return;</span>
        }

<span class="pc bpc" id="L383" title="1 of 2 branches missed.">        if (transactions != null) {</span>
<span class="fc" id="L384">            stream.write(new VarInt(transactions.size()).encode());</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">            for (Transaction tx : transactions) {</span>
<span class="fc" id="L386">                tx.bitcoinSerialize(stream);</span>
<span class="fc" id="L387">            }</span>
        }
        //writeMasterNodeVotes(stream);
<span class="fc" id="L390">    }</span>
    /**
     * Special handling to check if we have a valid byte array for both header
     * and transactions
     *
     * @throws IOException
     */
    @Override
    public byte[] bitcoinSerialize() {
        // we have completely cached byte array.
<span class="pc bpc" id="L400" title="1 of 4 branches missed.">        if (headerBytesValid &amp;&amp; transactionBytesValid) {</span>
<span class="fc" id="L401">            Preconditions.checkNotNull(payload, &quot;Bytes should never be null if headerBytesValid &amp;&amp; transactionBytesValid&quot;);</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">            if (length == payload.length) {</span>
<span class="fc" id="L403">                return payload;</span>
            } else {
                // byte array is offset so copy out the correct range.
<span class="nc" id="L406">                byte[] buf = new byte[length];</span>
<span class="nc" id="L407">                System.arraycopy(payload, offset, buf, 0, length);</span>
<span class="nc" id="L408">                return buf;</span>
            }
        }

        // At least one of the two cacheable components is invalid
        // so fall back to stream write since we can't be sure of the length.
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        ByteArrayOutputStream stream = new UnsafeByteArrayOutputStream(length == UNKNOWN_LENGTH ? getHeaderSize() + guessTransactionsLength() : length);</span>
        try {
<span class="fc" id="L416">            writeHeader(stream);</span>
<span class="fc" id="L417">            writeTransactions(stream);</span>
<span class="nc" id="L418">        } catch (IOException e) {</span>
            // Cannot happen, we are serializing to a memory stream.
<span class="fc" id="L420">        }</span>
<span class="fc" id="L421">        return stream.toByteArray();</span>
    }

    @Override
    protected void bitcoinSerializeToStream(OutputStream stream) throws IOException {
<span class="fc" id="L426">        writeHeader(stream);</span>
        // We may only have enough data to write the header.
<span class="fc" id="L428">        writeTransactions(stream);</span>
<span class="fc" id="L429">    }</span>

    /**
     * Provides a reasonable guess at the byte length of the transactions part of the block.
     * The returned value will be accurate in 99% of cases and in those cases where not will probably slightly
     * oversize.
     *
     * This is used to preallocate the underlying byte array for a ByteArrayOutputStream.  If the size is under the
     * real value the only penalty is resizing of the underlying byte array.
     */
    private int guessTransactionsLength() {
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (transactionBytesValid)</span>
<span class="nc" id="L441">            return payload.length - getHeaderSize();</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">        if (transactions == null)</span>
<span class="nc" id="L443">            return 0;</span>
<span class="nc" id="L444">        int len = VarInt.sizeOf(transactions.size());</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">        for (Transaction tx : transactions) {</span>
            // 255 is just a guess at an average tx length
<span class="nc bnc" id="L447" title="All 2 branches missed.">            len += tx.length == UNKNOWN_LENGTH ? 255 : tx.length;</span>
<span class="nc" id="L448">        }</span>
<span class="nc" id="L449">        return len;</span>
    }

    @Override
    protected void unCache() {
        // Since we have alternate uncache methods to use internally this will only ever be called by a child
        // transaction so we only need to invalidate that part of the cache.
<span class="fc" id="L456">        unCacheTransactions();</span>
<span class="fc" id="L457">    }</span>

    private void unCacheHeader() {
<span class="fc" id="L460">        headerBytesValid = false;</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">        if (!transactionBytesValid)</span>
<span class="fc" id="L462">            payload = null;</span>
<span class="fc" id="L463">        hash = null;</span>
<span class="fc" id="L464">    }</span>

    private void unCacheTransactions() {
<span class="fc" id="L467">        transactionBytesValid = false;</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        if (!headerBytesValid)</span>
<span class="fc" id="L469">            payload = null;</span>
        // Current implementation has to uncache headers as well as any change to a tx will alter the merkle root. In
        // future we can go more granular and cache merkle root separately so rest of the header does not need to be
        // rewritten.
<span class="fc" id="L473">        unCacheHeader();</span>
        // Clear merkleRoot last as it may end up being parsed during unCacheHeader().
<span class="fc" id="L475">        merkleRoot = null;</span>
<span class="fc" id="L476">    }</span>

    /**
     * Calculates the block hash by serializing the block and hashing the
     * resulting bytes.
     */
    private Sha256Hash calculateHash() {
        try {
<span class="fc" id="L484">            ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(getHeaderSize());</span>
<span class="fc" id="L485">            writeHeader(bos);</span>
<span class="fc" id="L486">            return Sha256Hash.wrap(Utils.reverseBytes(Skein.digest(bos.toByteArray())));</span>
<span class="nc" id="L487">        } catch (IOException e) {</span>
<span class="nc" id="L488">            throw new RuntimeException(e); // Cannot happen.</span>
        }
    }

    /**
     * Returns the hash of the block (which for a valid, solved block should be below the target) in the form seen on
     * the block explorer. If you call this on block 1 in the mainnet chain
     * you will get &quot;00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048&quot;.
     */
    public String getHashAsString() {
<span class="fc" id="L498">        return getHash().toString();</span>
    }


    public Sha256Hash getAccumulator() {
<span class="nc" id="L503">        return zeroCoinAccumulator;</span>
    }

    /**
     * Returns the hash of the block (which for a valid, solved block should be
     * below the target). Big endian.
     */
    @Override
    public Sha256Hash getHash() {
<span class="fc bfc" id="L512" title="All 2 branches covered.">        if (hash == null) {</span>
<span class="fc" id="L513">            hash = calculateHash();</span>
        }
<span class="fc" id="L515">        return hash;</span>
    }

    public boolean isZerocoin() {
        if (!ACTIVATE_ZEROCOIN) {
<span class="fc" id="L520">            return false;</span>
        }else {
            return version == ZEROCOIN_BLOCK_VERSION;
        }
    }

    public static boolean isZerocoinHeight(NetworkParameters networkParameters,long height) {
        if (!ACTIVATE_ZEROCOIN) {
<span class="nc" id="L528">            return false;</span>
        }else
            return height&gt;=networkParameters.getZerocoinStartedHeight();
    }

    public static int getHeaderSizeByVersion(long version){
        if (!ACTIVATE_ZEROCOIN) {
<span class="nc" id="L535">            return Block.HEADER_SIZE;</span>
        }else {
            return Block.ZEROCOIN_BLOCK_VERSION == version ? ZEROCOIN_HEADER_SIZE : HEADER_SIZE;
        }
    }

    public static int getHeaderSize(NetworkParameters params,long height){
        if (!ACTIVATE_ZEROCOIN) {
<span class="fc" id="L543">            return Block.HEADER_SIZE;</span>
        }else
            return Block.isZerocoinHeight(params,height)?Block.ZEROCOIN_HEADER_SIZE:Block.HEADER_SIZE;
    }

    /**
     * The number that is one greater than the largest representable SHA-256
     * hash.
     */
<span class="fc" id="L552">    private static BigInteger LARGEST_HASH = BigInteger.ONE.shiftLeft(256);</span>

    /**
     * Returns the work represented by this block.&lt;p&gt;
     *
     * Work is defined as the number of tries needed to solve a block in the
     * average case. Consider a difficulty target that covers 5% of all possible
     * hash values. Then the work of the block will be 20. As the target gets
     * lower, the amount of work goes up.
     */
    public BigInteger getWork() throws VerificationException {
<span class="fc" id="L563">        BigInteger target = getDifficultyTargetAsInteger();</span>
<span class="fc" id="L564">        return LARGEST_HASH.divide(target.add(BigInteger.ONE));</span>
    }

    /** Returns a copy of the block, but without any transactions. */
    public Block cloneAsHeader() {
<span class="fc" id="L569">        Block block = new Block(params, BLOCK_VERSION_GENESIS);</span>
<span class="fc" id="L570">        copyBitcoinHeaderTo(block);</span>
<span class="fc" id="L571">        return block;</span>
    }

    /** Copy the block without transactions into the provided empty block. */
    protected final void copyBitcoinHeaderTo(final Block block) {
<span class="fc" id="L576">        block.nonce = nonce;</span>
<span class="fc" id="L577">        block.prevBlockHash = prevBlockHash;</span>
<span class="fc" id="L578">        block.merkleRoot = getMerkleRoot();</span>
<span class="fc" id="L579">        block.version = version;</span>
<span class="fc" id="L580">        block.time = time;</span>
<span class="fc" id="L581">        block.difficultyTarget = difficultyTarget;</span>
<span class="fc" id="L582">        block.zeroCoinAccumulator = zeroCoinAccumulator;</span>
<span class="fc" id="L583">        block.transactions = null;</span>
<span class="fc" id="L584">        block.hash = getHash();</span>
<span class="fc" id="L585">    }</span>

    /**
     * Returns a multi-line string containing a description of the contents of
     * the block. Use for debugging purposes only.
     */
    @Override
    public String toString() {
<span class="fc" id="L593">        StringBuilder s = new StringBuilder();</span>
<span class="fc" id="L594">        s.append(&quot; block: \n&quot;);</span>
<span class="fc" id="L595">        s.append(&quot;   hash: &quot;).append(getHashAsString()).append('\n');</span>
<span class="fc" id="L596">        s.append(&quot;   version: &quot;).append(version);</span>
<span class="pc bpc" id="L597" title="1 of 4 branches missed.">        String bips = Joiner.on(&quot;, &quot;).skipNulls().join(isBIP34() ? &quot;BIP34&quot; : null, isBIP66() ? &quot;BIP66&quot; : null,</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">                isBIP65() ? &quot;BIP65&quot; : null);</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">        if (!bips.isEmpty())</span>
<span class="fc" id="L600">            s.append(&quot; (&quot;).append(bips).append(')');</span>
<span class="fc" id="L601">        s.append('\n');</span>
<span class="fc" id="L602">        s.append(&quot;   previous block: &quot;).append(getPrevBlockHash()).append(&quot;\n&quot;);</span>
<span class="fc" id="L603">        s.append(&quot;   merkle root: &quot;).append(getMerkleRoot()).append(&quot;\n&quot;);</span>
<span class="fc" id="L604">        s.append(&quot;   time: &quot;).append(time).append(&quot; (&quot;).append(Utils.dateTimeFormat(time * 1000)).append(&quot;)\n&quot;);</span>
<span class="fc" id="L605">        s.append(&quot;   difficulty target (nBits): &quot;).append(difficultyTarget).append(&quot;\n&quot;);</span>
<span class="fc" id="L606">        s.append(&quot;   nonce: &quot;).append(nonce).append(&quot;\n&quot;);</span>
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">        if (isZerocoin()){</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">            s.append(&quot;   accumulator: &quot;).append((zeroCoinAccumulator!=null)?zeroCoinAccumulator.toString():0).append(&quot;\n&quot;);;</span>
        }
<span class="pc bpc" id="L610" title="2 of 4 branches missed.">        if (transactions != null &amp;&amp; transactions.size() &gt; 0) {</span>
<span class="fc" id="L611">            s.append(&quot;   with &quot;).append(transactions.size()).append(&quot; transaction(s):\n&quot;);</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">            for (Transaction tx : transactions) {</span>
<span class="fc" id="L613">                s.append(tx);</span>
<span class="fc" id="L614">            }</span>
        }
<span class="fc" id="L616">        return s.toString();</span>
    }

    /**
     * &lt;p&gt;Finds a value of nonce that makes the blocks hash lower than the difficulty target. This is called mining, but
     * solve() is far too slow to do real mining with. It exists only for unit testing purposes.
     *
     * &lt;p&gt;This can loop forever if a solution cannot be found solely by incrementing nonce. It doesn't change
     * extraNonce.&lt;/p&gt;
     */
    public void solve() {
        while (true) {
            try {
                // Is our proof of work valid yet?
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">                if (checkProofOfWork(false))</span>
<span class="fc" id="L631">                    return;</span>
                // No, so increment the nonce and try again.
<span class="nc" id="L633">                setNonce(getNonce() + 1);</span>
<span class="nc" id="L634">            } catch (VerificationException e) {</span>
<span class="nc" id="L635">                throw new RuntimeException(e); // Cannot happen.</span>
<span class="nc" id="L636">            }</span>
        }
    }

    /**
     * Returns the difficulty target as a 256 bit value that can be compared to a SHA-256 hash. Inside a block the
     * target is represented using a compact form. If this form decodes to a value that is out of bounds, an exception
     * is thrown.
     */
    public BigInteger getDifficultyTargetAsInteger() throws VerificationException {
<span class="fc" id="L646">        BigInteger target = Utils.decodeCompactBits(difficultyTarget);</span>
<span class="pc bpc" id="L647" title="2 of 4 branches missed.">        if (target.signum() &lt;= 0 || target.compareTo(params.maxTarget) &gt; 0)</span>
<span class="nc" id="L648">            throw new VerificationException(&quot;Difficulty target is bad: &quot; + target.toString());</span>
<span class="fc" id="L649">        return target;</span>
    }

    /** Returns true if the hash of the block is OK (lower than difficulty target). */
    protected boolean checkProofOfWork(boolean throwException) throws VerificationException {
        // This part is key - it is what proves the block was as difficult to make as it claims
        // to be. Note however that in the context of this function, the block can claim to be
        // as difficult as it wants to be .... if somebody was able to take control of our network
        // connection and fork us onto a different chain, they could send us valid blocks with
        // ridiculously easy difficulty and this function would accept them.
        //
        // To prevent this attack from being possible, elsewhere we check that the difficultyTarget
        // field is of the right value. This requires us to have the preceeding blocks.
<span class="fc" id="L662">        BigInteger target = getDifficultyTargetAsInteger();</span>
<span class="fc" id="L663">        BigInteger h = getHash().toBigInteger();</span>

<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (h.compareTo(target) &gt; 0) {</span>
            // Proof of work check failed!
<span class="fc" id="L667">            log.debug(&quot;Hash is higher than target: &quot; + getHashAsString() + &quot; vs &quot; + target.toString(16));</span>
<span class="fc" id="L668">            return true;</span>
            // todo: commented for POS implementation, i have to verify this in another way..
            // todo: one workaround could be use a wallet service inside the master nodes.
            //if (throwException) {
            //    log.info(&quot;Hash is higher than target: &quot; + getHashAsString() + &quot; vs &quot; + target.toString(16));
                //throw new VerificationException(&quot;Hash is higher than target: &quot; + getHashAsString() + &quot; vs &quot;
                //        + target.toString(16));
            //}else
            //    return false;
        }
<span class="fc" id="L678">        return true;</span>
    }

    private void checkTimestamp() throws VerificationException {
        // Allow injection of a fake clock to allow unit testing.
<span class="fc" id="L683">        long currentTime = Utils.currentTimeSeconds();</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">        if (time &gt; currentTime + ALLOWED_TIME_DRIFT)</span>
<span class="nc" id="L685">            throw new VerificationException(String.format(Locale.US, &quot;Block too far in future: %d vs %d&quot;, time, currentTime + ALLOWED_TIME_DRIFT));</span>
<span class="fc" id="L686">    }</span>

    private void checkSigOps() throws VerificationException {
        // Check there aren't too many signature verifications in the block. This is an anti-DoS measure, see the
        // comments for MAX_BLOCK_SIGOPS.
<span class="fc" id="L691">        int sigOps = 0;</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">        for (Transaction tx : transactions) {</span>
<span class="fc" id="L693">            sigOps += tx.getSigOpCount();</span>
<span class="fc" id="L694">        }</span>
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">        if (sigOps &gt; MAX_BLOCK_SIGOPS)</span>
<span class="nc" id="L696">            throw new VerificationException(&quot;Block had too many Signature Operations&quot;);</span>
<span class="fc" id="L697">    }</span>

    private void checkMerkleRoot() throws VerificationException {
<span class="fc" id="L700">        Sha256Hash calculatedRoot = calculateMerkleRoot();</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">        if (!calculatedRoot.equals(merkleRoot)) {</span>
<span class="nc" id="L702">            log.error(&quot;Merkle tree did not verify&quot;);</span>
<span class="nc" id="L703">            throw new VerificationException(&quot;Merkle hashes do not match: &quot; + calculatedRoot + &quot; vs &quot; + merkleRoot);</span>
        }
<span class="fc" id="L705">    }</span>

    private Sha256Hash calculateMerkleRoot() {
<span class="fc" id="L708">        List&lt;byte[]&gt; tree = buildMerkleTree();</span>
<span class="fc" id="L709">        return Sha256Hash.wrap(tree.get(tree.size() - 1));</span>
    }

    private List&lt;byte[]&gt; buildMerkleTree() {
        // The Merkle root is based on a tree of hashes calculated from the transactions:
        //
        //     root
        //      / \
        //   A      B
        //  / \    / \
        // t1 t2 t3 t4
        //
        // The tree is represented as a list: t1,t2,t3,t4,A,B,root where each
        // entry is a hash.
        //
        // The hashing algorithm is double SHA-256. The leaves are a hash of the serialized contents of the transaction.
        // The interior nodes are hashes of the concenation of the two child hashes.
        //
        // This structure allows the creation of proof that a transaction was included into a block without having to
        // provide the full block contents. Instead, you can provide only a Merkle branch. For example to prove tx2 was
        // in a block you can just provide tx2, the hash(tx1) and B. Now the other party has everything they need to
        // derive the root, which can be checked against the block header. These proofs aren't used right now but
        // will be helpful later when we want to download partial block contents.
        //
        // Note that if the number of transactions is not even the last tx is repeated to make it so (see
        // tx3 above). A tree with 5 transactions would look like this:
        //
        //         root
        //        /     \
        //       1        5
        //     /   \     / \
        //    2     3    4  4
        //  / \   / \   / \
        // t1 t2 t3 t4 t5 t5
<span class="fc" id="L743">        ArrayList&lt;byte[]&gt; tree = new ArrayList&lt;byte[]&gt;();</span>
        // Start by adding all the hashes of the transactions as leaves of the tree.
<span class="fc bfc" id="L745" title="All 2 branches covered.">        for (Transaction t : transactions) {</span>
<span class="fc" id="L746">            tree.add(t.getHash().getBytes());</span>
<span class="fc" id="L747">        }</span>
<span class="fc" id="L748">        int levelOffset = 0; // Offset in the list where the currently processed level starts.</span>
        // Step through each level, stopping when we reach the root (levelSize == 1).
<span class="fc bfc" id="L750" title="All 2 branches covered.">        for (int levelSize = transactions.size(); levelSize &gt; 1; levelSize = (levelSize + 1) / 2) {</span>
            // For each pair of nodes on that level:
<span class="fc bfc" id="L752" title="All 2 branches covered.">            for (int left = 0; left &lt; levelSize; left += 2) {</span>
                // The right hand node can be the same as the left hand, in the case where we don't have enough
                // transactions.
<span class="fc" id="L755">                int right = Math.min(left + 1, levelSize - 1);</span>
<span class="fc" id="L756">                byte[] leftBytes = Utils.reverseBytes(tree.get(levelOffset + left));</span>
<span class="fc" id="L757">                byte[] rightBytes = Utils.reverseBytes(tree.get(levelOffset + right));</span>
<span class="fc" id="L758">                tree.add(Utils.reverseBytes(hashTwice(leftBytes, 0, 32, rightBytes, 0, 32)));</span>
            }
            // Move to the next level.
<span class="fc" id="L761">            levelOffset += levelSize;</span>
        }
<span class="fc" id="L763">        return tree;</span>
    }

    /**
     * Verify the transactions on a block.
     *
     * @param height block height, if known, or -1 otherwise. If provided, used
     * to validate the coinbase input script of v2 and above blocks.
     * @throws VerificationException if there was an error verifying the block.
     */
    private void checkTransactions(final int height, final EnumSet&lt;VerifyFlag&gt; flags)
            throws VerificationException {
        // The first transaction in a block must always be a coinbase transaction.
<span class="fc bfc" id="L776" title="All 2 branches covered.">        if (!transactions.get(0).isCoinBase())</span>
<span class="fc" id="L777">            throw new VerificationException(&quot;First tx is not coinbase&quot;);</span>
<span class="pc bpc" id="L778" title="3 of 4 branches missed.">        if (flags.contains(Block.VerifyFlag.HEIGHT_IN_COINBASE) &amp;&amp; height &gt;= BLOCK_HEIGHT_GENESIS) {</span>
<span class="nc" id="L779">            transactions.get(0).checkCoinBaseHeight(height);</span>
        }
        // The rest must not be.
<span class="fc bfc" id="L782" title="All 2 branches covered.">        for (int i = 1; i &lt; transactions.size(); i++) {</span>
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">            if (transactions.get(i).isCoinBase())</span>
<span class="nc" id="L784">                throw new VerificationException(&quot;TX &quot; + i + &quot; is coinbase when it should not be.&quot;);</span>
        }
<span class="fc" id="L786">    }</span>

    /**
     * Checks the block data to ensure it follows the rules laid out in the network parameters. Specifically,
     * throws an exception if the proof of work is invalid, or if the timestamp is too far from what it should be.
     * This is &lt;b&gt;not&lt;/b&gt; everything that is required for a block to be valid, only what is checkable independent
     * of the chain and without a transaction index.
     *
     * @throws VerificationException
     */
    public void verifyHeader() throws VerificationException {
        // Prove that this block is OK. It might seem that we can just ignore most of these checks given that the
        // network is also verifying the blocks, but we cannot as it'd open us to a variety of obscure attacks.
        //
        // Firstly we need to ensure this block does in fact represent real work done. If the difficulty is high
        // enough, it's probably been done by the network.
<span class="fc" id="L802">        checkProofOfWork(true);</span>
<span class="fc" id="L803">        checkTimestamp();</span>
<span class="fc" id="L804">    }</span>

    /**
     * Checks the block contents
     *
     * @param height block height, if known, or -1 otherwise. If valid, used
     * to validate the coinbase input script of v2 and above blocks.
     * @param flags flags to indicate which tests should be applied (i.e.
     * whether to test for height in the coinbase transaction).
     * @throws VerificationException if there was an error verifying the block.
     */
    public void verifyTransactions(final int height, final EnumSet&lt;VerifyFlag&gt; flags) throws VerificationException {
        // Now we need to check that the body of the block actually matches the headers. The network won't generate
        // an invalid block, but if we didn't validate this then an untrusted man-in-the-middle could obtain the next
        // valid block from the network and simply replace the transactions in it with their own fictional
        // transactions that reference spent or non-existant inputs.
<span class="pc bpc" id="L820" title="1 of 2 branches missed.">        if (transactions.isEmpty())</span>
<span class="nc" id="L821">            throw new VerificationException(&quot;Block had no transactions&quot;);</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">        if (this.getOptimalEncodingMessageSize() &gt; MAX_BLOCK_SIZE)</span>
<span class="nc" id="L823">            throw new VerificationException(&quot;Block larger than MAX_BLOCK_SIZE&quot;);</span>
<span class="fc" id="L824">        checkTransactions(height, flags);</span>
<span class="fc" id="L825">        checkMerkleRoot();</span>
<span class="fc" id="L826">        checkSigOps();</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">        for (Transaction transaction : transactions)</span>
<span class="fc" id="L828">            transaction.verify();</span>
<span class="fc" id="L829">        }</span>

    /**
     * Verifies both the header and that the transactions hash to the merkle root.
     *
     * @param height block height, if known, or -1 otherwise.
     * @param flags flags to indicate which tests should be applied (i.e.
     * whether to test for height in the coinbase transaction).
     * @throws VerificationException if there was an error verifying the block.
     */
    public void verify(final int height, final EnumSet&lt;VerifyFlag&gt; flags) throws VerificationException {
<span class="fc" id="L840">        verifyHeader();</span>
<span class="fc" id="L841">        verifyTransactions(height, flags);</span>
<span class="fc" id="L842">    }</span>

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">        if (this == o) return true;</span>
<span class="pc bpc" id="L847" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L848">        return getHash().equals(((Block)o).getHash());</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L853">        return getHash().hashCode();</span>
    }

    /**
     * Returns the merkle root in big endian form, calculating it from transactions if necessary.
     */
    public Sha256Hash getMerkleRoot() {
<span class="fc bfc" id="L860" title="All 2 branches covered.">        if (merkleRoot == null) {</span>
            //TODO check if this is really necessary.
<span class="fc" id="L862">            unCacheHeader();</span>
<span class="fc" id="L863">            merkleRoot = calculateMerkleRoot();</span>
        }
<span class="fc" id="L865">        return merkleRoot;</span>
    }

    /** Exists only for unit testing. */
    void setMerkleRoot(Sha256Hash value) {
<span class="fc" id="L870">        unCacheHeader();</span>
<span class="fc" id="L871">        merkleRoot = value;</span>
<span class="fc" id="L872">        hash = null;</span>
<span class="fc" id="L873">    }</span>

    /** Adds a transaction to this block. The nonce and merkle root are invalid after this. */
    public void addTransaction(Transaction t) {
<span class="fc" id="L877">        addTransaction(t, true);</span>
<span class="fc" id="L878">    }</span>

    /** Adds a transaction to this block, with or without checking the sanity of doing so */
    void addTransaction(Transaction t, boolean runSanityChecks) {
<span class="fc" id="L882">        unCacheTransactions();</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">        if (transactions == null) {</span>
<span class="fc" id="L884">            transactions = new ArrayList&lt;Transaction&gt;();</span>
        }
<span class="fc" id="L886">        t.setParent(this);</span>
<span class="fc bfc" id="L887" title="All 6 branches covered.">        if (runSanityChecks &amp;&amp; transactions.size() == 0 &amp;&amp; !t.isCoinBase())</span>
<span class="fc" id="L888">            throw new RuntimeException(&quot;Attempted to add a non-coinbase transaction as the first transaction: &quot; + t);</span>
<span class="pc bpc" id="L889" title="1 of 6 branches missed.">        else if (runSanityChecks &amp;&amp; transactions.size() &gt; 0 &amp;&amp; t.isCoinBase())</span>
<span class="nc" id="L890">            throw new RuntimeException(&quot;Attempted to add a coinbase transaction when there already is one: &quot; + t);</span>
<span class="fc" id="L891">        transactions.add(t);</span>
<span class="fc" id="L892">        adjustLength(transactions.size(), t.length);</span>
        // Force a recalculation next time the values are needed.
<span class="fc" id="L894">        merkleRoot = null;</span>
<span class="fc" id="L895">        hash = null;</span>
<span class="fc" id="L896">    }</span>

    /** Returns the version of the block data structure as defined by the Bitcoin protocol. */
    public long getVersion() {
<span class="fc" id="L900">        return version;</span>
    }

    /**
     * Returns the hash of the previous block in the chain, as defined by the block header.
     */
    public Sha256Hash getPrevBlockHash() {
<span class="fc" id="L907">        return prevBlockHash;</span>
    }

    void setPrevBlockHash(Sha256Hash prevBlockHash) {
<span class="fc" id="L911">        unCacheHeader();</span>
<span class="fc" id="L912">        this.prevBlockHash = prevBlockHash;</span>
<span class="fc" id="L913">        this.hash = null;</span>
<span class="fc" id="L914">    }</span>

    /**
     * Returns the time at which the block was solved and broadcast, according to the clock of the solving node. This
     * is measured in seconds since the UNIX epoch (midnight Jan 1st 1970).
     */
    public long getTimeSeconds() {
<span class="fc" id="L921">        return time;</span>
    }

    /**
     * Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
     */
    public Date getTime() {
<span class="fc" id="L928">        return new Date(getTimeSeconds()*1000);</span>
    }

    public void setTime(long time) {
<span class="fc" id="L932">        unCacheHeader();</span>
<span class="fc" id="L933">        this.time = time;</span>
<span class="fc" id="L934">        this.hash = null;</span>
<span class="fc" id="L935">    }</span>

    /**
     * Returns the difficulty of the proof of work that this block should meet encoded &lt;b&gt;in compact form&lt;/b&gt;. The {@link
     * BlockChain} verifies that this is not too easy by looking at the length of the chain when the block is added.
     * To find the actual value the hash should be compared against, use
     * {@link site.mtnsj.core.Block#getDifficultyTargetAsInteger()}. Note that this is &lt;b&gt;not&lt;/b&gt; the same as
     * the difficulty value reported by the Bitcoin &quot;getdifficulty&quot; RPC that you may see on various block explorers.
     * That number is the result of applying a formula to the underlying difficulty to normalize the minimum to 1.
     * Calculating the difficulty that way is currently unsupported.
     */
    public long getDifficultyTarget() {
<span class="fc" id="L947">        return difficultyTarget;</span>
    }

    /** Sets the difficulty target in compact form. */
    public void setDifficultyTarget(long compactForm) {
<span class="fc" id="L952">        unCacheHeader();</span>
<span class="fc" id="L953">        this.difficultyTarget = compactForm;</span>
<span class="fc" id="L954">        this.hash = null;</span>
<span class="fc" id="L955">    }</span>

    /**
     * Returns the nonce, an arbitrary value that exists only to make the hash of the block header fall below the
     * difficulty target.
     */
    public long getNonce() {
<span class="fc" id="L962">        return nonce;</span>
    }

    /** Sets the nonce and clears any cached data. */
    public void setNonce(long nonce) {
<span class="fc" id="L967">        unCacheHeader();</span>
<span class="fc" id="L968">        this.nonce = nonce;</span>
<span class="fc" id="L969">        this.hash = null;</span>
<span class="fc" id="L970">    }</span>

    /** Returns an immutable list of transactions held in this block, or null if this object represents just a header. */
    @Nullable
    public List&lt;Transaction&gt; getTransactions() {
<span class="pc bpc" id="L975" title="1 of 2 branches missed.">        return transactions == null ? null : ImmutableList.copyOf(transactions);</span>
    }

    // ///////////////////////////////////////////////////////////////////////////////////////////////
    // Unit testing related methods.

    // Used to make transactions unique.
    private static int txCounter;

    /** Adds a coinbase transaction to the block. This exists for unit tests.
     * 
     * @param height block height, if known, or -1 otherwise.
     */
    @VisibleForTesting
    void addCoinbaseTransaction(byte[] pubKeyTo, Coin value, final int height) {
<span class="fc" id="L990">        unCacheTransactions();</span>
<span class="fc" id="L991">        transactions = new ArrayList&lt;Transaction&gt;();</span>
<span class="fc" id="L992">        Transaction coinbase = new Transaction(params);</span>
<span class="fc" id="L993">        final ScriptBuilder inputBuilder = new ScriptBuilder();</span>

<span class="fc bfc" id="L995" title="All 2 branches covered.">        if (height &gt;= Block.BLOCK_HEIGHT_GENESIS) {</span>
<span class="fc" id="L996">            inputBuilder.number(height);</span>
        }
<span class="fc" id="L998">        inputBuilder.data(new byte[]{(byte) txCounter, (byte) (txCounter++ &gt;&gt; 8)});</span>

        // A real coinbase transaction has some stuff in the scriptSig like the extraNonce and difficulty. The
        // transactions are distinguished by every TX output going to a different key.
        //
        // Here we will do things a bit differently so a new address isn't needed every time. We'll put a simple
        // counter in the scriptSig so every transaction has a different hash.
<span class="fc" id="L1005">        coinbase.addInput(new TransactionInput(params, coinbase,</span>
<span class="fc" id="L1006">                inputBuilder.build().getProgram()));</span>
<span class="fc" id="L1007">        coinbase.addOutput(new TransactionOutput(params, coinbase, value,</span>
<span class="fc" id="L1008">                ScriptBuilder.createOutputScript(ECKey.fromPublicOnly(pubKeyTo)).getProgram()));</span>
<span class="fc" id="L1009">        transactions.add(coinbase);</span>
<span class="fc" id="L1010">        coinbase.setParent(this);</span>
<span class="fc" id="L1011">        coinbase.length = coinbase.unsafeBitcoinSerialize().length;</span>
<span class="fc" id="L1012">        adjustLength(transactions.size(), coinbase.length);</span>
<span class="fc" id="L1013">    }</span>

<span class="fc" id="L1015">    static final byte[] EMPTY_BYTES = new byte[32];</span>

    // It's pretty weak to have this around at runtime: fix later.
<span class="fc" id="L1018">    private static final byte[] pubkeyForTesting = new ECKey().getPubKey();</span>

    /**
     * Returns a solved block that builds on top of this one. This exists for unit tests.
     */
    @VisibleForTesting
    public Block createNextBlock(Address to, long version, long time, int blockHeight) {
<span class="fc" id="L1025">        return createNextBlock(to, version, null, time, pubkeyForTesting, FIFTY_COINS, blockHeight);</span>
    }

    /**
     * Returns a solved block that builds on top of this one. This exists for unit tests.
     * In this variant you can specify a public key (pubkey) for use in generating coinbase blocks.
     * 
     * @param height block height, if known, or -1 otherwise.
     */
    Block createNextBlock(@Nullable final Address to, final long version,
                          @Nullable TransactionOutPoint prevOut, final long time,
                          final byte[] pubKey, final Coin coinbaseValue,
                          final int height) {
<span class="fc" id="L1038">        Block b = new Block(params, version);</span>
<span class="fc" id="L1039">        b.setDifficultyTarget(difficultyTarget);</span>
<span class="fc" id="L1040">        b.addCoinbaseTransaction(pubKey, coinbaseValue, height);</span>

<span class="fc bfc" id="L1042" title="All 2 branches covered.">        if (to != null) {</span>
            // Add a transaction paying 50 coins to the &quot;to&quot; address.
<span class="fc" id="L1044">            Transaction t = new Transaction(params);</span>
<span class="fc" id="L1045">            t.addOutput(new TransactionOutput(params, t, FIFTY_COINS, to));</span>
            // The input does not really need to be a valid signature, as long as it has the right general form.
            TransactionInput input;
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">            if (prevOut == null) {</span>
<span class="fc" id="L1049">                input = new TransactionInput(params, t, Script.createInputScript(EMPTY_BYTES, EMPTY_BYTES));</span>
                // Importantly the outpoint hash cannot be zero as that's how we detect a coinbase transaction in isolation
                // but it must be unique to avoid 'different' transactions looking the same.
<span class="fc" id="L1052">                byte[] counter = new byte[32];</span>
<span class="fc" id="L1053">                counter[0] = (byte) txCounter;</span>
<span class="fc" id="L1054">                counter[1] = (byte) (txCounter++ &gt;&gt; 8);</span>
<span class="fc" id="L1055">                input.getOutpoint().setHash(Sha256Hash.wrap(counter));</span>
<span class="fc" id="L1056">            } else {</span>
<span class="nc" id="L1057">                input = new TransactionInput(params, t, Script.createInputScript(EMPTY_BYTES, EMPTY_BYTES), prevOut);</span>
            }
<span class="fc" id="L1059">            t.addInput(input);</span>
<span class="fc" id="L1060">            b.addTransaction(t);</span>
        }

<span class="fc" id="L1063">        b.setPrevBlockHash(getHash());</span>
        // Don't let timestamp go backwards
<span class="fc bfc" id="L1065" title="All 2 branches covered.">        if (getTimeSeconds() &gt;= time)</span>
<span class="fc" id="L1066">            b.setTime(getTimeSeconds() + 1);</span>
        else
<span class="fc" id="L1068">            b.setTime(time);</span>
<span class="fc" id="L1069">        b.solve();</span>
        try {
<span class="fc" id="L1071">            b.verifyHeader();</span>
<span class="nc" id="L1072">        } catch (VerificationException e) {</span>
<span class="nc" id="L1073">            throw new RuntimeException(e); // Cannot happen.</span>
<span class="fc" id="L1074">        }</span>
<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">        if (b.getVersion() != version) {</span>
<span class="nc" id="L1076">            throw new RuntimeException();</span>
        }
<span class="fc" id="L1078">        return b;</span>
    }

    @VisibleForTesting
    public Block createNextBlock(@Nullable Address to, TransactionOutPoint prevOut) {
<span class="nc" id="L1083">        return createNextBlock(to, BLOCK_VERSION_GENESIS, prevOut, getTimeSeconds() + 5, pubkeyForTesting, FIFTY_COINS, BLOCK_HEIGHT_UNKNOWN);</span>
    }

    @VisibleForTesting
    public Block createNextBlock(@Nullable Address to, Coin value) {
<span class="fc" id="L1088">        return createNextBlock(to, BLOCK_VERSION_GENESIS, null, getTimeSeconds() + 5, pubkeyForTesting, value, BLOCK_HEIGHT_UNKNOWN);</span>
    }

    @VisibleForTesting
    public Block createNextBlock(@Nullable Address to) {
<span class="fc" id="L1093">        return createNextBlock(to, FIFTY_COINS);</span>
    }

    @VisibleForTesting
    public Block createNextBlockWithCoinbase(long version, byte[] pubKey, Coin coinbaseValue, final int height) {
<span class="fc" id="L1098">        return createNextBlock(null, version, (TransactionOutPoint) null,</span>
<span class="fc" id="L1099">                               Utils.currentTimeSeconds(), pubKey, coinbaseValue, height);</span>
    }

    /**
     * Create a block sending 50BTC as a coinbase transaction to the public key specified.
     * This method is intended for test use only.
     */
    @VisibleForTesting
    Block createNextBlockWithCoinbase(long version, byte[] pubKey, final int height) {
<span class="fc" id="L1108">        return createNextBlock(null, version, (TransactionOutPoint) null,</span>
<span class="fc" id="L1109">                               Utils.currentTimeSeconds(), pubKey, FIFTY_COINS, height);</span>
    }

    @VisibleForTesting
    boolean isHeaderBytesValid() {
<span class="nc" id="L1114">        return headerBytesValid;</span>
    }

    @VisibleForTesting
    boolean isTransactionBytesValid() {
<span class="nc" id="L1119">        return transactionBytesValid;</span>
    }

    /**
     * Return whether this block contains any transactions.
     * 
     * @return  true if the block contains transactions, false otherwise (is
     * purely a header).
     */
    public boolean hasTransactions() {
<span class="nc bnc" id="L1129" title="All 2 branches missed.">        return !this.transactions.isEmpty();</span>
    }

    /**
     * Returns whether this block conforms to
     * &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki&quot;&gt;BIP34: Height in Coinbase&lt;/a&gt;.
     */
    public boolean isBIP34() {
<span class="fc bfc" id="L1137" title="All 2 branches covered.">        return version &gt;= BLOCK_VERSION_BIP34;</span>
    }

    /**
     * Returns whether this block conforms to
     * &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki&quot;&gt;BIP66: Strict DER signatures&lt;/a&gt;.
     */
    public boolean isBIP66() {
<span class="pc bpc" id="L1145" title="1 of 2 branches missed.">        return version &gt;= BLOCK_VERSION_BIP66;</span>
    }

    /**
     * Returns whether this block conforms to
     * &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki&quot;&gt;BIP65: OP_CHECKLOCKTIMEVERIFY&lt;/a&gt;.
     */
    public boolean isBIP65() {
<span class="pc bpc" id="L1153" title="1 of 2 branches missed.">        return version &gt;= BLOCK_VERSION_BIP65;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>