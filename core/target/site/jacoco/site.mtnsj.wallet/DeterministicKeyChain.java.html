<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DeterministicKeyChain.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mtnsj</a> &gt; <a href="index.source.html" class="el_package">site.mtnsj.wallet</a> &gt; <span class="el_source">DeterministicKeyChain.java</span></div><h1>DeterministicKeyChain.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014 The bitcoinj developers.
 * Copyright 2015 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package site.mtnsj.wallet;

import com.google.common.collect.Lists;
import site.mtnsj.core.BloomFilter;
import site.mtnsj.core.ECKey;
import site.mtnsj.core.NetworkParameters;
import site.mtnsj.core.Utils;
import site.mtnsj.crypto.*;
import site.mtnsj.script.Script;
import site.mtnsj.utils.Threading;
import site.mtnsj.wallet.listeners.KeyChainEventListener;

import com.google.common.base.Stopwatch;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterators;
import com.google.common.collect.PeekingIterator;
import com.google.protobuf.ByteString;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.spongycastle.crypto.params.KeyParameter;

import javax.annotation.Nullable;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.*;
import java.util.concurrent.Executor;
import java.util.concurrent.locks.ReentrantLock;

import static com.google.common.base.Preconditions.*;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Lists.newLinkedList;

/**
 * &lt;p&gt;A deterministic key chain is a {@link KeyChain} that uses the
 * &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki&quot;&gt;BIP 32 standard&lt;/a&gt;, as implemented by
 * {@link site.mtnsj.crypto.DeterministicHierarchy}, to derive all the keys in the keychain from a master seed.
 * This type of wallet is extremely convenient and flexible. Although backing up full wallet files is always a good
 * idea, to recover money only the root seed needs to be preserved and that is a number small enough that it can be
 * written down on paper or, when represented using a BIP 39 {@link site.mtnsj.crypto.MnemonicCode},
 * dictated over the phone (possibly even memorized).&lt;/p&gt;
 *
 * &lt;p&gt;Deterministic key chains have other advantages: parts of the key tree can be selectively revealed to allow
 * for auditing, and new public keys can be generated without access to the private keys, yielding a highly secure
 * configuration for web servers which can accept payments into a wallet but not spend from them. This does not work
 * quite how you would expect due to a quirk of elliptic curve mathematics and the techniques used to deal with it.
 * A watching wallet is not instantiated using the public part of the master key as you may imagine. Instead, you
 * need to take the account key (first child of the master key) and provide the public part of that to the watching
 * wallet instead. You can do this by calling {@link #getWatchingKey()} and then serializing it with
 * {@link site.mtnsj.crypto.DeterministicKey#serializePubB58(site.mtnsj.core.NetworkParameters)}. The resulting &quot;xpub...&quot; string encodes
 * sufficient information about the account key to create a watching chain via
 * {@link site.mtnsj.crypto.DeterministicKey#deserializeB58(site.mtnsj.crypto.DeterministicKey, String, site.mtnsj.core.NetworkParameters)}
 * (with null as the first parameter) and then
 * {@link DeterministicKeyChain#DeterministicKeyChain(site.mtnsj.crypto.DeterministicKey,KeyChainType keyChaintype)}.&lt;/p&gt;
 *
 * &lt;p&gt;This class builds on {@link site.mtnsj.crypto.DeterministicHierarchy} and
 * {@link site.mtnsj.crypto.DeterministicKey} by adding support for serialization to and from protobufs,
 * and encryption of parts of the key tree. Internally it arranges itself as per the BIP 32 spec, with the seed being
 * used to derive a master key, which is then used to derive an account key, the account key is used to derive two
 * child keys called the &lt;i&gt;internal&lt;/i&gt; and &lt;i&gt;external&lt;/i&gt; parent keys (for change and handing out addresses respectively)
 * and finally the actual leaf keys that users use hanging off the end. The leaf keys are special in that they don't
 * internally store the private part at all, instead choosing to rederive the private key from the parent when
 * needed for signing. This simplifies the design for encrypted key chains.&lt;/p&gt;
 *
 * &lt;p&gt;The key chain manages a &lt;i&gt;lookahead zone&lt;/i&gt;. This zone is required because when scanning the chain, you don't
 * know exactly which keys might receive payments. The user may have handed out several addresses and received payments
 * on them, but for latency reasons the block chain is requested from remote peers in bulk, meaning you must
 * &quot;look ahead&quot; when calculating keys to put in the Bloom filter. The default lookahead zone is 100 keys, meaning if
 * the user hands out more than 100 addresses and receives payment on them before the chain is next scanned, some
 * transactions might be missed. 100 is a reasonable choice for consumer wallets running on CPU constrained devices.
 * For industrial wallets that are receiving keys all the time, a higher value is more appropriate. Ideally DKC and the
 * wallet would know how to adjust this value automatically, but that's not implemented at the moment.&lt;/p&gt;
 *
 * &lt;p&gt;In fact the real size of the lookahead zone is larger than requested, by default, it's one third larger. This
 * is because the act of deriving new keys means recalculating the Bloom filters and this is an expensive operation.
 * Thus, to ensure we don't have to recalculate on every single new key/address requested or seen we add more buffer
 * space and only extend the lookahead zone when that buffer is exhausted. For example with a lookahead zone of 100
 * keys, you can request 33 keys before more keys will be calculated and the Bloom filter rebuilt and rebroadcast.
 * But even when you are requesting the 33rd key, you will still be looking 100 keys ahead.
 * &lt;/p&gt;
 */
@SuppressWarnings(&quot;PublicStaticCollectionField&quot;)
public class DeterministicKeyChain implements EncryptableKeyChain {
<span class="fc" id="L100">    private static final Logger log = LoggerFactory.getLogger(DeterministicKeyChain.class);</span>
    public static final String DEFAULT_PASSPHRASE_FOR_MNEMONIC = &quot;&quot;;

<span class="pc" id="L103">    protected final ReentrantLock lock = Threading.lock(&quot;DeterministicKeyChain&quot;);</span>

    private DeterministicHierarchy hierarchy;
    @Nullable private DeterministicKey rootKey;
    @Nullable private DeterministicSeed seed;

    // Paths through the key tree. External keys are ones that are communicated to other parties. Internal keys are
    // keys created for change addresses, coinbases, mixing, etc - anything that isn't communicated. The distinction
    // is somewhat arbitrary but can be useful for audits. The first number is the &quot;account number&quot; but we don't use
    // that feature yet. In future we might hand out different accounts for cases where we wish to hand payers
    // a payment request that can generate lots of addresses independently.
    // The account path may be overridden by subclasses.
<span class="fc" id="L115">    public static final ImmutableList&lt;ChildNumber&gt; ACCOUNT_ZERO_PATH = ImmutableList.of(ChildNumber.ZERO_HARDENED);</span>
<span class="fc" id="L116">    public static final ImmutableList&lt;ChildNumber&gt; EXTERNAL_SUBPATH = ImmutableList.of(ChildNumber.ZERO);</span>
<span class="fc" id="L117">    public static final ImmutableList&lt;ChildNumber&gt; INTERNAL_SUBPATH = ImmutableList.of(ChildNumber.ONE);</span>
<span class="fc" id="L118">    public static final ImmutableList&lt;ChildNumber&gt; EXTERNAL_PATH = HDUtils.concat(ACCOUNT_ZERO_PATH, EXTERNAL_SUBPATH);</span>
<span class="fc" id="L119">    public static final ImmutableList&lt;ChildNumber&gt; INTERNAL_PATH = HDUtils.concat(ACCOUNT_ZERO_PATH, INTERNAL_SUBPATH);</span>
    // m / 44' / 0' / 0'
    //public static final ImmutableList&lt;ChildNumber&gt; BIP44_ACCOUNT_ZERO_PATH =
    //        ImmutableList.of(new ChildNumber(44, true), ChildNumber.ZERO_HARDENED, ChildNumber.ZERO_HARDENED);

    // MTNS BIP44
<span class="fc" id="L125">    public static final ChildNumber BIP44_MASTER_KEY = new ChildNumber(44, true);</span>
<span class="fc" id="L126">    public static final ChildNumber MTNS_PATH = new ChildNumber(119,true);</span>
<span class="fc" id="L127">    public static final ImmutableList&lt;ChildNumber&gt; BIP44_ACCOUNT_ZERO_PATH =</span>
<span class="fc" id="L128">            ImmutableList.of(BIP44_MASTER_KEY, MTNS_PATH, ChildNumber.ZERO_HARDENED);</span>

    // We try to ensure we have at least this many keys ready and waiting to be handed out via getKey().
    // See docs for getLookaheadSize() for more info on what this is for. The -1 value means it hasn't been calculated
    // yet. For new chains it's set to whatever the default is, unless overridden by setLookaheadSize. For deserialized
    // chains, it will be calculated on demand from the number of loaded keys.
    private static final int LAZY_CALCULATE_LOOKAHEAD = -1;
<span class="pc" id="L135">    protected int lookaheadSize = 100;</span>
    // The lookahead threshold causes us to batch up creation of new keys to minimize the frequency of Bloom filter
    // regenerations, which are expensive and will (in future) trigger chain download stalls/retries. One third
    // is an efficiency tradeoff.
<span class="pc" id="L139">    protected int lookaheadThreshold = calcDefaultLookaheadThreshold();</span>

    private int calcDefaultLookaheadThreshold() {
<span class="fc" id="L142">        return lookaheadSize / 3;</span>
    }

    // The parent keys for external keys (handed out to other people) and internal keys (used for change addresses).
    private DeterministicKey externalParentKey, internalParentKey;
    // How many keys on each path have actually been used. This may be fewer than the number that have been deserialized
    // or held in memory, because of the lookahead zone.
    private int issuedExternalKeys, issuedInternalKeys;
    // A counter that is incremented each time a key in the lookahead threshold zone is marked as used and lookahead
    // is triggered. The Wallet/KCG reads these counters and combines them so it can tell the Peer whether to throw
    // away the current block (and any future blocks in the same download batch) and restart chain sync once a new
    // filter has been calculated. This field isn't persisted to the wallet as it's only relevant within a network
    // session.
    private int keyLookaheadEpoch;

    // We simplify by wrapping a basic key chain and that way we get some functionality like key lookup and event
    // listeners &quot;for free&quot;. All keys in the key tree appear here, even if they aren't meant to be used for receiving
    // money.
    private final BasicKeyChain basicKeyChain;

    // If set this chain is following another chain in a married KeyChainGroup
    private boolean isFollowing;

    // holds a number of signatures required to spend. It's the N from N-of-M CHECKMULTISIG script for P2SH transactions
    // and always 1 for other transaction types
<span class="pc" id="L167">    protected int sigsRequiredToSpend = 1;</span>
    // Key Chain type to support bip32 or bip44
<span class="pc" id="L169">    private KeyChainType keyChainType = KeyChainType.BIP32;</span>

    // Key Chain version to support BIP44 fixed without refactor this code too much
<span class="pc" id="L172">    public static enum KeyChainType{</span>
<span class="fc" id="L173">        BIP32,BIP44_MTNS_ONLY</span>
    }



    public static class Builder&lt;T extends Builder&lt;T&gt;&gt; {
        protected SecureRandom random;
<span class="nc" id="L180">        protected int bits = 128;</span>
        protected String passphrase;
        protected long seedCreationTimeSecs;
        protected byte[] entropy;
        protected DeterministicSeed seed;
        protected DeterministicKey watchingKey;

<span class="nc" id="L187">        protected Builder() {</span>
<span class="nc" id="L188">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        protected T self() {
<span class="nc" id="L192">            return (T)this;</span>
        }

        /**
         * Creates a deterministic key chain starting from the given entropy. All keys yielded by this chain will be the same
         * if the starting entropy is the same. You should provide the creation time in seconds since the UNIX epoch for the
         * seed: this lets us know from what part of the chain we can expect to see derived keys appear.
         */
        public T entropy(byte[] entropy) {
<span class="nc" id="L201">            this.entropy = entropy;</span>
<span class="nc" id="L202">            return self();</span>
        }

        /**
         * Creates a deterministic key chain starting from the given seed. All keys yielded by this chain will be the same
         * if the starting seed is the same.
         */
        public T seed(DeterministicSeed seed) {
<span class="nc" id="L210">            this.seed = seed;</span>
<span class="nc" id="L211">            return self();</span>
        }

        /**
         * Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
         * object and of the requested size in bits.  The derived seed is further protected with a user selected passphrase
         * (see BIP 39).
         * @param random the random number generator - use new SecureRandom().
         * @param bits The number of bits of entropy to use when generating entropy.  Either 128 (default), 192 or 256.
         */
        public T random(SecureRandom random, int bits) {
<span class="nc" id="L222">            this.random = random;</span>
<span class="nc" id="L223">            this.bits = bits;</span>
<span class="nc" id="L224">            return self();</span>
        }

        /**
         * Generates a new key chain with 128 bits of entropy selected randomly from the given {@link java.security.SecureRandom}
         * object.  The derived seed is further protected with a user selected passphrase
         * (see BIP 39).
         * @param random the random number generator - use new SecureRandom().
         */
        public T random(SecureRandom random) {
<span class="nc" id="L234">            this.random = random;</span>
<span class="nc" id="L235">            return self();</span>
        }

        public T watchingKey(DeterministicKey watchingKey) {
<span class="nc" id="L239">            this.watchingKey = watchingKey;</span>
<span class="nc" id="L240">            return self();</span>
        }

        public T seedCreationTimeSecs(long seedCreationTimeSecs) {
<span class="nc" id="L244">            this.seedCreationTimeSecs = seedCreationTimeSecs;</span>
<span class="nc" id="L245">            return self();</span>
        }

        /** The passphrase to use with the generated mnemonic, or null if you would like to use the default empty string. Currently must be the empty string. */
        public T passphrase(String passphrase) {
            // FIXME support non-empty passphrase
<span class="nc" id="L251">            this.passphrase = passphrase;</span>
<span class="nc" id="L252">            return self();</span>
        }

        public DeterministicKeyChain build() {
<span class="nc bnc" id="L256" title="All 8 branches missed.">            checkState(random != null || entropy != null || seed != null || watchingKey!= null, &quot;Must provide either entropy or random or seed or watchingKey&quot;);</span>
<span class="nc bnc" id="L257" title="All 4 branches missed.">            checkState(passphrase == null || seed == null, &quot;Passphrase must not be specified with seed&quot;);</span>
            DeterministicKeyChain chain;

<span class="nc bnc" id="L260" title="All 2 branches missed.">            if (random != null) {</span>
                // Default passphrase to &quot;&quot; if not specified
<span class="nc" id="L262">                chain = new DeterministicKeyChain(random, bits, getPassphrase(), seedCreationTimeSecs);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">            } else if (entropy != null) {</span>
<span class="nc" id="L264">                chain = new DeterministicKeyChain(entropy, getPassphrase(), seedCreationTimeSecs);</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">            } else if (seed != null) {</span>
<span class="nc" id="L266">                seed.setCreationTimeSeconds(seedCreationTimeSecs);</span>
<span class="nc" id="L267">                chain = new DeterministicKeyChain(seed);</span>
            } else {
<span class="nc" id="L269">                watchingKey.setCreationTimeSeconds(seedCreationTimeSecs);</span>
<span class="nc" id="L270">                chain = new DeterministicKeyChain(watchingKey,KeyChainType.BIP32);</span>
            }

<span class="nc" id="L273">            return chain;</span>
        }

        protected String getPassphrase() {
<span class="nc bnc" id="L277" title="All 2 branches missed.">            return passphrase != null ? passphrase : DEFAULT_PASSPHRASE_FOR_MNEMONIC;</span>
        }
    }

    public static Builder&lt;?&gt; builder() {
<span class="nc" id="L282">        return new Builder();</span>
    }

    /**
     * Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     * object and the default entropy size.
     */
    public DeterministicKeyChain(SecureRandom random) {
<span class="fc" id="L290">        this(random, DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS, DEFAULT_PASSPHRASE_FOR_MNEMONIC, Utils.currentTimeSeconds());</span>
<span class="fc" id="L291">    }</span>

    /**
     * Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     * object and of the requested size in bits.
     */
    public DeterministicKeyChain(SecureRandom random, int bits) {
<span class="nc" id="L298">        this(random, bits, DEFAULT_PASSPHRASE_FOR_MNEMONIC, Utils.currentTimeSeconds());</span>
<span class="nc" id="L299">    }</span>

    /**
     * Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     * object and of the requested size in bits.  The derived seed is further protected with a user selected passphrase
     * (see BIP 39).
     */
    public DeterministicKeyChain(SecureRandom random, int bits, String passphrase, long seedCreationTimeSecs) {
<span class="fc" id="L307">        this(new DeterministicSeed(random, bits, passphrase, seedCreationTimeSecs));</span>
<span class="fc" id="L308">    }</span>

    /**
     * Creates a deterministic key chain starting from the given entropy. All keys yielded by this chain will be the same
     * if the starting seed is the same. You should provide the creation time in seconds since the UNIX epoch for the
     * seed: this lets us know from what part of the chain we can expect to see derived keys appear.
     */
    public DeterministicKeyChain(byte[] entropy, String passphrase, long seedCreationTimeSecs) {
<span class="nc" id="L316">        this(new DeterministicSeed(entropy, passphrase, seedCreationTimeSecs));</span>
<span class="nc" id="L317">    }</span>

    /**
     * Creates a deterministic key chain starting from the given seed. All keys yielded by this chain will be the same
     * if the starting seed is the same.
     */
    protected DeterministicKeyChain(DeterministicSeed seed,KeyChainType keyChainType) {
<span class="fc" id="L324">        this(seed, null,keyChainType);</span>

<span class="fc" id="L326">    }</span>

    /**
     * Creates a deterministic key chain starting from the given seed. All keys yielded by this chain will be the same
     * if the starting seed is the same.
     */
    protected DeterministicKeyChain(DeterministicSeed seed) {
<span class="fc" id="L333">        this(seed, null,KeyChainType.BIP32);</span>
<span class="fc" id="L334">    }</span>

    /**
     * Creates a deterministic key chain that watches the given (public only) root key. You can use this to calculate
     * balances and generally follow along, but spending is not possible with such a chain. Currently you can't use
     * this method to watch an arbitrary fragment of some other tree, this limitation may be removed in future.
     */
<span class="nc" id="L341">    public DeterministicKeyChain(DeterministicKey watchingKey,KeyChainType keyChainType) {</span>
<span class="nc" id="L342">        this.keyChainType = keyChainType;</span>
<span class="nc" id="L343">        checkArgument(watchingKey.isPubKeyOnly(), &quot;Private subtrees not currently supported: if you got this key from DKC.getWatchingKey() then use .dropPrivate().dropParent() on it first.&quot;);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (keyChainType != KeyChainType.BIP44_MTNS_ONLY)</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            checkArgument( watchingKey.getPath().size() == getAccountPath().size(), &quot;You can only watch an account key currently&quot;);</span>
<span class="nc" id="L346">        basicKeyChain = new BasicKeyChain();</span>
<span class="nc" id="L347">        this.seed = null;</span>
<span class="nc" id="L348">        rootKey = null;</span>
<span class="nc" id="L349">        addToBasicChain(watchingKey);</span>
<span class="nc" id="L350">        hierarchy = new DeterministicHierarchy(watchingKey);</span>
<span class="nc" id="L351">        initializeHierarchyUnencrypted(watchingKey);</span>
<span class="nc" id="L352">    }</span>

    /**
     * &lt;p&gt;Creates a deterministic key chain with the given watch key. If &lt;code&gt;isFollowing&lt;/code&gt; flag is set then this keychain follows
     * some other keychain. In a married wallet following keychain represents &quot;spouse's&quot; keychain.&lt;/p&gt;
     * &lt;p&gt;Watch key has to be an account key.&lt;/p&gt;
     */
    protected DeterministicKeyChain(DeterministicKey watchKey, boolean isFollowing) {
<span class="nc" id="L360">        this(watchKey,KeyChainType.BIP32);</span>
<span class="nc" id="L361">        this.isFollowing = isFollowing;</span>
<span class="nc" id="L362">    }</span>

    /**
     * Creates a deterministic key chain with the given watch key and that follows some other keychain. In a married
     * wallet following keychain represents &quot;spouse&quot;
     * Watch key has to be an account key.
     */
    public static DeterministicKeyChain watchAndFollow(DeterministicKey watchKey) {
<span class="nc" id="L370">        return new DeterministicKeyChain(watchKey, true);</span>
    }

    /**
     * Creates a key chain that watches the given account key.
     */
    public static DeterministicKeyChain watch(DeterministicKey accountKey) {
<span class="nc" id="L377">        return new DeterministicKeyChain(accountKey,KeyChainType.BIP32);</span>
    }

    /**
     * Creates a key chain that watches the given account key.
     */
    public static DeterministicKeyChain watch(DeterministicKey accountKey,KeyChainType keyChainType) {
<span class="nc" id="L384">        return new DeterministicKeyChain(accountKey,keyChainType);</span>
    }

    /**
     * For use in {@link KeyChainFactory} during deserialization.
     */
<span class="fc" id="L390">    protected DeterministicKeyChain(DeterministicSeed seed, @Nullable KeyCrypter crypter,KeyChainType keyChainType) {</span>
<span class="fc" id="L391">        this.keyChainType = keyChainType;</span>
<span class="fc" id="L392">        this.seed = seed;</span>
<span class="fc" id="L393">        basicKeyChain = new BasicKeyChain(crypter);</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        if (!seed.isEncrypted()) {</span>
<span class="fc" id="L395">            rootKey = HDKeyDerivation.createMasterPrivateKey(checkNotNull(seed.getSeedBytes()));</span>
<span class="fc" id="L396">            rootKey.setCreationTimeSeconds(seed.getCreationTimeSeconds());</span>
<span class="fc" id="L397">            addToBasicChain(rootKey);</span>
<span class="fc" id="L398">            hierarchy = new DeterministicHierarchy(rootKey);</span>
<span class="fc" id="L399">            ImmutableList&lt;ChildNumber&gt; accountPath = getAccountPath();</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">            for (int i = 1; i &lt;= accountPath.size(); i++) {</span>
<span class="fc" id="L401">                addToBasicChain(hierarchy.get(accountPath.subList(0, i), false, true));</span>
            }
<span class="fc" id="L403">            initializeHierarchyUnencrypted(rootKey);</span>
        }
        // Else...
        // We can't initialize ourselves with just an encrypted seed, so we expected deserialization code to do the
        // rest of the setup (loading the root key).
<span class="fc" id="L408">    }</span>

    /**
     * For use in {@link KeyChainFactory} during deserialization.
     */
<span class="nc" id="L413">    protected DeterministicKeyChain(DeterministicSeed seed, @Nullable KeyCrypter crypter) {</span>
<span class="nc" id="L414">        this.seed = seed;</span>
<span class="nc" id="L415">        basicKeyChain = new BasicKeyChain(crypter);</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (!seed.isEncrypted()) {</span>
<span class="nc" id="L417">            rootKey = HDKeyDerivation.createMasterPrivateKey(checkNotNull(seed.getSeedBytes()));</span>
<span class="nc" id="L418">            rootKey.setCreationTimeSeconds(seed.getCreationTimeSeconds());</span>
<span class="nc" id="L419">            addToBasicChain(rootKey);</span>
<span class="nc" id="L420">            hierarchy = new DeterministicHierarchy(rootKey);</span>
<span class="nc" id="L421">            ImmutableList&lt;ChildNumber&gt; accountPath = getAccountPath();</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">            for (int i = 1; i &lt;= accountPath.size(); i++) {</span>
<span class="nc" id="L423">                addToBasicChain(hierarchy.get(accountPath.subList(0, i), false, true));</span>
            }
<span class="nc" id="L425">            initializeHierarchyUnencrypted(rootKey);</span>
        }
        // Else...
        // We can't initialize ourselves with just an encrypted seed, so we expected deserialization code to do the
        // rest of the setup (loading the root key).
<span class="nc" id="L430">    }</span>

    /**
     * For use in encryption when {@link #toEncrypted(KeyCrypter, KeyParameter)} is called, so that
     * subclasses can override that method and create an instance of the right class.
     *
     * See also {@link #makeKeyChainFromSeed(DeterministicSeed)}
     */
<span class="nc" id="L438">    protected DeterministicKeyChain(KeyCrypter crypter, KeyParameter aesKey, DeterministicKeyChain chain) {</span>
        // Can't encrypt a watching chain.
<span class="nc" id="L440">        checkNotNull(chain.rootKey);</span>
<span class="nc" id="L441">        checkNotNull(chain.seed);</span>

<span class="nc bnc" id="L443" title="All 2 branches missed.">        checkArgument(!chain.rootKey.isEncrypted(), &quot;Chain already encrypted&quot;);</span>

<span class="nc" id="L445">        this.issuedExternalKeys = chain.issuedExternalKeys;</span>
<span class="nc" id="L446">        this.issuedInternalKeys = chain.issuedInternalKeys;</span>

<span class="nc" id="L448">        this.lookaheadSize = chain.lookaheadSize;</span>
<span class="nc" id="L449">        this.lookaheadThreshold = chain.lookaheadThreshold;</span>

<span class="nc" id="L451">        this.seed = chain.seed.encrypt(crypter, aesKey);</span>
<span class="nc" id="L452">        basicKeyChain = new BasicKeyChain(crypter);</span>
        // The first number is the &quot;account number&quot; but we don't use that feature.
<span class="nc" id="L454">        rootKey = chain.rootKey.encrypt(crypter, aesKey, null);</span>
<span class="nc" id="L455">        hierarchy = new DeterministicHierarchy(rootKey);</span>
<span class="nc" id="L456">        basicKeyChain.importKey(rootKey);</span>

<span class="nc bnc" id="L458" title="All 2 branches missed.">        for (int i = 1; i &lt; getAccountPath().size(); i++) {</span>
<span class="nc" id="L459">            encryptNonLeaf(aesKey, chain, rootKey, getAccountPath().subList(0, i));</span>
        }
<span class="nc" id="L461">        DeterministicKey account = encryptNonLeaf(aesKey, chain, rootKey, getAccountPath());</span>
<span class="nc" id="L462">        externalParentKey = encryptNonLeaf(aesKey, chain, account, HDUtils.concat(getAccountPath(), EXTERNAL_SUBPATH));</span>
<span class="nc" id="L463">        internalParentKey = encryptNonLeaf(aesKey, chain, account, HDUtils.concat(getAccountPath(), INTERNAL_SUBPATH));</span>

        // Now copy the (pubkey only) leaf keys across to avoid rederiving them. The private key bytes are missing
        // anyway so there's nothing to encrypt.
<span class="nc bnc" id="L467" title="All 2 branches missed.">        for (ECKey eckey : chain.basicKeyChain.getKeys()) {</span>
<span class="nc" id="L468">            DeterministicKey key = (DeterministicKey) eckey;</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">            if (key.getPath().size() != getAccountPath().size() + 2) continue; // Not a leaf key.</span>
<span class="nc" id="L470">            DeterministicKey parent = hierarchy.get(checkNotNull(key.getParent()).getPath(), false, false);</span>
            // Clone the key to the new encrypted hierarchy.
<span class="nc" id="L472">            key = new DeterministicKey(key.dropPrivateBytes(), parent);</span>
<span class="nc" id="L473">            hierarchy.putKey(key);</span>
<span class="nc" id="L474">            basicKeyChain.importKey(key);</span>
<span class="nc" id="L475">        }</span>
<span class="nc" id="L476">    }</span>

    /** Override in subclasses to use a different account derivation path */
    protected ImmutableList&lt;ChildNumber&gt; getAccountPath() {
<span class="pc bpc" id="L480" title="1 of 3 branches missed.">        switch (keyChainType){</span>
            case BIP32:
<span class="fc" id="L482">                return ACCOUNT_ZERO_PATH;</span>
            case BIP44_MTNS_ONLY:
<span class="fc" id="L484">                return BIP44_ACCOUNT_ZERO_PATH;</span>
            default:
<span class="nc" id="L486">                throw new IllegalStateException(&quot;Uknown keyChainType&quot;);</span>
        }
    }

    public KeyChainType getKeyChainType() {
<span class="nc" id="L491">        return keyChainType;</span>
    }

    private DeterministicKey encryptNonLeaf(KeyParameter aesKey, DeterministicKeyChain chain,
                                            DeterministicKey parent, ImmutableList&lt;ChildNumber&gt; path) {
<span class="nc" id="L496">        DeterministicKey key = chain.hierarchy.get(path, false, false);</span>
<span class="nc" id="L497">        key = key.encrypt(checkNotNull(basicKeyChain.getKeyCrypter()), aesKey, parent);</span>
<span class="nc" id="L498">        hierarchy.putKey(key);</span>
<span class="nc" id="L499">        basicKeyChain.importKey(key);</span>
<span class="nc" id="L500">        return key;</span>
    }

    // Derives the account path keys and inserts them into the basic key chain. This is important to preserve their
    // order for serialization, amongst other things.
    private void initializeHierarchyUnencrypted(DeterministicKey baseKey) {
<span class="pc bpc" id="L506" title="3 of 4 branches missed.">        if (baseKey.isPubKeyOnly() &amp;&amp; keyChainType == KeyChainType.BIP44_MTNS_ONLY){</span>
<span class="nc" id="L507">            externalParentKey = baseKey;</span>
<span class="nc" id="L508">            internalParentKey = baseKey;</span>
<span class="nc" id="L509">            addToBasicChain(externalParentKey);</span>
<span class="nc" id="L510">            addToBasicChain(internalParentKey);</span>
        }else {
<span class="fc" id="L512">            externalParentKey = hierarchy.deriveChild(getAccountPath(), false, false, ChildNumber.ZERO);</span>
<span class="fc" id="L513">            internalParentKey = hierarchy.deriveChild(getAccountPath(), false, false, ChildNumber.ONE);</span>
<span class="fc" id="L514">            addToBasicChain(externalParentKey);</span>
<span class="fc" id="L515">            addToBasicChain(internalParentKey);</span>
        }
<span class="fc" id="L517">    }</span>

    /** Returns a freshly derived key that has not been returned by this method before. */
    @Override
    public DeterministicKey getKey(KeyPurpose purpose) {
<span class="nc" id="L522">        DeterministicKey deterministicKey = getKeys(purpose, 1).get(0);</span>
<span class="nc" id="L523">        return deterministicKey;</span>
    }


    /** Returns freshly derived key/s that have not been returned by this method before. */
    @Override
    public List&lt;DeterministicKey&gt; getKeys(KeyPurpose purpose, int numberOfKeys) {
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">        checkArgument(numberOfKeys &gt; 0);</span>
<span class="fc" id="L531">        lock.lock();</span>
        try {
            DeterministicKey parentKey;
            int index;
<span class="pc bpc" id="L535" title="1 of 3 branches missed.">            switch (purpose) {</span>
                // Map both REFUND and RECEIVE_KEYS to the same branch for now. Refunds are a feature of the BIP 70
                // payment protocol. Later we may wish to map it to a different branch (in a new wallet version?).
                // This would allow a watching wallet to only be able to see inbound payments, but not change
                // (i.e. spends) or refunds. Might be useful for auditing ...
                case RECEIVE_FUNDS:
                case REFUND:
<span class="fc" id="L542">                    issuedExternalKeys += numberOfKeys;</span>
<span class="fc" id="L543">                    index = issuedExternalKeys;</span>
<span class="fc" id="L544">                    parentKey = externalParentKey;</span>
<span class="fc" id="L545">                    break;</span>
                case AUTHENTICATION:
                case CHANGE:
<span class="fc" id="L548">                    issuedInternalKeys += numberOfKeys;</span>
<span class="fc" id="L549">                    index = issuedInternalKeys;</span>
<span class="fc" id="L550">                    parentKey = internalParentKey;</span>
<span class="fc" id="L551">                    break;</span>
                default:
<span class="nc" id="L553">                    throw new UnsupportedOperationException();</span>
            }
            // Optimization: potentially do a very quick key generation for just the number of keys we need if we
            // didn't already create them, ignoring the configured lookahead size. This ensures we'll be able to
            // retrieve the keys in the following loop, but if we're totally fresh and didn't get a chance to
            // calculate the lookahead keys yet, this will not block waiting to calculate 100+ EC point multiplies.
            // On slow/crappy Android phones looking ahead 100 keys can take ~5 seconds but the OS will kill us
            // if we block for just one second on the UI thread. Because UI threads may need an address in order
            // to render the screen, we need getKeys to be fast even if the wallet is totally brand new and lookahead
            // didn't happen yet.
            //
            // It's safe to do this because when a network thread tries to calculate a Bloom filter, we'll go ahead
            // and calculate the full lookahead zone there, so network requests will always use the right amount.
<span class="fc" id="L566">            List&lt;DeterministicKey&gt; lookahead = maybeLookAhead(parentKey, index, 0, 0);</span>
<span class="fc" id="L567">            basicKeyChain.importKeys(lookahead);</span>
<span class="fc" id="L568">            List&lt;DeterministicKey&gt; keys = new ArrayList&lt;DeterministicKey&gt;(numberOfKeys);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">            for (int i = 0; i &lt; numberOfKeys; i++) {</span>
<span class="fc" id="L570">                ImmutableList&lt;ChildNumber&gt; path = HDUtils.append(parentKey.getPath(), new ChildNumber(index - numberOfKeys + i, false));</span>
<span class="fc" id="L571">                DeterministicKey k = hierarchy.get(path, false, false);</span>
                // Just a last minute sanity check before we hand the key out to the app for usage. This isn't inspired
                // by any real problem reports from mtnsj users, but I've heard of cases via the grapevine of
                // places that lost money due to bitflips causing addresses to not match keys. Of course in an
                // environment with flaky RAM there's no real way to always win: bitflips could be introduced at any
                // other layer. But as we're potentially retrieving from long term storage here, check anyway.
<span class="fc" id="L577">                checkForBitFlip(k);</span>
<span class="fc" id="L578">                keys.add(k);</span>
            }
<span class="fc" id="L580">            return keys;</span>
        } finally {
<span class="pc" id="L582">            lock.unlock();</span>
<span class="nc" id="L583">        }</span>
    }

    private void checkForBitFlip(DeterministicKey k) {
<span class="fc" id="L587">        DeterministicKey parent = checkNotNull(k.getParent());</span>
<span class="fc" id="L588">        byte[] rederived = HDKeyDerivation.deriveChildKeyBytesFromPublic(parent, k.getChildNumber(), HDKeyDerivation.PublicDeriveMode.WITH_INVERSION).keyBytes;</span>
<span class="fc" id="L589">        byte[] actual = k.getPubKey();</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">        if (!Arrays.equals(rederived, actual))</span>
<span class="nc" id="L591">            throw new IllegalStateException(String.format(Locale.US, &quot;Bit-flip check failed: %s vs %s&quot;, Arrays.toString(rederived), Arrays.toString(actual)));</span>
<span class="fc" id="L592">    }</span>

    private void addToBasicChain(DeterministicKey key) {
<span class="fc" id="L595">        basicKeyChain.importKeys(ImmutableList.of(key));</span>
<span class="fc" id="L596">    }</span>

    /**
     * Mark the DeterministicKey as used.
     * Also correct the issued{Internal|External}Keys counter, because all lower children seem to be requested already.
     * If the counter was updated, we also might trigger lookahead.
     */
    public DeterministicKey markKeyAsUsed(DeterministicKey k) {
<span class="fc" id="L604">        int numChildren = k.getChildNumber().i() + 1;</span>

<span class="fc bfc" id="L606" title="All 2 branches covered.">        if (k.getParent() == internalParentKey) {</span>
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">            if (issuedInternalKeys &lt; numChildren) {</span>
<span class="nc" id="L608">                issuedInternalKeys = numChildren;</span>
<span class="nc" id="L609">                maybeLookAhead();</span>
            }
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">        } else if (k.getParent() == externalParentKey) {</span>
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">            if (issuedExternalKeys &lt; numChildren) {</span>
<span class="nc" id="L613">                issuedExternalKeys = numChildren;</span>
<span class="nc" id="L614">                maybeLookAhead();</span>
            }
        }
<span class="fc" id="L617">        return k;</span>
    }

    public DeterministicKey findKeyFromPubHash(byte[] pubkeyHash) {
<span class="fc" id="L621">        lock.lock();</span>
        try {
<span class="fc" id="L623">            return (DeterministicKey) basicKeyChain.findKeyFromPubHash(pubkeyHash);</span>
        } finally {
<span class="pc" id="L625">            lock.unlock();</span>
<span class="nc" id="L626">        }</span>
    }

    public DeterministicKey findKeyFromPubKey(byte[] pubkey) {
<span class="fc" id="L630">        lock.lock();</span>
        try {
<span class="fc" id="L632">            return (DeterministicKey) basicKeyChain.findKeyFromPubKey(pubkey);</span>
        } finally {
<span class="pc" id="L634">            lock.unlock();</span>
<span class="nc" id="L635">        }</span>
    }

    /**
     * Mark the DeterministicKeys as used, if they match the pubkeyHash
     * See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     */
    @Nullable
    public DeterministicKey markPubHashAsUsed(byte[] pubkeyHash) {
<span class="fc" id="L644">        lock.lock();</span>
        try {
<span class="fc" id="L646">            DeterministicKey k = (DeterministicKey) basicKeyChain.findKeyFromPubHash(pubkeyHash);</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">            if (k != null)</span>
<span class="fc" id="L648">                markKeyAsUsed(k);</span>
<span class="fc" id="L649">            return k;</span>
        } finally {
<span class="pc" id="L651">            lock.unlock();</span>
<span class="nc" id="L652">        }</span>
    }

    /**
     * Mark the DeterministicKeys as used, if they match the pubkey
     * See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     */
    @Nullable
    public DeterministicKey markPubKeyAsUsed(byte[] pubkey) {
<span class="fc" id="L661">        lock.lock();</span>
        try {
<span class="fc" id="L663">            DeterministicKey k = (DeterministicKey) basicKeyChain.findKeyFromPubKey(pubkey);</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">            if (k != null)</span>
<span class="fc" id="L665">                markKeyAsUsed(k);</span>
<span class="fc" id="L666">            return k;</span>
        } finally {
<span class="pc" id="L668">            lock.unlock();</span>
<span class="nc" id="L669">        }</span>
    }

    @Override
    public boolean hasKey(ECKey key) {
<span class="nc" id="L674">        lock.lock();</span>
        try {
<span class="nc" id="L676">            return basicKeyChain.hasKey(key);</span>
        } finally {
<span class="nc" id="L678">            lock.unlock();</span>
<span class="nc" id="L679">        }</span>
    }

    /** Returns the deterministic key for the given absolute path in the hierarchy. */
    protected DeterministicKey getKeyByPath(ChildNumber... path) {
<span class="nc" id="L684">        return getKeyByPath(ImmutableList.copyOf(path));</span>
    }

    /** Returns the deterministic key for the given absolute path in the hierarchy. */
    protected DeterministicKey getKeyByPath(List&lt;ChildNumber&gt; path) {
<span class="fc" id="L689">        return getKeyByPath(path, false);</span>
    }

    /** Returns the deterministic key for the given absolute path in the hierarchy, optionally creating it */
    public DeterministicKey getKeyByPath(List&lt;ChildNumber&gt; path, boolean create) {
<span class="fc" id="L694">        return hierarchy.get(path, false, create);</span>
    }

    /**
     * &lt;p&gt;An alias for &lt;code&gt;getKeyByPath(getAccountPath())&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;Use this when you would like to create a watching key chain that follows this one, but can't spend money from it.
     * The returned key can be serialized and then passed into {@link #watch(site.mtnsj.crypto.DeterministicKey)}
     * on another system to watch the hierarchy.&lt;/p&gt;
     *
     * &lt;p&gt;Note that the returned key is not pubkey only unless this key chain already is: the returned key can still
     * be used for signing etc if the private key bytes are available.&lt;/p&gt;
     */
    public DeterministicKey getWatchingKey() {
<span class="nc" id="L708">        List&lt;ChildNumber&gt; childNumbers = Lists.newArrayList(getAccountPath());</span>
        // first account only
<span class="nc bnc" id="L710" title="All 2 branches missed.">        if (keyChainType == KeyChainType.BIP44_MTNS_ONLY){</span>
<span class="nc" id="L711">            childNumbers.add(ChildNumber.ZERO);</span>
        }
<span class="nc" id="L713">        return getKeyByPath(childNumbers,true);</span>
    }

    /** Returns true if this chain is watch only, meaning it has public keys but no private key. */
    public boolean isWatching() {
<span class="nc" id="L718">        return getWatchingKey().isWatching();</span>
    }

    @Override
    public int numKeys() {
        // We need to return here the total number of keys including the lookahead zone, not the number of keys we
        // have issued via getKey/freshReceiveKey.
<span class="fc" id="L725">        lock.lock();</span>
        try {
<span class="fc" id="L727">            maybeLookAhead();</span>
<span class="fc" id="L728">            return basicKeyChain.numKeys();</span>
        } finally {
<span class="pc" id="L730">            lock.unlock();</span>
<span class="nc" id="L731">        }</span>

    }

    /**
     * Returns number of leaf keys used including both internal and external paths. This may be fewer than the number
     * that have been deserialized or held in memory, because of the lookahead zone.
     */
    public int numLeafKeysIssued() {
<span class="nc" id="L740">        lock.lock();</span>
        try {
<span class="nc" id="L742">            return issuedExternalKeys + issuedInternalKeys;</span>
        } finally {
<span class="nc" id="L744">            lock.unlock();</span>
<span class="nc" id="L745">        }</span>
    }

    @Override
    public long getEarliestKeyCreationTime() {
<span class="nc bnc" id="L750" title="All 2 branches missed.">        if (seed != null)</span>
<span class="nc" id="L751">            return seed.getCreationTimeSeconds();</span>
        else
<span class="nc" id="L753">            return getWatchingKey().getCreationTimeSeconds();</span>
    }

    @Override
    public void addEventListener(KeyChainEventListener listener) {
<span class="nc" id="L758">        basicKeyChain.addEventListener(listener);</span>
<span class="nc" id="L759">    }</span>

    @Override
    public void addEventListener(KeyChainEventListener listener, Executor executor) {
<span class="nc" id="L763">        basicKeyChain.addEventListener(listener, executor);</span>
<span class="nc" id="L764">    }</span>

    @Override
    public boolean removeEventListener(KeyChainEventListener listener) {
<span class="nc" id="L768">        return basicKeyChain.removeEventListener(listener);</span>
    }

    /** Returns a list of words that represent the seed or null if this chain is a watching chain. */
    @Nullable
    public List&lt;String&gt; getMnemonicCode() {
<span class="nc bnc" id="L774" title="All 2 branches missed.">        if (seed == null) return null;</span>

<span class="nc" id="L776">        lock.lock();</span>
        try {
<span class="nc" id="L778">            return seed.getMnemonicCode();</span>
        } finally {
<span class="nc" id="L780">            lock.unlock();</span>
<span class="nc" id="L781">        }</span>
    }

    /**
     * Return true if this keychain is following another keychain
     */
    public boolean isFollowing() {
<span class="fc" id="L788">        return isFollowing;</span>
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // Serialization support
    //
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public List&lt;Protos.Key&gt; serializeToProtobuf() {
<span class="fc" id="L799">        List&lt;Protos.Key&gt; result = newArrayList();</span>
<span class="fc" id="L800">        lock.lock();</span>
        try {
<span class="fc" id="L802">            result.addAll(serializeMyselfToProtobuf());</span>
        } finally {
<span class="pc" id="L804">            lock.unlock();</span>
<span class="pc" id="L805">        }</span>
<span class="fc" id="L806">        return result;</span>
    }

    protected List&lt;Protos.Key&gt; serializeMyselfToProtobuf() {
        // Most of the serialization work is delegated to the basic key chain, which will serialize the bulk of the
        // data (handling encryption along the way), and letting us patch it up with the extra data we care about.
<span class="fc" id="L812">        LinkedList&lt;Protos.Key&gt; entries = newLinkedList();</span>
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">        if (seed != null) {</span>
<span class="fc" id="L814">            Protos.Key.Builder mnemonicEntry = BasicKeyChain.serializeEncryptableItem(seed);</span>
<span class="fc" id="L815">            mnemonicEntry.setType(Protos.Key.Type.DETERMINISTIC_MNEMONIC);</span>
<span class="fc" id="L816">            serializeSeedEncryptableItem(seed, mnemonicEntry);</span>
<span class="fc" id="L817">            entries.add(mnemonicEntry.build());</span>
        }
<span class="fc" id="L819">        Map&lt;ECKey, Protos.Key.Builder&gt; keys = basicKeyChain.serializeToEditableProtobufs();</span>
<span class="fc bfc" id="L820" title="All 2 branches covered.">        for (Map.Entry&lt;ECKey, Protos.Key.Builder&gt; entry : keys.entrySet()) {</span>
<span class="fc" id="L821">            DeterministicKey key = (DeterministicKey) entry.getKey();</span>
<span class="fc" id="L822">            Protos.Key.Builder proto = entry.getValue();</span>
<span class="fc" id="L823">            proto.setType(Protos.Key.Type.DETERMINISTIC_KEY);</span>
<span class="fc" id="L824">            final Protos.DeterministicKey.Builder detKey = proto.getDeterministicKeyBuilder();</span>
<span class="fc" id="L825">            detKey.setChainCode(ByteString.copyFrom(key.getChainCode()));</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">            for (ChildNumber num : key.getPath())</span>
<span class="fc" id="L827">                detKey.addPath(num.i());</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">            if (key.equals(externalParentKey)) {</span>
<span class="fc" id="L829">                detKey.setIssuedSubkeys(issuedExternalKeys);</span>
<span class="fc" id="L830">                detKey.setLookaheadSize(lookaheadSize);</span>
<span class="fc" id="L831">                detKey.setSigsRequiredToSpend(getSigsRequiredToSpend());</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">            } else if (key.equals(internalParentKey)) {</span>
<span class="fc" id="L833">                detKey.setIssuedSubkeys(issuedInternalKeys);</span>
<span class="fc" id="L834">                detKey.setLookaheadSize(lookaheadSize);</span>
<span class="fc" id="L835">                detKey.setSigsRequiredToSpend(getSigsRequiredToSpend());</span>
            }
            // Flag the very first key of following keychain.
<span class="pc bpc" id="L838" title="3 of 4 branches missed.">            if (entries.isEmpty() &amp;&amp; isFollowing()) {</span>
<span class="nc" id="L839">                detKey.setIsFollowing(true);</span>
            }
<span class="fc bfc" id="L841" title="All 2 branches covered.">            if (key.getParent() != null) {</span>
                // HD keys inherit the timestamp of their parent if they have one, so no need to serialize it.
<span class="fc" id="L843">                proto.clearCreationTimestamp();</span>
            }
<span class="fc" id="L845">            entries.add(proto.build());</span>
<span class="fc" id="L846">        }</span>
<span class="fc" id="L847">        return entries;</span>
    }

    static List&lt;DeterministicKeyChain&gt; fromProtobuf(List&lt;Protos.Key&gt; keys, @Nullable KeyCrypter crypter) throws UnreadableWalletException {
<span class="nc" id="L851">        return fromProtobuf(keys, crypter, new DefaultKeyChainFactory());</span>
    }

    /**
     * Returns all the key chains found in the given list of keys. Typically there will only be one, but in the case of
     * key rotation it can happen that there are multiple chains found.
     */
    public static List&lt;DeterministicKeyChain&gt; fromProtobuf(List&lt;Protos.Key&gt; keys, @Nullable KeyCrypter crypter, KeyChainFactory factory) throws UnreadableWalletException {
<span class="fc" id="L859">        List&lt;DeterministicKeyChain&gt; chains = newLinkedList();</span>
<span class="fc" id="L860">        DeterministicSeed seed = null;</span>
<span class="fc" id="L861">        DeterministicKeyChain chain = null;</span>

<span class="fc" id="L863">        int lookaheadSize = -1;</span>
<span class="fc" id="L864">        int sigsRequiredToSpend = 1;</span>

        // Determine KeyChainType
<span class="fc" id="L867">        KeyChainType keyChainType = KeyChainType.BIP32;</span>
        // Quick loop to see if the first key correspond to a BIP44 path.
<span class="fc bfc" id="L869" title="All 2 branches covered.">        for (Protos.Key key : keys) {</span>
            // Deserialize the path through the tree.
<span class="fc" id="L871">            LinkedList&lt;ChildNumber&gt; path = newLinkedList();</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">            for (int i : key.getDeterministicKey().getPathList())</span>
<span class="fc" id="L873">                path.add(new ChildNumber(i));</span>
<span class="pc bpc" id="L874" title="1 of 4 branches missed.">            if (!path.isEmpty() &amp;&amp; path.get(0).equals(BIP44_MASTER_KEY)){</span>
                // is BIP44
<span class="nc" id="L876">                keyChainType = KeyChainType.BIP44_MTNS_ONLY;</span>
<span class="nc" id="L877">                break;</span>
            }
<span class="fc" id="L879">        }</span>

<span class="fc" id="L881">        PeekingIterator&lt;Protos.Key&gt; iter = Iterators.peekingIterator(keys.iterator());</span>
<span class="fc bfc" id="L882" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L883">            Protos.Key key = iter.next();</span>
<span class="fc" id="L884">            final Protos.Key.Type t = key.getType();</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">            if (t == Protos.Key.Type.DETERMINISTIC_MNEMONIC) {</span>
<span class="pc bpc" id="L886" title="1 of 2 branches missed.">                if (chain != null) {</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">                    checkState(lookaheadSize &gt;= 0);</span>
<span class="nc" id="L888">                    chain.setLookaheadSize(lookaheadSize);</span>
<span class="nc" id="L889">                    chain.setSigsRequiredToSpend(sigsRequiredToSpend);</span>
<span class="nc" id="L890">                    chain.maybeLookAhead();</span>
<span class="nc" id="L891">                    chains.add(chain);</span>
<span class="nc" id="L892">                    chain = null;</span>
                }
<span class="fc" id="L894">                long timestamp = key.getCreationTimestamp() / 1000;</span>
<span class="fc" id="L895">                String passphrase = DEFAULT_PASSPHRASE_FOR_MNEMONIC; // FIXME allow non-empty passphrase</span>
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">                if (key.hasSecretBytes()) {</span>
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">                    if (key.hasEncryptedDeterministicSeed())</span>
<span class="nc" id="L898">                        throw new UnreadableWalletException(&quot;Malformed key proto: &quot; + key.toString());</span>
<span class="fc" id="L899">                    byte[] seedBytes = null;</span>
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">                    if (key.hasDeterministicSeed()) {</span>
<span class="fc" id="L901">                        seedBytes = key.getDeterministicSeed().toByteArray();</span>
                    }
<span class="fc" id="L903">                    seed = new DeterministicSeed(key.getSecretBytes().toStringUtf8(), seedBytes, passphrase, timestamp);</span>
<span class="pc bnc" id="L904" title="All 2 branches missed.">                } else if (key.hasEncryptedData()) {</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">                    if (key.hasDeterministicSeed())</span>
<span class="nc" id="L906">                        throw new UnreadableWalletException(&quot;Malformed key proto: &quot; + key.toString());</span>
<span class="nc" id="L907">                    EncryptedData data = new EncryptedData(key.getEncryptedData().getInitialisationVector().toByteArray(),</span>
<span class="nc" id="L908">                            key.getEncryptedData().getEncryptedPrivateKey().toByteArray());</span>
<span class="nc" id="L909">                    EncryptedData encryptedSeedBytes = null;</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">                    if (key.hasEncryptedDeterministicSeed()) {</span>
<span class="nc" id="L911">                        Protos.EncryptedData encryptedSeed = key.getEncryptedDeterministicSeed();</span>
<span class="nc" id="L912">                        encryptedSeedBytes = new EncryptedData(encryptedSeed.getInitialisationVector().toByteArray(),</span>
<span class="nc" id="L913">                                encryptedSeed.getEncryptedPrivateKey().toByteArray());</span>
                    }
<span class="nc" id="L915">                    seed = new DeterministicSeed(data, encryptedSeedBytes, timestamp);</span>
<span class="nc" id="L916">                } else {</span>
<span class="nc" id="L917">                    throw new UnreadableWalletException(&quot;Malformed key proto: &quot; + key.toString());</span>
                }
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">                if (log.isDebugEnabled())</span>
<span class="nc" id="L920">                    log.debug(&quot;Deserializing: DETERMINISTIC_MNEMONIC: {}&quot;, seed);</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">            } else if (t == Protos.Key.Type.DETERMINISTIC_KEY) {</span>
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">                if (!key.hasDeterministicKey())</span>
<span class="nc" id="L923">                    throw new UnreadableWalletException(&quot;Deterministic key missing extra data: &quot; + key.toString());</span>
<span class="fc" id="L924">                byte[] chainCode = key.getDeterministicKey().getChainCode().toByteArray();</span>
                // Deserialize the path through the tree.
<span class="fc" id="L926">                LinkedList&lt;ChildNumber&gt; path = newLinkedList();</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">                for (int i : key.getDeterministicKey().getPathList())</span>
<span class="fc" id="L928">                    path.add(new ChildNumber(i));</span>
                // Deserialize the public key and path.
<span class="fc" id="L930">                LazyECPoint pubkey = new LazyECPoint(ECKey.CURVE.getCurve(), key.getPublicKey().toByteArray());</span>
<span class="fc" id="L931">                final ImmutableList&lt;ChildNumber&gt; immutablePath = ImmutableList.copyOf(path);</span>
                // Possibly create the chain, if we didn't already do so yet.
<span class="fc" id="L933">                boolean isWatchingAccountKey = false;</span>
<span class="fc" id="L934">                boolean isFollowingKey = false;</span>
                // save previous chain if any if the key is marked as following. Current key and the next ones are to be
                // placed in new following key chain
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">                if (key.getDeterministicKey().getIsFollowing()) {</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">                    if (chain != null) {</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">                        checkState(lookaheadSize &gt;= 0);</span>
<span class="nc" id="L940">                        chain.setLookaheadSize(lookaheadSize);</span>
<span class="nc" id="L941">                        chain.setSigsRequiredToSpend(sigsRequiredToSpend);</span>
<span class="nc" id="L942">                        chain.maybeLookAhead();</span>
<span class="nc" id="L943">                        chains.add(chain);</span>
<span class="nc" id="L944">                        chain = null;</span>
<span class="nc" id="L945">                        seed = null;</span>
                    }
<span class="nc" id="L947">                    isFollowingKey = true;</span>
                }
<span class="fc bfc" id="L949" title="All 2 branches covered.">                if (chain == null) {</span>
                    // If this is not a following chain and previous was, this must be married
<span class="pc bpc" id="L951" title="4 of 6 branches missed.">                    boolean isMarried = !isFollowingKey &amp;&amp; !chains.isEmpty() &amp;&amp; chains.get(chains.size() - 1).isFollowing();</span>
<span class="pc bpc" id="L952" title="1 of 2 branches missed.">                    if (seed == null) {</span>
<span class="nc" id="L953">                        DeterministicKey accountKey = new DeterministicKey(immutablePath, chainCode, pubkey, null, null);</span>
<span class="nc" id="L954">                        accountKey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000);</span>
<span class="nc" id="L955">                        chain = factory.makeWatchingKeyChain(key, iter.peek(), accountKey, isFollowingKey, isMarried);</span>
<span class="nc" id="L956">                        isWatchingAccountKey = true;</span>
<span class="nc" id="L957">                    } else {</span>
<span class="fc" id="L958">                        chain = factory.makeKeyChain(key, iter.peek(), seed, crypter, isMarried,keyChainType);</span>
<span class="fc" id="L959">                        chain.lookaheadSize = LAZY_CALCULATE_LOOKAHEAD;</span>
                        // If the seed is encrypted, then the chain is incomplete at this point. However, we will load
                        // it up below as we parse in the keys. We just need to check at the end that we've loaded
                        // everything afterwards.
                    }
                }
                // Find the parent key assuming this is not the root key, and not an account key for a watching chain.
<span class="fc" id="L966">                DeterministicKey parent = null;</span>
<span class="pc bpc" id="L967" title="1 of 4 branches missed.">                if (!path.isEmpty() &amp;&amp; !isWatchingAccountKey) {</span>
<span class="fc" id="L968">                    ChildNumber index = path.removeLast();</span>
<span class="fc" id="L969">                    parent = chain.hierarchy.get(path, false, false);</span>
<span class="fc" id="L970">                    path.add(index);</span>
                }
                DeterministicKey detkey;
<span class="fc bfc" id="L973" title="All 2 branches covered.">                if (key.hasSecretBytes()) {</span>
                    // Not encrypted: private key is available.
<span class="fc" id="L975">                    final BigInteger priv = new BigInteger(1, key.getSecretBytes().toByteArray());</span>
<span class="fc" id="L976">                    detkey = new DeterministicKey(immutablePath, chainCode, pubkey, priv, parent);</span>
<span class="fc" id="L977">                } else {</span>
<span class="pc bpc" id="L978" title="1 of 2 branches missed.">                    if (key.hasEncryptedData()) {</span>
<span class="nc" id="L979">                        Protos.EncryptedData proto = key.getEncryptedData();</span>
<span class="nc" id="L980">                        EncryptedData data = new EncryptedData(proto.getInitialisationVector().toByteArray(),</span>
<span class="nc" id="L981">                                proto.getEncryptedPrivateKey().toByteArray());</span>
<span class="nc" id="L982">                        checkNotNull(crypter, &quot;Encountered an encrypted key but no key crypter provided&quot;);</span>
<span class="nc" id="L983">                        detkey = new DeterministicKey(immutablePath, chainCode, crypter, pubkey, data, parent);</span>
<span class="nc" id="L984">                    } else {</span>
                        // No secret key bytes and key is not encrypted: either a watching key or private key bytes
                        // will be rederived on the fly from the parent.
<span class="fc" id="L987">                        detkey = new DeterministicKey(immutablePath, chainCode, pubkey, null, parent);</span>
                    }
                }
<span class="fc bfc" id="L990" title="All 2 branches covered.">                if (key.hasCreationTimestamp())</span>
<span class="fc" id="L991">                    detkey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000);</span>
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">                if (log.isDebugEnabled())</span>
<span class="nc" id="L993">                    log.debug(&quot;Deserializing: DETERMINISTIC_KEY: {}&quot;, detkey);</span>
<span class="pc bpc" id="L994" title="1 of 2 branches missed.">                if (!isWatchingAccountKey) {</span>
                    // If the non-encrypted case, the non-leaf keys (account, internal, external) have already
                    // been rederived and inserted at this point. In the encrypted case though,
                    // we can't rederive and we must reinsert, potentially building the heirarchy object
                    // if need be.
<span class="fc bfc" id="L999" title="All 2 branches covered.">                    if (path.size() == 0) {</span>
                        // Master key.
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">                        if (chain.rootKey == null) {</span>
<span class="nc" id="L1002">                            chain.rootKey = detkey;</span>
<span class="nc" id="L1003">                            chain.hierarchy = new DeterministicHierarchy(detkey);</span>
                        }
<span class="fc bfc" id="L1005" title="All 2 branches covered.">                    } else if (path.size() == chain.getAccountPath().size() + 1) {</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">                        if (detkey.getChildNumber().num() == 0) {</span>
<span class="fc" id="L1007">                            chain.externalParentKey = detkey;</span>
<span class="fc" id="L1008">                            chain.issuedExternalKeys = key.getDeterministicKey().getIssuedSubkeys();</span>
<span class="fc" id="L1009">                            lookaheadSize = Math.max(lookaheadSize, key.getDeterministicKey().getLookaheadSize());</span>
<span class="fc" id="L1010">                            sigsRequiredToSpend = key.getDeterministicKey().getSigsRequiredToSpend();</span>
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">                        } else if (detkey.getChildNumber().num() == 1) {</span>
<span class="fc" id="L1012">                            chain.internalParentKey = detkey;</span>
<span class="fc" id="L1013">                            chain.issuedInternalKeys = key.getDeterministicKey().getIssuedSubkeys();</span>
                        }
                    }
                }
<span class="fc" id="L1017">                chain.hierarchy.putKey(detkey);</span>
<span class="fc" id="L1018">                chain.basicKeyChain.importKey(detkey);</span>
            }
<span class="fc" id="L1020">        }</span>
<span class="pc bpc" id="L1021" title="1 of 2 branches missed.">        if (chain != null) {</span>
<span class="pc bpc" id="L1022" title="1 of 2 branches missed.">            checkState(lookaheadSize &gt;= 0);</span>
<span class="fc" id="L1023">            chain.setLookaheadSize(lookaheadSize);</span>
<span class="fc" id="L1024">            chain.setSigsRequiredToSpend(sigsRequiredToSpend);</span>
<span class="fc" id="L1025">            chain.maybeLookAhead();</span>
<span class="fc" id="L1026">            chains.add(chain);</span>
        }
<span class="fc" id="L1028">        return chains;</span>
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // Encryption support
    //
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public DeterministicKeyChain toEncrypted(CharSequence password) {
<span class="nc" id="L1039">        checkNotNull(password);</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">        checkArgument(password.length() &gt; 0);</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">        checkState(seed != null, &quot;Attempt to encrypt a watching chain.&quot;);</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">        checkState(!seed.isEncrypted());</span>
<span class="nc" id="L1043">        KeyCrypter scrypt = new KeyCrypterScrypt();</span>
<span class="nc" id="L1044">        KeyParameter derivedKey = scrypt.deriveKey(password);</span>
<span class="nc" id="L1045">        return toEncrypted(scrypt, derivedKey);</span>
    }

    @Override
    public DeterministicKeyChain toEncrypted(KeyCrypter keyCrypter, KeyParameter aesKey) {
<span class="nc" id="L1050">        return new DeterministicKeyChain(keyCrypter, aesKey, this);</span>
    }

    @Override
    public DeterministicKeyChain toDecrypted(CharSequence password) {
<span class="nc" id="L1055">        checkNotNull(password);</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">        checkArgument(password.length() &gt; 0);</span>
<span class="nc" id="L1057">        KeyCrypter crypter = getKeyCrypter();</span>
<span class="nc bnc" id="L1058" title="All 2 branches missed.">        checkState(crypter != null, &quot;Chain not encrypted&quot;);</span>
<span class="nc" id="L1059">        KeyParameter derivedKey = crypter.deriveKey(password);</span>
<span class="nc" id="L1060">        return toDecrypted(derivedKey);</span>
    }

    @Override
    public DeterministicKeyChain toDecrypted(KeyParameter aesKey) {
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        checkState(getKeyCrypter() != null, &quot;Key chain not encrypted&quot;);</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">        checkState(seed != null, &quot;Can't decrypt a watching chain&quot;);</span>
<span class="nc" id="L1067">        checkState(seed.isEncrypted());</span>
<span class="nc" id="L1068">        String passphrase = DEFAULT_PASSPHRASE_FOR_MNEMONIC; // FIXME allow non-empty passphrase</span>
<span class="nc" id="L1069">        DeterministicSeed decSeed = seed.decrypt(getKeyCrypter(), passphrase, aesKey);</span>
<span class="nc" id="L1070">        DeterministicKeyChain chain = makeKeyChainFromSeed(decSeed);</span>
        // Now double check that the keys match to catch the case where the key is wrong but padding didn't catch it.
<span class="nc bnc" id="L1072" title="All 2 branches missed.">        if (!chain.getWatchingKey().getPubKeyPoint().equals(getWatchingKey().getPubKeyPoint()))</span>
<span class="nc" id="L1073">            throw new KeyCrypterException(&quot;Provided AES key is wrong&quot;);</span>
<span class="nc" id="L1074">        chain.lookaheadSize = lookaheadSize;</span>
        // Now copy the (pubkey only) leaf keys across to avoid rederiving them. The private key bytes are missing
        // anyway so there's nothing to decrypt.
<span class="nc bnc" id="L1077" title="All 2 branches missed.">        for (ECKey eckey : basicKeyChain.getKeys()) {</span>
<span class="nc" id="L1078">            DeterministicKey key = (DeterministicKey) eckey;</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">            if (key.getPath().size() != getAccountPath().size() + 2) continue; // Not a leaf key.</span>
<span class="nc" id="L1080">            checkState(key.isEncrypted());</span>
<span class="nc" id="L1081">            DeterministicKey parent = chain.hierarchy.get(checkNotNull(key.getParent()).getPath(), false, false);</span>
            // Clone the key to the new decrypted hierarchy.
<span class="nc" id="L1083">            key = new DeterministicKey(key.dropPrivateBytes(), parent);</span>
<span class="nc" id="L1084">            chain.hierarchy.putKey(key);</span>
<span class="nc" id="L1085">            chain.basicKeyChain.importKey(key);</span>
<span class="nc" id="L1086">        }</span>
<span class="nc" id="L1087">        chain.issuedExternalKeys = issuedExternalKeys;</span>
<span class="nc" id="L1088">        chain.issuedInternalKeys = issuedInternalKeys;</span>
<span class="nc" id="L1089">        return chain;</span>
    }

    /**
     * Factory method to create a key chain from a seed.
     * Subclasses should override this to create an instance of the subclass instead of a plain DKC.
     * This is used in encryption/decryption.
     */
    protected DeterministicKeyChain makeKeyChainFromSeed(DeterministicSeed seed) {
<span class="nc" id="L1098">        return new DeterministicKeyChain(seed);</span>
    }

    @Override
    public boolean checkPassword(CharSequence password) {
<span class="nc" id="L1103">        checkNotNull(password);</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">        checkState(getKeyCrypter() != null, &quot;Key chain not encrypted&quot;);</span>
<span class="nc" id="L1105">        return checkAESKey(getKeyCrypter().deriveKey(password));</span>
    }

    @Override
    public boolean checkAESKey(KeyParameter aesKey) {
<span class="nc bnc" id="L1110" title="All 2 branches missed.">        checkState(rootKey != null, &quot;Can't check password for a watching chain&quot;);</span>
<span class="nc" id="L1111">        checkNotNull(aesKey);</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">        checkState(getKeyCrypter() != null, &quot;Key chain not encrypted&quot;);</span>
        try {
<span class="nc" id="L1114">            return rootKey.decrypt(aesKey).getPubKeyPoint().equals(rootKey.getPubKeyPoint());</span>
<span class="nc" id="L1115">        } catch (KeyCrypterException e) {</span>
<span class="nc" id="L1116">            return false;</span>
        }
    }

    @Nullable
    @Override
    public KeyCrypter getKeyCrypter() {
<span class="nc" id="L1123">        return basicKeyChain.getKeyCrypter();</span>
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // Bloom filtering support
    //
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    @Override
    public int numBloomFilterEntries() {
<span class="nc" id="L1135">        return numKeys() * 2;</span>
    }

    @Override
    public BloomFilter getFilter(int size, double falsePositiveRate, long tweak) {
<span class="nc" id="L1140">        lock.lock();</span>
        try {
<span class="nc bnc" id="L1142" title="All 2 branches missed.">            checkArgument(size &gt;= numBloomFilterEntries());</span>
<span class="nc" id="L1143">            maybeLookAhead();</span>
<span class="nc" id="L1144">            return basicKeyChain.getFilter(size, falsePositiveRate, tweak);</span>
        } finally {
<span class="nc" id="L1146">            lock.unlock();</span>
<span class="nc" id="L1147">        }</span>

    }

    /**
     * &lt;p&gt;The number of public keys we should pre-generate on each path before they are requested by the app. This is
     * required so that when scanning through the chain given only a seed, we can give enough keys to the remote node
     * via the Bloom filter such that we see transactions that are &quot;from the future&quot;, for example transactions created
     * by a different app that's sharing the same seed, or transactions we made before but we're replaying the chain
     * given just the seed. The default is 100.&lt;/p&gt;
     */
    public int getLookaheadSize() {
<span class="fc" id="L1159">        lock.lock();</span>
        try {
<span class="fc" id="L1161">            return lookaheadSize;</span>
        } finally {
<span class="pc" id="L1163">            lock.unlock();</span>
<span class="nc" id="L1164">        }</span>
    }

    /**
     * Sets a new lookahead size. See {@link #getLookaheadSize()} for details on what this is. Setting a new size
     * that's larger than the current size will return immediately and the new size will only take effect next time
     * a fresh filter is requested (e.g. due to a new peer being connected). So you should set this before starting
     * to sync the chain, if you want to modify it. If you haven't modified the lookahead threshold manually then
     * it will be automatically set to be a third of the new size.
     */
    public void setLookaheadSize(int lookaheadSize) {
<span class="fc" id="L1175">        lock.lock();</span>
        try {
<span class="fc bfc" id="L1177" title="All 2 branches covered.">            boolean readjustThreshold = this.lookaheadThreshold == calcDefaultLookaheadThreshold();</span>
<span class="fc" id="L1178">            this.lookaheadSize = lookaheadSize;</span>
<span class="fc bfc" id="L1179" title="All 2 branches covered.">            if (readjustThreshold)</span>
<span class="fc" id="L1180">                this.lookaheadThreshold = calcDefaultLookaheadThreshold();</span>
        } finally {
<span class="pc" id="L1182">            lock.unlock();</span>
<span class="pc" id="L1183">        }</span>
<span class="fc" id="L1184">    }</span>

    /**
     * Sets the threshold for the key pre-generation. This is used to avoid adding new keys and thus
     * re-calculating Bloom filters every time a new key is calculated. Without a lookahead threshold, every time we
     * received a relevant transaction we'd extend the lookahead zone and generate a new filter, which is inefficient.
     */
    public void setLookaheadThreshold(int num) {
<span class="nc" id="L1192">        lock.lock();</span>
        try {
<span class="nc bnc" id="L1194" title="All 2 branches missed.">            if (num &gt;= lookaheadSize)</span>
<span class="nc" id="L1195">                throw new IllegalArgumentException(&quot;Threshold larger or equal to the lookaheadSize&quot;);</span>
<span class="nc" id="L1196">            this.lookaheadThreshold = num;</span>
        } finally {
<span class="nc" id="L1198">            lock.unlock();</span>
<span class="nc" id="L1199">        }</span>
<span class="nc" id="L1200">    }</span>

    /**
     * Gets the threshold for the key pre-generation. See {@link #setLookaheadThreshold(int)} for details on what this
     * is. The default is a third of the lookahead size (100 / 3 == 33). If you don't modify it explicitly then this
     * value will always be one third of the lookahead size.
     */
    public int getLookaheadThreshold() {
<span class="fc" id="L1208">        lock.lock();</span>
        try {
<span class="pc bpc" id="L1210" title="1 of 2 branches missed.">            if (lookaheadThreshold &gt;= lookaheadSize)</span>
<span class="fc" id="L1211">                return 0;</span>
<span class="nc" id="L1212">            return lookaheadThreshold;</span>
        } finally {
<span class="pc" id="L1214">            lock.unlock();</span>
<span class="nc" id="L1215">        }</span>
    }

    /**
     * Pre-generate enough keys to reach the lookahead size. You can call this if you need to explicitly invoke
     * the lookahead procedure, but it's normally unnecessary as it will be done automatically when needed.
     */
    public void maybeLookAhead() {
<span class="fc" id="L1223">        lock.lock();</span>
        try {
<span class="fc" id="L1225">            List&lt;DeterministicKey&gt; keys = maybeLookAhead(externalParentKey, issuedExternalKeys);</span>
<span class="fc" id="L1226">            keys.addAll(maybeLookAhead(internalParentKey, issuedInternalKeys));</span>
<span class="fc bfc" id="L1227" title="All 2 branches covered.">            if (keys.isEmpty())</span>
<span class="fc" id="L1228">                return;</span>
<span class="fc" id="L1229">            keyLookaheadEpoch++;</span>
            // Batch add all keys at once so there's only one event listener invocation, as this will be listened to
            // by the wallet and used to rebuild/broadcast the Bloom filter. That's expensive so we don't want to do
            // it more often than necessary.
<span class="fc" id="L1233">            basicKeyChain.importKeys(keys);</span>
        } finally {
<span class="pc" id="L1235">            lock.unlock();</span>
<span class="pc" id="L1236">        }</span>
<span class="fc" id="L1237">    }</span>

    private List&lt;DeterministicKey&gt; maybeLookAhead(DeterministicKey parent, int issued) {
<span class="fc" id="L1240">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L1241">        return maybeLookAhead(parent, issued, getLookaheadSize(), getLookaheadThreshold());</span>
    }

    /**
     * Pre-generate enough keys to reach the lookahead size, but only if there are more than the lookaheadThreshold to
     * be generated, so that the Bloom filter does not have to be regenerated that often.
     *
     * The returned mutable list of keys must be inserted into the basic key chain.
     */
    private List&lt;DeterministicKey&gt; maybeLookAhead(DeterministicKey parent, int issued, int lookaheadSize, int lookaheadThreshold) {
<span class="fc" id="L1251">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L1252">        final int numChildren = hierarchy.getNumChildren(parent.getPath());</span>
<span class="fc" id="L1253">        final int needed = issued + lookaheadSize + lookaheadThreshold - numChildren;</span>

<span class="fc bfc" id="L1255" title="All 2 branches covered.">        if (needed &lt;= lookaheadThreshold)</span>
<span class="fc" id="L1256">            return new ArrayList&lt;DeterministicKey&gt;();</span>

<span class="fc" id="L1258">        log.info(&quot;{} keys needed for {} = {} issued + {} lookahead size + {} lookahead threshold - {} num children&quot;,</span>
<span class="fc" id="L1259">                needed, parent.getPathAsString(), issued, lookaheadSize, lookaheadThreshold, numChildren);</span>

<span class="fc" id="L1261">        List&lt;DeterministicKey&gt; result  = new ArrayList&lt;DeterministicKey&gt;(needed);</span>
<span class="fc" id="L1262">        final Stopwatch watch = Stopwatch.createStarted();</span>
<span class="fc" id="L1263">        int nextChild = numChildren;</span>
<span class="fc bfc" id="L1264" title="All 2 branches covered.">        for (int i = 0; i &lt; needed; i++) {</span>
<span class="fc" id="L1265">            DeterministicKey key = HDKeyDerivation.deriveThisOrNextChildKey(parent, nextChild);</span>
<span class="fc" id="L1266">            key = key.dropPrivateBytes();</span>
<span class="fc" id="L1267">            hierarchy.putKey(key);</span>
<span class="fc" id="L1268">            result.add(key);</span>
<span class="fc" id="L1269">            nextChild = key.getChildNumber().num() + 1;</span>
        }
<span class="fc" id="L1271">        watch.stop();</span>
<span class="fc" id="L1272">        log.info(&quot;Took {}&quot;, watch);</span>
<span class="fc" id="L1273">        return result;</span>
    }

    /** Housekeeping call to call when lookahead might be needed.  Normally called automatically by KeychainGroup. */
    public void maybeLookAheadScripts() {
<span class="fc" id="L1278">    }</span>

    /**
     * Returns number of keys used on external path. This may be fewer than the number that have been deserialized
     * or held in memory, because of the lookahead zone.
     */
    public int getIssuedExternalKeys() {
<span class="fc" id="L1285">        lock.lock();</span>
        try {
<span class="fc" id="L1287">            return issuedExternalKeys;</span>
        } finally {
<span class="pc" id="L1289">            lock.unlock();</span>
<span class="nc" id="L1290">        }</span>
    }

    /**
     * Returns number of keys used on internal path. This may be fewer than the number that have been deserialized
     * or held in memory, because of the lookahead zone.
     */
    public int getIssuedInternalKeys() {
<span class="fc" id="L1298">        lock.lock();</span>
        try {
<span class="fc" id="L1300">            return issuedInternalKeys;</span>
        } finally {
<span class="pc" id="L1302">            lock.unlock();</span>
<span class="nc" id="L1303">        }</span>
    }

    /** Returns the seed or null if this chain is a watching chain. */
    @Nullable
    public DeterministicSeed getSeed() {
<span class="nc" id="L1309">        lock.lock();</span>
        try {
<span class="nc" id="L1311">            return seed;</span>
        } finally {
<span class="nc" id="L1313">            lock.unlock();</span>
<span class="nc" id="L1314">        }</span>
    }

    // For internal usage only
    /* package */ List&lt;ECKey&gt; getKeys(boolean includeLookahead) {
<span class="fc" id="L1319">        List&lt;ECKey&gt; keys = basicKeyChain.getKeys();</span>
<span class="pc bpc" id="L1320" title="1 of 2 branches missed.">        if (!includeLookahead) {</span>
<span class="nc" id="L1321">            int treeSize = internalParentKey.getPath().size();</span>
<span class="nc" id="L1322">            List&lt;ECKey&gt; issuedKeys = new LinkedList&lt;ECKey&gt;();</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">            for (ECKey key : keys) {</span>
<span class="nc" id="L1324">                DeterministicKey detkey = (DeterministicKey) key;</span>
<span class="nc" id="L1325">                DeterministicKey parent = detkey.getParent();</span>
<span class="nc bnc" id="L1326" title="All 2 branches missed.">                if (parent == null) continue;</span>
<span class="nc bnc" id="L1327" title="All 2 branches missed.">                if (detkey.getPath().size() &lt;= treeSize) continue;</span>
<span class="nc bnc" id="L1328" title="All 4 branches missed.">                if (parent.equals(internalParentKey) &amp;&amp; detkey.getChildNumber().i() &gt;= issuedInternalKeys) continue;</span>
<span class="nc bnc" id="L1329" title="All 4 branches missed.">                if (parent.equals(externalParentKey) &amp;&amp; detkey.getChildNumber().i() &gt;= issuedExternalKeys) continue;</span>
<span class="nc" id="L1330">                issuedKeys.add(detkey);</span>
<span class="nc" id="L1331">            }</span>
<span class="nc" id="L1332">            return issuedKeys;</span>
        }
<span class="fc" id="L1334">        return keys;</span>
    }

    /**
     * Returns only the external keys that have been issued by this chain, lookahead not included.
     */
    public List&lt;ECKey&gt; getIssuedReceiveKeys() {
<span class="nc" id="L1341">        final List&lt;ECKey&gt; keys = new ArrayList&lt;ECKey&gt;(getKeys(false));</span>
<span class="nc bnc" id="L1342" title="All 2 branches missed.">        for (Iterator&lt;ECKey&gt; i = keys.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1343">            DeterministicKey parent = ((DeterministicKey) i.next()).getParent();</span>
<span class="nc bnc" id="L1344" title="All 4 branches missed.">            if (parent == null || !externalParentKey.equals(parent))</span>
<span class="nc" id="L1345">                i.remove();</span>
<span class="nc" id="L1346">        }</span>
<span class="nc" id="L1347">        return keys;</span>
    }

    /**
     * Returns leaf keys issued by this chain (including lookahead zone)
     */
    public List&lt;DeterministicKey&gt; getLeafKeys() {
<span class="fc" id="L1354">        ImmutableList.Builder&lt;DeterministicKey&gt; keys = ImmutableList.builder();</span>
<span class="fc bfc" id="L1355" title="All 2 branches covered.">        for (ECKey key : getKeys(true)) {</span>
<span class="fc" id="L1356">            DeterministicKey dKey = (DeterministicKey) key;</span>
<span class="fc bfc" id="L1357" title="All 2 branches covered.">            if (dKey.getPath().size() == getAccountPath().size() + 2) {</span>
<span class="fc" id="L1358">                keys.add(dKey);</span>
            }
<span class="fc" id="L1360">        }</span>
<span class="fc" id="L1361">        return keys.build();</span>
    }

    /*package*/ static void serializeSeedEncryptableItem(DeterministicSeed seed, Protos.Key.Builder proto) {
        // The seed can be missing if we have not derived it yet from the mnemonic.
        // This will not normally happen once all the wallets are on the latest code that caches
        // the seed.
<span class="pc bpc" id="L1368" title="3 of 4 branches missed.">        if (seed.isEncrypted() &amp;&amp; seed.getEncryptedSeedData() != null) {</span>
<span class="nc" id="L1369">            EncryptedData data = seed.getEncryptedSeedData();</span>
<span class="nc" id="L1370">            proto.getEncryptedDeterministicSeedBuilder()</span>
<span class="nc" id="L1371">                    .setEncryptedPrivateKey(ByteString.copyFrom(data.encryptedBytes))</span>
<span class="nc" id="L1372">                    .setInitialisationVector(ByteString.copyFrom(data.initialisationVector));</span>
            // We don't allow mixing of encryption types at the moment.
<span class="nc bnc" id="L1374" title="All 2 branches missed.">            checkState(seed.getEncryptionType() == Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES);</span>
<span class="nc" id="L1375">        } else {</span>
<span class="fc" id="L1376">            final byte[] secret = seed.getSeedBytes();</span>
<span class="pc bpc" id="L1377" title="1 of 2 branches missed.">            if (secret != null)</span>
<span class="fc" id="L1378">                proto.setDeterministicSeed(ByteString.copyFrom(secret));</span>
        }
<span class="fc" id="L1380">    }</span>

    /**
     * Returns a counter that is incremented each time new keys are generated due to lookahead. Used by the network
     * code to learn whether to discard the current block and await calculation of a new filter.
     */
    public int getKeyLookaheadEpoch() {
<span class="nc" id="L1387">        lock.lock();</span>
        try {
<span class="nc" id="L1389">            return keyLookaheadEpoch;</span>
        } finally {
<span class="nc" id="L1391">            lock.unlock();</span>
<span class="nc" id="L1392">        }</span>
    }

    /**
     * Whether the keychain is married.  A keychain is married when it vends P2SH addresses
     * from multiple keychains in a multisig relationship.
     * @see site.mtnsj.wallet.MarriedKeyChain
     */
    public boolean isMarried() {
<span class="fc" id="L1401">        return false;</span>
    }

    /** Get redeem data for a key.  Only applicable to married keychains. */
    public RedeemData getRedeemData(DeterministicKey followedKey) {
<span class="nc" id="L1406">        throw new UnsupportedOperationException();</span>
    }

    /** Create a new key and return the matching output script.  Only applicable to married keychains. */
    public Script freshOutputScript(KeyPurpose purpose) {
<span class="nc" id="L1411">        throw new UnsupportedOperationException();</span>
    }

    public String toString(boolean includePrivateKeys, NetworkParameters params) {
<span class="nc" id="L1415">        final DeterministicKey watchingKey = getWatchingKey();</span>
<span class="nc" id="L1416">        final StringBuilder builder = new StringBuilder();</span>
<span class="nc bnc" id="L1417" title="All 2 branches missed.">        if (seed != null) {</span>
<span class="nc bnc" id="L1418" title="All 2 branches missed.">            if (seed.isEncrypted()) {</span>
<span class="nc" id="L1419">                builder.append(&quot;Seed is encrypted\n&quot;);</span>
<span class="nc bnc" id="L1420" title="All 2 branches missed.">            } else if (includePrivateKeys) {</span>
<span class="nc" id="L1421">                final List&lt;String&gt; words = seed.getMnemonicCode();</span>
<span class="nc" id="L1422">                builder.append(&quot;Seed as words: &quot;).append(Utils.join(words)).append('\n');</span>
<span class="nc" id="L1423">                builder.append(&quot;Seed as hex:   &quot;).append(seed.toHexString()).append('\n');</span>
            }
<span class="nc" id="L1425">            builder.append(&quot;Seed birthday: &quot;).append(seed.getCreationTimeSeconds()).append(&quot;  [&quot;)</span>
<span class="nc" id="L1426">                    .append(Utils.dateTimeFormat(seed.getCreationTimeSeconds() * 1000)).append(&quot;]\n&quot;);</span>
        } else {
<span class="nc" id="L1428">            builder.append(&quot;Key birthday:  &quot;).append(watchingKey.getCreationTimeSeconds()).append(&quot;  [&quot;)</span>
<span class="nc" id="L1429">                    .append(Utils.dateTimeFormat(watchingKey.getCreationTimeSeconds() * 1000)).append(&quot;]\n&quot;);</span>
        }
<span class="nc" id="L1431">        builder.append(&quot;Key to watch:  &quot;).append(watchingKey.serializePubB58(params)).append('\n');</span>
<span class="nc" id="L1432">        formatAddresses(includePrivateKeys, params, builder);</span>
<span class="nc" id="L1433">        return builder.toString();</span>
    }

    protected void formatAddresses(boolean includePrivateKeys, NetworkParameters params, StringBuilder builder2) {
<span class="nc bnc" id="L1437" title="All 2 branches missed.">        for (ECKey key : getKeys(false))</span>
<span class="nc" id="L1438">            key.formatKeyWithAddress(includePrivateKeys, builder2, params);</span>
<span class="nc" id="L1439">    }</span>

    /** The number of signatures required to spend coins received by this keychain. */
    public void setSigsRequiredToSpend(int sigsRequiredToSpend) {
<span class="fc" id="L1443">        this.sigsRequiredToSpend = sigsRequiredToSpend;</span>
<span class="fc" id="L1444">    }</span>

    /**
     * Returns the number of signatures required to spend transactions for this KeyChain. It's the N from
     * N-of-M CHECKMULTISIG script for P2SH transactions and always 1 for other transaction types.
     */
    public int getSigsRequiredToSpend() {
<span class="fc" id="L1451">        return sigsRequiredToSpend;</span>
    }

    /** Returns the redeem script by its hash or null if this keychain did not generate the script. */
    @Nullable
    public RedeemData findRedeemDataByScriptHash(ByteString bytes) {
<span class="nc" id="L1457">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>