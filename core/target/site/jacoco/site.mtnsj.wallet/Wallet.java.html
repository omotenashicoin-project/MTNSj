<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Wallet.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mtnsj</a> &gt; <a href="index.source.html" class="el_package">site.mtnsj.wallet</a> &gt; <span class="el_source">Wallet.java</span></div><h1>Wallet.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Google Inc.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package site.mtnsj.wallet;

import com.google.common.annotations.*;
import com.google.common.base.*;
import com.google.common.collect.*;
import com.google.common.primitives.*;
import com.google.common.util.concurrent.*;
import com.google.protobuf.*;
import net.jcip.annotations.*;
import site.mtnsj.core.*;
import site.mtnsj.core.Message;
import site.mtnsj.core.listeners.*;
import site.mtnsj.core.TransactionConfidence.*;
import site.mtnsj.crypto.*;
import site.mtnsj.script.*;
import site.mtnsj.signers.*;
import site.mtnsj.utils.*;
import site.mtnsj.wallet.Protos.Wallet.*;
import site.mtnsj.wallet.WalletTransaction.*;
import site.mtnsj.wallet.listeners.KeyChainEventListener;
import site.mtnsj.wallet.listeners.ScriptsChangeEventListener;
import site.mtnsj.wallet.listeners.WalletChangeEventListener;
import site.mtnsj.wallet.listeners.WalletCoinsReceivedEventListener;
import site.mtnsj.wallet.listeners.WalletCoinsSentEventListener;
import site.mtnsj.wallet.listeners.WalletEventListener;
import site.mtnsj.wallet.listeners.WalletReorganizeEventListener;
import org.slf4j.*;
import org.spongycastle.crypto.params.*;

import javax.annotation.*;
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import java.util.concurrent.locks.*;

import static com.google.common.base.Preconditions.*;
import static java.lang.Math.max;


// To do list:
//
// - Take all wallet-relevant data out of Transaction and put it into WalletTransaction. Make Transaction immutable.
// - Only store relevant transaction outputs, don't bother storing the rest of the data. Big RAM saving.
// - Split block chain and tx output tracking into a superclass that doesn't have any key or spending related code.
// - Simplify how transactions are tracked and stored: in particular, have the wallet maintain positioning information
//   for transactions independent of the transactions themselves, so the timeline can be walked without having to
//   process and sort every single transaction.
// - Split data persistence out into a backend class and make the wallet transactional, so we can store a wallet
//   in a database not just in RAM.
// - Make clearing of transactions able to only rewind the wallet a certain distance instead of all blocks.
// - Make it scale:
//     - eliminate all the algorithms with quadratic complexity (or worse)
//     - don't require everything to be held in RAM at once
//     - consider allowing eviction of no longer re-orgable transactions or keys that were used up
//
// Finally, find more ways to break the class up and decompose it. Currently every time we move code out, other code
// fills up the lines saved!

/**
 * &lt;p&gt;A Wallet stores keys and a record of transactions that send and receive value from those keys. Using these,
 * it is able to create new transactions that spend the recorded transactions, and this is the fundamental operation
 * of the Bitcoin protocol.&lt;/p&gt;
 *
 * &lt;p&gt;To learn more about this class, read &lt;b&gt;&lt;a href=&quot;https://bitcoinj.github.io/working-with-the-wallet&quot;&gt;
 *     working with the wallet.&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;
 *
 * &lt;p&gt;To fill up a Wallet with transactions, you need to use it in combination with a {@link BlockChain} and various
 * other objects, see the &lt;a href=&quot;https://bitcoinj.github.io/getting-started&quot;&gt;Getting started&lt;/a&gt; tutorial
 * on the website to learn more about how to set everything up.&lt;/p&gt;
 *
 * &lt;p&gt;Wallets can be serialized using protocol buffers. You need to save the wallet whenever it changes, there is an
 * auto-save feature that simplifies this for you although you're still responsible for manually triggering a save when
 * your app is about to quit because the auto-save feature waits a moment before actually committing to disk to avoid IO
 * thrashing when the wallet is changing very fast (eg due to a block chain sync). See
 * {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, site.mtnsj.wallet.WalletFiles.Listener)}
 * for more information about this.&lt;/p&gt;
 */
public class Wallet extends BaseTaggableObject
    implements NewBestBlockListener, TransactionReceivedInBlockListener, PeerFilterProvider, KeyBag, TransactionBag, ReorganizeListener {
<span class="fc" id="L99">    private static final Logger log = LoggerFactory.getLogger(Wallet.class);</span>
    private static final int MINIMUM_BLOOM_DATA_LENGTH = 8;

    // Ordering: lock &gt; keyChainGroupLock. KeyChainGroup is protected separately to allow fast querying of current receive address
    // even if the wallet itself is busy e.g. saving or processing a big reorg. Useful for reducing UI latency.
<span class="fc" id="L104">    protected final ReentrantLock lock = Threading.lock(&quot;wallet&quot;);</span>
<span class="fc" id="L105">    protected final ReentrantLock keyChainGroupLock = Threading.lock(&quot;wallet-keychaingroup&quot;);</span>

    // The various pools below give quick access to wallet-relevant transactions by the state they're in:
    //
    // Pending:  Transactions that didn't make it into the best chain yet. Pending transactions can be killed if a
    //           double spend against them appears in the best chain, in which case they move to the dead pool.
    //           If a double spend appears in the pending state as well, we update the confidence type
    //           of all txns in conflict to IN_CONFLICT and wait for the miners to resolve the race.
    // Unspent:  Transactions that appeared in the best chain and have outputs we can spend. Note that we store the
    //           entire transaction in memory even though for spending purposes we only really need the outputs, the
    //           reason being that this simplifies handling of re-orgs. It would be worth fixing this in future.
    // Spent:    Transactions that appeared in the best chain but don't have any spendable outputs. They're stored here
    //           for history browsing/auditing reasons only and in future will probably be flushed out to some other
    //           kind of cold storage or just removed.
    // Dead:     Transactions that we believe will never confirm get moved here, out of pending. Note that Bitcoin
    //           Core has no notion of dead-ness: the assumption is that double spends won't happen so there's no
    //           need to notify the user about them. We take a more pessimistic approach and try to track the fact that
    //           transactions have been double spent so applications can do something intelligent (cancel orders, show
    //           to the user in the UI, etc). A transaction can leave dead and move into spent/unspent if there is a
    //           re-org to a chain that doesn't include the double spend.

    private final Map&lt;Sha256Hash, Transaction&gt; pending;
    private final Map&lt;Sha256Hash, Transaction&gt; unspent;
    private final Map&lt;Sha256Hash, Transaction&gt; spent;
    private final Map&lt;Sha256Hash, Transaction&gt; dead;

    // All transactions together.
    protected final Map&lt;Sha256Hash, Transaction&gt; transactions;

    // All the TransactionOutput objects that we could spend (ignoring whether we have the private key or not).
    // Used to speed up various calculations.
<span class="fc" id="L136">    protected final HashSet&lt;TransactionOutput&gt; myUnspents = Sets.newHashSet();</span>

    // Transactions that were dropped by the risk analysis system. These are not in any pools and not serialized
    // to disk. We have to keep them around because if we ignore a tx because we think it will never confirm, but
    // then it actually does confirm and does so within the same network session, remote peers will not resend us
    // the tx data along with the Bloom filtered block, as they know we already received it once before
    // (so it would be wasteful to repeat). Thus we keep them around here for a while. If we drop our network
    // connections then the remote peers will forget that we were sent the tx data previously and send it again
    // when relaying a filtered merkleblock.
<span class="fc" id="L145">    private final LinkedHashMap&lt;Sha256Hash, Transaction&gt; riskDropped = new LinkedHashMap&lt;Sha256Hash, Transaction&gt;() {</span>
        @Override
        protected boolean removeEldestEntry(Map.Entry&lt;Sha256Hash, Transaction&gt; eldest) {
<span class="nc bnc" id="L148" title="All 2 branches missed.">            return size() &gt; 1000;</span>
        }
    };

    // The key chain group is not thread safe, and generally the whole hierarchy of objects should not be mutated
    // outside the wallet lock. So don't expose this object directly via any accessors!
    @GuardedBy(&quot;keyChainGroupLock&quot;) private KeyChainGroup keyChainGroup;

    // A list of scripts watched by this wallet.
    @GuardedBy(&quot;keyChainGroupLock&quot;) private Set&lt;Script&gt; watchedScripts;

    protected final Context context;
    protected final NetworkParameters params;

    @Nullable private Sha256Hash lastBlockSeenHash;
    private int lastBlockSeenHeight;
    private long lastBlockSeenTimeSecs;

<span class="fc" id="L166">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;WalletChangeEventListener&gt;&gt; changeListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;WalletChangeEventListener&gt;&gt;();
<span class="fc" id="L168">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;WalletCoinsReceivedEventListener&gt;&gt; coinsReceivedListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;WalletCoinsReceivedEventListener&gt;&gt;();
<span class="fc" id="L170">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;WalletCoinsSentEventListener&gt;&gt; coinsSentListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;WalletCoinsSentEventListener&gt;&gt;();
<span class="fc" id="L172">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;WalletReorganizeEventListener&gt;&gt; reorganizeListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;WalletReorganizeEventListener&gt;&gt;();
<span class="fc" id="L174">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;ScriptsChangeEventListener&gt;&gt; scriptChangeListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;ScriptsChangeEventListener&gt;&gt;();
<span class="fc" id="L176">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;TransactionConfidenceEventListener&gt;&gt; transactionConfidenceListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;TransactionConfidenceEventListener&gt;&gt;();

    // A listener that relays confidence changes from the transaction confidence object to the wallet event listener,
    // as a convenience to API users so they don't have to register on every transaction themselves.
    private TransactionConfidence.Listener txConfidenceListener;

    // If a TX hash appears in this set then notifyNewBestBlock will ignore it, as its confidence was already set up
    // in receive() via Transaction.setBlockAppearance(). As the BlockChain always calls notifyNewBestBlock even if
    // it sent transactions to the wallet, without this we'd double count.
    private HashSet&lt;Sha256Hash&gt; ignoreNextNewBlock;
    // Whether or not to ignore pending transactions that are considered risky by the configured risk analyzer.
    private boolean acceptRiskyTransactions;
    // Object that performs risk analysis of pending transactions. We might reject transactions that seem like
    // a high risk of being a double spending attack.
<span class="fc" id="L191">    private RiskAnalysis.Analyzer riskAnalyzer = DefaultRiskAnalysis.FACTORY;</span>

    // Stuff for notifying transaction objects that we changed their confidences. The purpose of this is to avoid
    // spuriously sending lots of repeated notifications to listeners that API users aren't really interested in as a
    // side effect of how the code is written (e.g. during re-orgs confidence data gets adjusted multiple times).
    private int onWalletChangedSuppressions;
    private boolean insideReorg;
    private Map&lt;Transaction, TransactionConfidence.Listener.ChangeReason&gt; confidenceChanged;
    protected volatile WalletFiles vFileManager;
    // Object that is used to send transactions asynchronously when the wallet requires it.
    protected volatile TransactionBroadcaster vTransactionBroadcaster;
    // UNIX time in seconds. Money controlled by keys created before this time will be automatically respent to a key
    // that was created after it. Useful when you believe some keys have been compromised.
    private volatile long vKeyRotationTimestamp;

<span class="fc" id="L206">    protected CoinSelector coinSelector = new DefaultCoinSelector();</span>


    // The wallet version. This is an int that can be used to track breaking changes in the wallet format.
    // You can also use it to detect wallets that come from the future (ie they contain features you
    // do not know how to deal with).
    private int version;
    // User-provided description that may help people keep track of what a wallet is for.
    private String description;
    // Stores objects that know how to serialize/unserialize themselves to byte streams and whether they're mandatory
    // or not. The string key comes from the extension itself.
    private final HashMap&lt;String, WalletExtension&gt; extensions;

    // Objects that perform transaction signing. Applied subsequently one after another
    @GuardedBy(&quot;lock&quot;) private List&lt;TransactionSigner&gt; signers;

    // If this is set then the wallet selects spendable candidate outputs from a UTXO provider.
    @Nullable private volatile UTXOProvider vUTXOProvider;

    /**
     * Creates a new, empty wallet with a randomly chosen seed and no transactions. Make sure to provide for sufficient
     * backup! Any keys will be derived from the seed. If you want to restore a wallet from disk instead, see
     * {@link #loadFromFile}.
     */
    public Wallet(NetworkParameters params) {
<span class="fc" id="L231">        this(Context.getOrCreate(params));</span>
<span class="fc" id="L232">    }</span>

    /**
     * Creates a new, empty wallet with a randomly chosen seed and no transactions. Make sure to provide for sufficient
     * backup! Any keys will be derived from the seed. If you want to restore a wallet from disk instead, see
     * {@link #loadFromFile}.
     */
    public Wallet(Context context) {
<span class="fc" id="L240">        this(context, new KeyChainGroup(context.getParams()));</span>
<span class="fc" id="L241">    }</span>

    public static Wallet fromSeed(NetworkParameters params, DeterministicSeed seed, DeterministicKeyChain.KeyChainType keyChainType) {
<span class="nc" id="L244">        return new Wallet(params, new KeyChainGroup(params, seed,keyChainType));</span>
    }

    public static Wallet fromSeed(NetworkParameters params, DeterministicSeed seed) {
<span class="nc" id="L248">        return new Wallet(params, new KeyChainGroup(params, seed));</span>
    }

    /**
     * Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key. A
     * watching key corresponds to account zero in the recommended BIP32 key hierarchy.
     */
    public static Wallet fromWatchingKey(NetworkParameters params, DeterministicKey watchKey) {
<span class="nc" id="L256">        return new Wallet(params, new KeyChainGroup(params, watchKey));</span>
    }

    public static Wallet fromWatchingKey(NetworkParameters params, DeterministicKey watchKey, DeterministicKeyChain.KeyChainType keyChainType) {
<span class="nc" id="L260">        return new Wallet(params, new KeyChainGroup(params, watchKey,keyChainType));</span>
    }

    /**
     * Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key. A
     * watching key corresponds to account zero in the recommended BIP32 key hierarchy. The key is specified in base58
     * notation and the creation time of the key. If you don't know the creation time, you can pass
     * {@link DeterministicHierarchy#BIP32_STANDARDISATION_TIME_SECS}.
     */
    public static Wallet fromWatchingKeyB58(NetworkParameters params, String watchKeyB58, long creationTimeSeconds) {
<span class="nc" id="L270">        final DeterministicKey watchKey = DeterministicKey.deserializeB58(null, watchKeyB58, params);</span>
<span class="nc" id="L271">        watchKey.setCreationTimeSeconds(creationTimeSeconds);</span>
<span class="nc" id="L272">        return fromWatchingKey(params, watchKey);</span>
    }

    public static Wallet fromWatchingKeyB58(NetworkParameters params, String watchKeyB58, long creationTimeSeconds, DeterministicKeyChain.KeyChainType keyChainType) {
<span class="nc" id="L276">        DeterministicKey parent = null;</span>
<span class="nc" id="L277">        final DeterministicKey watchKey = DeterministicKey.deserializeB58(parent, watchKeyB58, params,keyChainType);</span>
<span class="nc" id="L278">        watchKey.setCreationTimeSeconds(creationTimeSeconds);</span>
<span class="nc" id="L279">        return fromWatchingKey(params, watchKey,keyChainType);</span>
    }

    /**
     * Creates a wallet containing a given set of keys. All further keys will be derived from the oldest key.
     */
    public static Wallet fromKeys(NetworkParameters params, List&lt;ECKey&gt; keys) {
<span class="nc bnc" id="L286" title="All 2 branches missed.">        for (ECKey key : keys)</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">            checkArgument(!(key instanceof DeterministicKey));</span>

<span class="nc" id="L289">        KeyChainGroup group = new KeyChainGroup(params);</span>
<span class="nc" id="L290">        group.importKeys(keys);</span>
<span class="nc" id="L291">        return new Wallet(params, group);</span>
    }

    public Wallet(NetworkParameters params, KeyChainGroup keyChainGroup) {
<span class="fc" id="L295">        this(Context.getOrCreate(params), keyChainGroup);</span>
<span class="fc" id="L296">    }</span>

<span class="fc" id="L298">    private Wallet(Context context, KeyChainGroup keyChainGroup) {</span>
<span class="fc" id="L299">        this.context = context;</span>
<span class="fc" id="L300">        this.params = context.getParams();</span>
<span class="fc" id="L301">        this.keyChainGroup = checkNotNull(keyChainGroup);</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (params.getId().equals(NetworkParameters.ID_UNITTESTNET))</span>
<span class="fc" id="L303">            this.keyChainGroup.setLookaheadSize(5);  // Cut down excess computation for unit tests.</span>
        // If this keyChainGroup was created fresh just now (new wallet), make HD so a backup can be made immediately
        // without having to call current/freshReceiveKey. If there are already keys in the chain of any kind then
        // we're probably being deserialized so leave things alone: the API user can upgrade later.
<span class="fc bfc" id="L307" title="All 2 branches covered.">        if (this.keyChainGroup.numKeys() == 0)</span>
<span class="fc" id="L308">            this.keyChainGroup.createAndActivateNewHDChain();</span>
        // wallet version 1 if the key chain is a bip44
        //this.version = this.keyChainGroup.getActiveKeyChain().getKeyChainType() == DeterministicKeyChain.KeyChainType.BIP44_MTNS_ONLY? 1 : 0;
<span class="fc" id="L311">        watchedScripts = Sets.newHashSet();</span>
<span class="fc" id="L312">        unspent = new HashMap&lt;Sha256Hash, Transaction&gt;();</span>
<span class="fc" id="L313">        spent = new HashMap&lt;Sha256Hash, Transaction&gt;();</span>
<span class="fc" id="L314">        pending = new HashMap&lt;Sha256Hash, Transaction&gt;();</span>
<span class="fc" id="L315">        dead = new HashMap&lt;Sha256Hash, Transaction&gt;();</span>
<span class="fc" id="L316">        transactions = new HashMap&lt;Sha256Hash, Transaction&gt;();</span>
<span class="fc" id="L317">        extensions = new HashMap&lt;String, WalletExtension&gt;();</span>
        // Use a linked hash map to ensure ordering of event listeners is correct.
<span class="fc" id="L319">        confidenceChanged = new LinkedHashMap&lt;Transaction, TransactionConfidence.Listener.ChangeReason&gt;();</span>
<span class="fc" id="L320">        signers = new ArrayList&lt;TransactionSigner&gt;();</span>
<span class="fc" id="L321">        addTransactionSigner(new LocalTransactionSigner());</span>
<span class="fc" id="L322">        createTransientState();</span>
<span class="fc" id="L323">    }</span>

    private void createTransientState() {
<span class="fc" id="L326">        ignoreNextNewBlock = new HashSet&lt;Sha256Hash&gt;();</span>
<span class="fc" id="L327">        txConfidenceListener = new TransactionConfidence.Listener() {</span>
            @Override
            public void onConfidenceChanged(TransactionConfidence confidence, TransactionConfidence.Listener.ChangeReason reason) {
                // This will run on the user code thread so we shouldn't do anything too complicated here.
                // We only want to queue a wallet changed event and auto-save if the number of peers announcing
                // the transaction has changed, as that confidence change is made by the networking code which
                // doesn't necessarily know at that point which wallets contain which transactions, so it's up
                // to us to listen for that. Other types of confidence changes (type, etc) are triggered by us,
                // so we'll queue up a wallet change event in other parts of the code.
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">                if (reason == ChangeReason.SEEN_PEERS) {</span>
<span class="nc" id="L337">                    lock.lock();</span>
                    try {
<span class="nc" id="L339">                        checkBalanceFuturesLocked(null);</span>
<span class="nc" id="L340">                        Transaction tx = getTransaction(confidence.getTransactionHash());</span>
<span class="nc" id="L341">                        queueOnTransactionConfidenceChanged(tx);</span>
<span class="nc" id="L342">                        maybeQueueOnWalletChanged();</span>
                    } finally {
<span class="nc" id="L344">                        lock.unlock();</span>
<span class="nc" id="L345">                    }</span>
                }
<span class="fc" id="L347">            }</span>
        };
<span class="fc" id="L349">        acceptRiskyTransactions = false;</span>
<span class="fc" id="L350">    }</span>

    public NetworkParameters getNetworkParameters() {
<span class="fc" id="L353">        return params;</span>
    }

    /**
     * Gets the active keychain via {@link KeyChainGroup#getActiveKeyChain()}
     */
    public DeterministicKeyChain getActiveKeyChain() {
<span class="fc" id="L360">        return keyChainGroup.getActiveKeyChain();</span>
    }

    /**
     * &lt;p&gt;Adds given transaction signer to the list of signers. It will be added to the end of the signers list, so if
     * this wallet already has some signers added, given signer will be executed after all of them.&lt;/p&gt;
     * &lt;p&gt;Transaction signer should be fully initialized before adding to the wallet, otherwise {@link IllegalStateException}
     * will be thrown&lt;/p&gt;
     */
    public final void addTransactionSigner(TransactionSigner signer) {
<span class="fc" id="L370">        lock.lock();</span>
        try {
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">            if (signer.isReady())</span>
<span class="fc" id="L373">                signers.add(signer);</span>
            else
<span class="nc" id="L375">                throw new IllegalStateException(&quot;Signer instance is not ready to be added into Wallet: &quot; + signer.getClass());</span>
        } finally {
<span class="pc" id="L377">            lock.unlock();</span>
<span class="pc" id="L378">        }</span>
<span class="fc" id="L379">    }</span>

    public List&lt;TransactionSigner&gt; getTransactionSigners() {
<span class="fc" id="L382">        lock.lock();</span>
        try {
<span class="fc" id="L384">            return ImmutableList.copyOf(signers);</span>
        } finally {
<span class="pc" id="L386">            lock.unlock();</span>
<span class="nc" id="L387">        }</span>
    }

    /******************************************************************************************************************/

    //region Key Management

    /**
     * Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying in a wallet
     * user interface as &quot;a convenient key to receive funds on&quot; when the purpose parameter is
     * {@link site.mtnsj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS}. The returned key is stable until
     * it's actually seen in a pending or confirmed transaction, at which point this method will start returning
     * a different key (for each purpose independently).
     */
    public DeterministicKey currentKey(KeyChain.KeyPurpose purpose) {
<span class="fc" id="L402">        keyChainGroupLock.lock();</span>
        try {
<span class="fc" id="L404">            maybeUpgradeToHD();</span>
<span class="fc" id="L405">            return keyChainGroup.currentKey(purpose);</span>
        } finally {
<span class="pc" id="L407">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L408">        }</span>
    }

    /**
     * An alias for calling {@link #currentKey(site.mtnsj.wallet.KeyChain.KeyPurpose)} with
     * {@link site.mtnsj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     */
    public DeterministicKey currentReceiveKey() {
<span class="fc" id="L416">        return currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);</span>
    }

    /**
     * Returns address for a {@link #currentKey(site.mtnsj.wallet.KeyChain.KeyPurpose)}
     */
    public Address currentAddress(KeyChain.KeyPurpose purpose) {
<span class="fc" id="L423">        keyChainGroupLock.lock();</span>
        try {
<span class="fc" id="L425">            maybeUpgradeToHD();</span>
<span class="fc" id="L426">            return keyChainGroup.currentAddress(purpose);</span>
        } finally {
<span class="pc" id="L428">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L429">        }</span>
    }

    /**
     * An alias for calling {@link #currentAddress(site.mtnsj.wallet.KeyChain.KeyPurpose)} with
     * {@link site.mtnsj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     */
    public Address currentReceiveAddress() {
<span class="nc" id="L437">        return currentAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);</span>
    }

    /**
     * Returns a key that has not been returned by this method before (fresh). You can think of this as being
     * a newly created key, although the notion of &quot;create&quot; is not really valid for a
     * {@link site.mtnsj.wallet.DeterministicKeyChain}. When the parameter is
     * {@link site.mtnsj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for being put
     * into a receive coins wizard type UI. You should use this when the user is definitely going to hand this key out
     * to someone who wishes to send money.
     */
    public DeterministicKey freshKey(KeyChain.KeyPurpose purpose) {
<span class="fc" id="L449">        return freshKeys(purpose, 1).get(0);</span>
    }

    /**
     * Returns a key/s that has not been returned by this method before (fresh). You can think of this as being
     * a newly created key/s, although the notion of &quot;create&quot; is not really valid for a
     * {@link site.mtnsj.wallet.DeterministicKeyChain}. When the parameter is
     * {@link site.mtnsj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for being put
     * into a receive coins wizard type UI. You should use this when the user is definitely going to hand this key/s out
     * to someone who wishes to send money.
     */
    public List&lt;DeterministicKey&gt; freshKeys(KeyChain.KeyPurpose purpose, int numberOfKeys) {
        List&lt;DeterministicKey&gt; keys;
<span class="fc" id="L462">        keyChainGroupLock.lock();</span>
        try {
<span class="fc" id="L464">            maybeUpgradeToHD();</span>
<span class="fc" id="L465">            keys = keyChainGroup.freshKeys(purpose, numberOfKeys);</span>
        } finally {
<span class="pc" id="L467">            keyChainGroupLock.unlock();</span>
<span class="pc" id="L468">        }</span>
        // Do we really need an immediate hard save? Arguably all this is doing is saving the 'current' key
        // and that's not quite so important, so we could coalesce for more performance.
<span class="fc" id="L471">        saveNow();</span>
<span class="fc" id="L472">        return keys;</span>
    }

    /**
     * An alias for calling {@link #freshKey(site.mtnsj.wallet.KeyChain.KeyPurpose)} with
     * {@link site.mtnsj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     */
    public DeterministicKey freshReceiveKey() {
<span class="fc" id="L480">        return freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);</span>
    }

    /**
     * Returns address for a {@link #freshKey(site.mtnsj.wallet.KeyChain.KeyPurpose)}
     */
    public Address freshAddress(KeyChain.KeyPurpose purpose) {
        Address key;
<span class="nc" id="L488">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L490">            key = keyChainGroup.freshAddress(purpose);</span>
        } finally {
<span class="nc" id="L492">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L493">        }</span>
<span class="nc" id="L494">        saveNow();</span>
<span class="nc" id="L495">        return key;</span>
    }

    /**
     * An alias for calling {@link #freshAddress(site.mtnsj.wallet.KeyChain.KeyPurpose)} with
     * {@link site.mtnsj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     */
    public Address freshReceiveAddress() {
<span class="nc" id="L503">        return freshAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);</span>
    }

    /**
     * Returns only the keys that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     * {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     */
    public List&lt;ECKey&gt; getIssuedReceiveKeys() {
<span class="nc" id="L511">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L513">            return keyChainGroup.getActiveKeyChain().getIssuedReceiveKeys();</span>
        } finally {
<span class="nc" id="L515">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L516">        }</span>
    }

    /**
     * Returns only the addresses that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     * {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     */
    public List&lt;Address&gt; getIssuedReceiveAddresses() {
<span class="nc" id="L524">        final List&lt;ECKey&gt; keys = getIssuedReceiveKeys();</span>
<span class="nc" id="L525">        List&lt;Address&gt; addresses = new ArrayList&lt;Address&gt;(keys.size());</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">        for (ECKey key : keys)</span>
<span class="nc" id="L527">            addresses.add(key.toAddress(getParams()));</span>
<span class="nc" id="L528">        return addresses;</span>
    }

    /**
     * Upgrades the wallet to be deterministic (BIP32). You should call this, possibly providing the users encryption
     * key, after loading a wallet produced by previous versions of mtnsj. If the wallet is encrypted the key
     * &lt;b&gt;must&lt;/b&gt; be provided, due to the way the seed is derived deterministically from private key bytes: failing
     * to do this will result in an exception being thrown. For non-encrypted wallets, the upgrade will be done for
     * you automatically the first time a new key is requested (this happens when spending due to the change address).
     */
    public void upgradeToDeterministic(@Nullable KeyParameter aesKey) throws DeterministicUpgradeRequiresPassword {
<span class="nc" id="L539">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L541">            keyChainGroup.upgradeToDeterministic(vKeyRotationTimestamp, aesKey);</span>
        } finally {
<span class="nc" id="L543">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L544">        }</span>
<span class="nc" id="L545">    }</span>

    /**
     * Returns true if the wallet contains random keys and no HD chains, in which case you should call
     * {@link #upgradeToDeterministic(org.spongycastle.crypto.params.KeyParameter)} before attempting to do anything
     * that would require a new address or key.
     */
    public boolean isDeterministicUpgradeRequired() {
<span class="nc" id="L553">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L555">            return keyChainGroup.isDeterministicUpgradeRequired();</span>
        } finally {
<span class="nc" id="L557">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L558">        }</span>
    }

    private void maybeUpgradeToHD() throws DeterministicUpgradeRequiresPassword {
<span class="fc" id="L562">        maybeUpgradeToHD(null);</span>
<span class="fc" id="L563">    }</span>

    @GuardedBy(&quot;keyChainGroupLock&quot;)
    private void maybeUpgradeToHD(@Nullable KeyParameter aesKey) throws DeterministicUpgradeRequiresPassword {
<span class="fc" id="L567">        checkState(keyChainGroupLock.isHeldByCurrentThread());</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">        if (keyChainGroup.isDeterministicUpgradeRequired()) {</span>
<span class="nc" id="L569">            log.info(&quot;Upgrade to HD wallets is required, attempting to do so.&quot;);</span>
            try {
<span class="nc" id="L571">                upgradeToDeterministic(aesKey);</span>
<span class="nc" id="L572">            } catch (DeterministicUpgradeRequiresPassword e) {</span>
<span class="nc" id="L573">                log.error(&quot;Failed to auto upgrade due to encryption. You should call wallet.upgradeToDeterministic &quot; +</span>
                        &quot;with the users AES key to avoid this error.&quot;);
<span class="nc" id="L575">                throw e;</span>
<span class="nc" id="L576">            }</span>
        }
<span class="fc" id="L578">    }</span>

    /**
     * Returns a snapshot of the watched scripts. This view is not live.
     */
    public List&lt;Script&gt; getWatchedScripts() {
<span class="fc" id="L584">        keyChainGroupLock.lock();</span>
        try {
<span class="fc" id="L586">            return new ArrayList&lt;Script&gt;(watchedScripts);</span>
        } finally {
<span class="pc" id="L588">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L589">        }</span>
    }

    /**
     * Removes the given key from the basicKeyChain. Be very careful with this - losing a private key &lt;b&gt;destroys the
     * money associated with it&lt;/b&gt;.
     * @return Whether the key was removed or not.
     */
    public boolean removeKey(ECKey key) {
<span class="nc" id="L598">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L600">            return keyChainGroup.removeImportedKey(key);</span>
        } finally {
<span class="nc" id="L602">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L603">        }</span>
    }

    /**
     * Returns the number of keys in the key chain group, including lookahead keys.
     */
    public int getKeyChainGroupSize() {
<span class="nc" id="L610">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L612">            return keyChainGroup.numKeys();</span>
        } finally {
<span class="nc" id="L614">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L615">        }</span>
    }

    @VisibleForTesting
    public int getKeyChainGroupCombinedKeyLookaheadEpochs() {
<span class="nc" id="L620">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L622">            return keyChainGroup.getCombinedKeyLookaheadEpochs();</span>
        } finally {
<span class="nc" id="L624">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L625">        }</span>
    }

    /**
     * Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
     */
    public List&lt;ECKey&gt; getImportedKeys() {
<span class="fc" id="L632">        keyChainGroupLock.lock();</span>
        try {
<span class="fc" id="L634">            return keyChainGroup.getImportedKeys();</span>
        } finally {
<span class="pc" id="L636">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L637">        }</span>
    }

    /** Returns the address used for change outputs. Note: this will probably go away in future. */
    public Address currentChangeAddress() {
<span class="fc" id="L642">        return currentAddress(KeyChain.KeyPurpose.CHANGE);</span>
    }
    /**
     * @deprecated use {@link #currentChangeAddress()} instead.
     */
    public Address getChangeAddress() {
<span class="nc" id="L648">        return currentChangeAddress();</span>
    }

    /**
     * &lt;p&gt;Deprecated alias for {@link #importKey(ECKey)}.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;b&gt;Replace with either {@link #freshReceiveKey()} if your call is addKey(new ECKey()), or with {@link #importKey(ECKey)}
     * which does the same thing this method used to, but with a better name.&lt;/b&gt;&lt;/p&gt;
     */
    @Deprecated
    public boolean addKey(ECKey key) {
<span class="nc" id="L659">        return importKey(key);</span>
    }

    /**
     * &lt;p&gt;Imports the given ECKey to the wallet.&lt;/p&gt;
     *
     * &lt;p&gt;If the wallet is configured to auto save to a file, triggers a save immediately. Runs the onKeysAdded event
     * handler. If the key already exists in the wallet, does nothing and returns false.&lt;/p&gt;
     */
    public boolean importKey(ECKey key) {
<span class="nc bnc" id="L669" title="All 2 branches missed.">        return importKeys(Lists.newArrayList(key)) == 1;</span>
    }

    /** Replace with {@link #importKeys(java.util.List)}, which does the same thing but with a better name. */
    @Deprecated
    public int addKeys(List&lt;ECKey&gt; keys) {
<span class="nc" id="L675">        return importKeys(keys);</span>
    }

    /**
     * Imports the given keys to the wallet.
     * If {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, site.mtnsj.wallet.WalletFiles.Listener)}
     * has been called, triggers an auto save bypassing the normal coalescing delay and event handlers.
     * Returns the number of keys added, after duplicates are ignored. The onKeyAdded event will be called for each key
     * in the list that was not already present.
     */
    public int importKeys(final List&lt;ECKey&gt; keys) {
        // API usage check.
<span class="nc" id="L687">        checkNoDeterministicKeys(keys);</span>
        int result;
<span class="nc" id="L689">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L691">            result = keyChainGroup.importKeys(keys);</span>
        } finally {
<span class="nc" id="L693">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L694">        }</span>
<span class="nc" id="L695">        saveNow();</span>
<span class="nc" id="L696">        return result;</span>
    }

    private void checkNoDeterministicKeys(List&lt;ECKey&gt; keys) {
        // Watch out for someone doing wallet.importKey(wallet.freshReceiveKey()); or equivalent: we never tested this.
<span class="nc bnc" id="L701" title="All 2 branches missed.">        for (ECKey key : keys)</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">            if (key instanceof DeterministicKey)</span>
<span class="nc" id="L703">                throw new IllegalArgumentException(&quot;Cannot import HD keys back into the wallet&quot;);</span>
<span class="nc" id="L704">    }</span>

    /** Takes a list of keys and a password, then encrypts and imports them in one step using the current keycrypter. */
    public int importKeysAndEncrypt(final List&lt;ECKey&gt; keys, CharSequence password) {
<span class="nc" id="L708">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L710">            checkNotNull(getKeyCrypter(), &quot;Wallet is not encrypted&quot;);</span>
<span class="nc" id="L711">            return importKeysAndEncrypt(keys, getKeyCrypter().deriveKey(password));</span>
        } finally {
<span class="nc" id="L713">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L714">        }</span>
    }

    /** Takes a list of keys and an AES key, then encrypts and imports them in one step using the current keycrypter. */
    public int importKeysAndEncrypt(final List&lt;ECKey&gt; keys, KeyParameter aesKey) {
<span class="nc" id="L719">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L721">            checkNoDeterministicKeys(keys);</span>
<span class="nc" id="L722">            return keyChainGroup.importKeysAndEncrypt(keys, aesKey);</span>
        } finally {
<span class="nc" id="L724">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L725">        }</span>
    }

    /**
     * Add a pre-configured keychain to the wallet.  Useful for setting up a complex keychain,
     * such as for a married wallet.  For example:
     * &lt;pre&gt;
     * MarriedKeyChain chain = MarriedKeyChain.builder()
     *     .random(new SecureRandom())
     *     .followingKeys(followingKeys)
     *     .threshold(2).build();
     * wallet.addAndActivateHDChain(chain);
     * &lt;/p&gt;
     */

    public void addAndActivateHDChain(DeterministicKeyChain chain) {
<span class="nc" id="L741">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L743">            keyChainGroup.addAndActivateHDChain(chain);</span>
        } finally {
<span class="nc" id="L745">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L746">        }</span>
<span class="nc" id="L747">    }</span>

    /** See {@link site.mtnsj.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. */
    public void setKeyChainGroupLookaheadSize(int lookaheadSize) {
<span class="nc" id="L751">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L753">            keyChainGroup.setLookaheadSize(lookaheadSize);</span>
        } finally {
<span class="nc" id="L755">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L756">        }</span>
<span class="nc" id="L757">    }</span>

    /** See {@link site.mtnsj.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. */
    public int getKeyChainGroupLookaheadSize() {
<span class="nc" id="L761">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L763">            return keyChainGroup.getLookaheadSize();</span>
        } finally {
<span class="nc" id="L765">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L766">        }</span>
    }

    /** See {@link site.mtnsj.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. */
    public void setKeyChainGroupLookaheadThreshold(int num) {
<span class="nc" id="L771">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L773">            maybeUpgradeToHD();</span>
<span class="nc" id="L774">            keyChainGroup.setLookaheadThreshold(num);</span>
        } finally {
<span class="nc" id="L776">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L777">        }</span>
<span class="nc" id="L778">    }</span>

    /** See {@link site.mtnsj.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. */
    public int getKeyChainGroupLookaheadThreshold() {
<span class="nc" id="L782">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L784">            maybeUpgradeToHD();</span>
<span class="nc" id="L785">            return keyChainGroup.getLookaheadThreshold();</span>
        } finally {
<span class="nc" id="L787">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L788">        }</span>
    }

    /**
     * Returns a public-only DeterministicKey that can be used to set up a watching wallet: that is, a wallet that
     * can import transactions from the block chain just as the normal wallet can, but which cannot spend. Watching
     * wallets are very useful for things like web servers that accept payments. This key corresponds to the account
     * zero key in the recommended BIP32 hierarchy.
     */
    public DeterministicKey getWatchingKey() {
<span class="nc" id="L798">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L800">            maybeUpgradeToHD();</span>
<span class="nc" id="L801">            return keyChainGroup.getActiveKeyChain().getWatchingKey();</span>
        } finally {
<span class="nc" id="L803">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L804">        }</span>
    }

    /**
     * Returns whether this wallet consists entirely of watching keys (unencrypted keys with no private part). Mixed
     * wallets are forbidden.
     * 
     * @throws IllegalStateException
     *             if there are no keys, or if there is a mix between watching and non-watching keys.
     */
    public boolean isWatching() {
<span class="nc" id="L815">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L817">            maybeUpgradeToHD();</span>
<span class="nc" id="L818">            return keyChainGroup.isWatching();</span>
        } finally {
<span class="nc" id="L820">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L821">        }</span>
    }

    /**
     * Return true if we are watching this address.
     */
    public boolean isAddressWatched(Address address) {
<span class="nc" id="L828">        Script script = ScriptBuilder.createOutputScript(address);</span>
<span class="nc" id="L829">        return isWatchedScript(script);</span>
    }

    /**
     * Same as {@link #addWatchedAddress(Address, long)} with the current time as the creation time.
     */
    public boolean addWatchedAddress(final Address address) {
<span class="nc" id="L836">        long now = Utils.currentTimeMillis() / 1000;</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">        return addWatchedAddresses(Lists.newArrayList(address), now) == 1;</span>
    }


    /**
     * Adds the given address to the wallet to be watched. Outputs can be retrieved by {@link #getWatchedOutputs(boolean)}.
     *
     * @param creationTime creation time in seconds since the epoch, for scanning the blockchain
     * @return whether the address was added successfully (not already present)
     */
    public boolean addWatchedAddress(final Address address, long creationTime) {
<span class="nc bnc" id="L848" title="All 2 branches missed.">        return addWatchedAddresses(Lists.newArrayList(address), creationTime) == 1;</span>
    }

    /**
     * Adds the given address to the wallet to be watched. Outputs can be retrieved
     * by {@link #getWatchedOutputs(boolean)}.
     *
     * @return how many addresses were added successfully
     */
    public int addWatchedAddresses(final List&lt;Address&gt; addresses, long creationTime) {
<span class="nc" id="L858">        List&lt;Script&gt; scripts = Lists.newArrayList();</span>

<span class="nc bnc" id="L860" title="All 2 branches missed.">        for (Address address : addresses) {</span>
<span class="nc" id="L861">            Script script = ScriptBuilder.createOutputScript(address);</span>
<span class="nc" id="L862">            script.setCreationTimeSeconds(creationTime);</span>
<span class="nc" id="L863">            scripts.add(script);</span>
<span class="nc" id="L864">        }</span>

<span class="nc" id="L866">        return addWatchedScripts(scripts);</span>
    }

    /**
     * Adds the given output scripts to the wallet to be watched. Outputs can be retrieved by {@link #getWatchedOutputs(boolean)}.
     * If a script is already being watched, the object is replaced with the one in the given list. As {@link Script}
     * equality is defined in terms of program bytes only this lets you update metadata such as creation time. Note that
     * you should be careful not to add scripts with a creation time of zero (the default!) because otherwise it will
     * disable the important wallet checkpointing optimisation.
     *
     * @return how many scripts were added successfully
     */
    public int addWatchedScripts(final List&lt;Script&gt; scripts) {
<span class="fc" id="L879">        int added = 0;</span>
<span class="fc" id="L880">        keyChainGroupLock.lock();</span>
        try {
<span class="pc bpc" id="L882" title="1 of 2 branches missed.">            for (final Script script : scripts) {</span>
                // Script.equals/hashCode() only takes into account the program bytes, so this step lets the user replace
                // a script in the wallet with an incorrect creation time.
<span class="nc bnc" id="L885" title="All 2 branches missed.">                if (watchedScripts.contains(script))</span>
<span class="nc" id="L886">                    watchedScripts.remove(script);</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">                if (script.getCreationTimeSeconds() == 0)</span>
<span class="nc" id="L888">                    log.warn(&quot;Adding a script to the wallet with a creation time of zero, this will disable the checkpointing optimization!    {}&quot;, script);</span>
<span class="nc" id="L889">                watchedScripts.add(script);</span>
<span class="nc" id="L890">                added++;</span>
<span class="nc" id="L891">            }</span>
        } finally {
<span class="pc" id="L893">            keyChainGroupLock.unlock();</span>
<span class="pc" id="L894">        }</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">        if (added &gt; 0) {</span>
<span class="nc" id="L896">            queueOnScriptsChanged(scripts, true);</span>
<span class="nc" id="L897">            saveNow();</span>
        }
<span class="fc" id="L899">        return added;</span>
    }

    /**
     * Removes the given output scripts from the wallet that were being watched.
     *
     * @return true if successful
     */
    public boolean removeWatchedAddress(final Address address) {
<span class="nc" id="L908">        return removeWatchedAddresses(ImmutableList.of(address));</span>
    }

    /**
     * Removes the given output scripts from the wallet that were being watched.
     *
     * @return true if successful
     */
    public boolean removeWatchedAddresses(final List&lt;Address&gt; addresses) {
<span class="nc" id="L917">        List&lt;Script&gt; scripts = Lists.newArrayList();</span>

<span class="nc bnc" id="L919" title="All 2 branches missed.">        for (Address address : addresses) {</span>
<span class="nc" id="L920">            Script script = ScriptBuilder.createOutputScript(address);</span>
<span class="nc" id="L921">            scripts.add(script);</span>
<span class="nc" id="L922">        }</span>

<span class="nc" id="L924">        return removeWatchedScripts(scripts);</span>
    }

    /**
     * Removes the given output scripts from the wallet that were being watched.
     *
     * @return true if successful
     */
    public boolean removeWatchedScripts(final List&lt;Script&gt; scripts) {
<span class="nc" id="L933">        lock.lock();</span>
        try {
<span class="nc bnc" id="L935" title="All 2 branches missed.">            for (final Script script : scripts) {</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">                if (!watchedScripts.contains(script))</span>
<span class="nc" id="L937">                    continue;</span>

<span class="nc" id="L939">                watchedScripts.remove(script);</span>
<span class="nc" id="L940">            }</span>

<span class="nc" id="L942">            queueOnScriptsChanged(scripts, false);</span>
<span class="nc" id="L943">            saveNow();</span>
<span class="nc" id="L944">            return true;</span>
        } finally {
<span class="nc" id="L946">            lock.unlock();</span>
<span class="nc" id="L947">        }</span>
    }

    /**
     * Returns all addresses watched by this wallet.
     */
    public List&lt;Address&gt; getWatchedAddresses() {
<span class="nc" id="L954">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L956">            List&lt;Address&gt; addresses = new LinkedList&lt;Address&gt;();</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">            for (Script script : watchedScripts)</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">                if (script.isSentToAddress())</span>
<span class="nc" id="L959">                    addresses.add(script.getToAddress(params));</span>
<span class="nc" id="L960">            return addresses;</span>
        } finally {
<span class="nc" id="L962">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L963">        }</span>
    }

    /**
     * Locates a keypair from the basicKeyChain given the hash of the public key. This is needed when finding out which
     * key we need to use to redeem a transaction output.
     *
     * @return ECKey object or null if no such key was found.
     */
    @Override
    @Nullable
    public ECKey findKeyFromPubHash(byte[] pubkeyHash) {
<span class="fc" id="L975">        keyChainGroupLock.lock();</span>
        try {
<span class="fc" id="L977">            return keyChainGroup.findKeyFromPubHash(pubkeyHash);</span>
        } finally {
<span class="pc" id="L979">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L980">        }</span>
    }

    /** Returns true if the given key is in the wallet, false otherwise. Currently an O(N) operation. */
    public boolean hasKey(ECKey key) {
<span class="nc" id="L985">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L987">            return keyChainGroup.hasKey(key);</span>
        } finally {
<span class="nc" id="L989">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L990">        }</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean isPubKeyHashMine(byte[] pubkeyHash) {
<span class="fc bfc" id="L996" title="All 2 branches covered.">        return findKeyFromPubHash(pubkeyHash) != null;</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean isWatchedScript(Script script) {
<span class="fc" id="L1002">        keyChainGroupLock.lock();</span>
        try {
<span class="fc" id="L1004">            return watchedScripts.contains(script);</span>
        } finally {
<span class="pc" id="L1006">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1007">        }</span>
    }

    /**
     * Locates a keypair from the basicKeyChain given the raw public key bytes.
     * @return ECKey or null if no such key was found.
     */
    @Override
    @Nullable
    public ECKey findKeyFromPubKey(byte[] pubkey) {
<span class="fc" id="L1017">        keyChainGroupLock.lock();</span>
        try {
<span class="fc" id="L1019">            return keyChainGroup.findKeyFromPubKey(pubkey);</span>
        } finally {
<span class="pc" id="L1021">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1022">        }</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean isPubKeyMine(byte[] pubkey) {
<span class="fc bfc" id="L1028" title="All 2 branches covered.">        return findKeyFromPubKey(pubkey) != null;</span>
    }

    /**
     * Locates a redeem data (redeem script and keys) from the keyChainGroup given the hash of the script.
     * Returns RedeemData object or null if no such data was found.
     */
    @Nullable
    @Override
    public RedeemData findRedeemDataFromScriptHash(byte[] payToScriptHash) {
<span class="nc" id="L1038">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L1040">            return keyChainGroup.findRedeemDataFromScriptHash(payToScriptHash);</span>
        } finally {
<span class="nc" id="L1042">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1043">        }</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean isPayToScriptHashMine(byte[] payToScriptHash) {
<span class="nc bnc" id="L1049" title="All 2 branches missed.">        return findRedeemDataFromScriptHash(payToScriptHash) != null;</span>
    }

    /**
     * Marks all keys used in the transaction output as used in the wallet.
     * See {@link site.mtnsj.wallet.DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     */
    private void markKeysAsUsed(Transaction tx) {
<span class="fc" id="L1057">        keyChainGroupLock.lock();</span>
        try {
<span class="fc bfc" id="L1059" title="All 2 branches covered.">            for (TransactionOutput o : tx.getOutputs()) {</span>
                try {
<span class="fc" id="L1061">                    Script script = o.getScriptPubKey();</span>
<span class="fc bfc" id="L1062" title="All 2 branches covered.">                    if (script.isSentToRawPubKey()) {</span>
<span class="fc" id="L1063">                        byte[] pubkey = script.getPubKey();</span>
<span class="fc" id="L1064">                        keyChainGroup.markPubKeyAsUsed(pubkey);</span>
<span class="pc bpc" id="L1065" title="1 of 2 branches missed.">                    } else if (script.isSentToAddress()) {</span>
<span class="fc" id="L1066">                        byte[] pubkeyHash = script.getPubKeyHash();</span>
<span class="fc" id="L1067">                        keyChainGroup.markPubKeyHashAsUsed(pubkeyHash);</span>
<span class="pc bnc" id="L1068" title="All 2 branches missed.">                    } else if (script.isPayToScriptHash()) {</span>
<span class="nc" id="L1069">                        Address a = Address.fromP2SHScript(tx.getParams(), script);</span>
<span class="nc" id="L1070">                        keyChainGroup.markP2SHAddressAsUsed(a);</span>
                    }
<span class="nc" id="L1072">                } catch (ScriptException e) {</span>
                    // Just means we didn't understand the output of this transaction: ignore it.
<span class="nc" id="L1074">                    log.warn(&quot;Could not parse tx output script: {}&quot;, e.toString());</span>
<span class="fc" id="L1075">                }</span>
<span class="fc" id="L1076">            }</span>
        } finally {
<span class="pc" id="L1078">            keyChainGroupLock.unlock();</span>
<span class="pc" id="L1079">        }</span>
<span class="fc" id="L1080">    }</span>

    /**
     * Returns the immutable seed for the current active HD chain.
     * @throws site.mtnsj.core.ECKey.MissingPrivateKeyException if the seed is unavailable (watching wallet)
     */
    public DeterministicSeed getKeyChainSeed() {
<span class="nc" id="L1087">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L1089">            DeterministicSeed seed = keyChainGroup.getActiveKeyChain().getSeed();</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">            if (seed == null)</span>
<span class="nc" id="L1091">                throw new ECKey.MissingPrivateKeyException();</span>
<span class="nc" id="L1092">            return seed;</span>
        } finally {
<span class="nc" id="L1094">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1095">        }</span>
    }

    /**
     * Returns a key for the given HD path, assuming it's already been derived. You normally shouldn't use this:
     * use currentReceiveKey/freshReceiveKey instead.
     */
    public DeterministicKey getKeyByPath(List&lt;ChildNumber&gt; path) {
<span class="nc" id="L1103">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L1105">            maybeUpgradeToHD();</span>
<span class="nc" id="L1106">            return keyChainGroup.getActiveKeyChain().getKeyByPath(path, false);</span>
        } finally {
<span class="nc" id="L1108">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1109">        }</span>
    }

    /**
     * Convenience wrapper around {@link Wallet#encrypt(site.mtnsj.crypto.KeyCrypter,
     * org.spongycastle.crypto.params.KeyParameter)} which uses the default Scrypt key derivation algorithm and
     * parameters to derive a key from the given password.
     */
    public void encrypt(CharSequence password) {
<span class="nc" id="L1118">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L1120">            final KeyCrypterScrypt scrypt = new KeyCrypterScrypt();</span>
<span class="nc" id="L1121">            keyChainGroup.encrypt(scrypt, scrypt.deriveKey(password));</span>
        } finally {
<span class="nc" id="L1123">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1124">        }</span>
<span class="nc" id="L1125">        saveNow();</span>
<span class="nc" id="L1126">    }</span>

    /**
     * Encrypt the wallet using the KeyCrypter and the AES key. A good default KeyCrypter to use is
     * {@link site.mtnsj.crypto.KeyCrypterScrypt}.
     *
     * @param keyCrypter The KeyCrypter that specifies how to encrypt/ decrypt a key
     * @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password)
     * @throws KeyCrypterException Thrown if the wallet encryption fails. If so, the wallet state is unchanged.
     */
    public void encrypt(KeyCrypter keyCrypter, KeyParameter aesKey) {
<span class="nc" id="L1137">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L1139">            keyChainGroup.encrypt(keyCrypter, aesKey);</span>
        } finally {
<span class="nc" id="L1141">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1142">        }</span>
<span class="nc" id="L1143">        saveNow();</span>
<span class="nc" id="L1144">    }</span>

    /**
     * Decrypt the wallet with the wallets keyCrypter and password.
     * @throws KeyCrypterException Thrown if the wallet decryption fails. If so, the wallet state is unchanged.
     */
    public void decrypt(CharSequence password) {
<span class="nc" id="L1151">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L1153">            final KeyCrypter crypter = keyChainGroup.getKeyCrypter();</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">            checkState(crypter != null, &quot;Not encrypted&quot;);</span>
<span class="nc" id="L1155">            keyChainGroup.decrypt(crypter.deriveKey(password));</span>
        } finally {
<span class="nc" id="L1157">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1158">        }</span>
<span class="nc" id="L1159">        saveNow();</span>
<span class="nc" id="L1160">    }</span>

    /**
     * Decrypt the wallet with the wallets keyCrypter and AES key.
     *
     * @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password)
     * @throws KeyCrypterException Thrown if the wallet decryption fails. If so, the wallet state is unchanged.
     */
    public void decrypt(KeyParameter aesKey) {
<span class="nc" id="L1169">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L1171">            keyChainGroup.decrypt(aesKey);</span>
        } finally {
<span class="nc" id="L1173">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1174">        }</span>
<span class="nc" id="L1175">        saveNow();</span>
<span class="nc" id="L1176">    }</span>

    /**
     *  Check whether the password can decrypt the first key in the wallet.
     *  This can be used to check the validity of an entered password.
     *
     *  @return boolean true if password supplied can decrypt the first private key in the wallet, false otherwise.
     *  @throws IllegalStateException if the wallet is not encrypted.
     */
    public boolean checkPassword(CharSequence password) {
<span class="nc" id="L1186">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L1188">            return keyChainGroup.checkPassword(password);</span>
        } finally {
<span class="nc" id="L1190">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1191">        }</span>
    }

    /**
     *  Check whether the AES key can decrypt the first encrypted key in the wallet.
     *
     *  @return boolean true if AES key supplied can decrypt the first encrypted private key in the wallet, false otherwise.
     */
    public boolean checkAESKey(KeyParameter aesKey) {
<span class="nc" id="L1200">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L1202">            return keyChainGroup.checkAESKey(aesKey);</span>
        } finally {
<span class="nc" id="L1204">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1205">        }</span>
    }

    /**
     * Get the wallet's KeyCrypter, or null if the wallet is not encrypted.
     * (Used in encrypting/ decrypting an ECKey).
     */
    @Nullable
    public KeyCrypter getKeyCrypter() {
<span class="fc" id="L1214">        keyChainGroupLock.lock();</span>
        try {
<span class="fc" id="L1216">            return keyChainGroup.getKeyCrypter();</span>
        } finally {
<span class="pc" id="L1218">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1219">        }</span>
    }

    /**
     * Get the type of encryption used for this wallet.
     *
     * (This is a convenience method - the encryption type is actually stored in the keyCrypter).
     */
    public EncryptionType getEncryptionType() {
<span class="nc" id="L1228">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L1230">            KeyCrypter crypter = keyChainGroup.getKeyCrypter();</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">            if (crypter != null)</span>
<span class="nc" id="L1232">                return crypter.getUnderstoodEncryptionType();</span>
            else
<span class="nc" id="L1234">                return EncryptionType.UNENCRYPTED;</span>
        } finally {
<span class="nc" id="L1236">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1237">        }</span>
    }

    /** Returns true if the wallet is encrypted using any scheme, false if not. */
    public boolean isEncrypted() {
<span class="nc bnc" id="L1242" title="All 2 branches missed.">        return getEncryptionType() != EncryptionType.UNENCRYPTED;</span>
    }

    /** Changes wallet encryption password, this is atomic operation. */
    public void changeEncryptionPassword(CharSequence currentPassword, CharSequence newPassword){
<span class="nc" id="L1247">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L1249">            decrypt(currentPassword);</span>
<span class="nc" id="L1250">            encrypt(newPassword);</span>
        } finally {
<span class="nc" id="L1252">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1253">        }</span>
<span class="nc" id="L1254">    }</span>

    /** Changes wallet AES encryption key, this is atomic operation. */
    public void changeEncryptionKey(KeyCrypter keyCrypter, KeyParameter currentAesKey, KeyParameter newAesKey){
<span class="nc" id="L1258">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L1260">            decrypt(currentAesKey);</span>
<span class="nc" id="L1261">            encrypt(keyCrypter, newAesKey);</span>
        } finally {
<span class="nc" id="L1263">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1264">        }</span>
<span class="nc" id="L1265">    }</span>

    //endregion

    /******************************************************************************************************************/

    //region Serialization support

    // TODO: Make this package private once the classes finish moving around.
    /** Internal use only. */
    public List&lt;Protos.Key&gt; serializeKeyChainGroupToProtobuf() {
<span class="fc" id="L1276">        keyChainGroupLock.lock();</span>
        try {
<span class="fc" id="L1278">            return keyChainGroup.serializeToProtobuf();</span>
        } finally {
<span class="pc" id="L1280">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L1281">        }</span>
    }

    /** Saves the wallet first to the given temp file, then renames to the dest file. */
    public void saveToFile(File temp, File destFile) throws IOException {
<span class="nc" id="L1286">        FileOutputStream stream = null;</span>
<span class="nc" id="L1287">        lock.lock();</span>
        try {
<span class="nc" id="L1289">            stream = new FileOutputStream(temp);</span>
<span class="nc" id="L1290">            saveToFileStream(stream);</span>
            // Attempt to force the bits to hit the disk. In reality the OS or hard disk itself may still decide
            // to not write through to physical media for at least a few seconds, but this is the best we can do.
<span class="nc" id="L1293">            stream.flush();</span>
<span class="nc" id="L1294">            stream.getFD().sync();</span>
<span class="nc" id="L1295">            stream.close();</span>
<span class="nc" id="L1296">            stream = null;</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">            if (Utils.isWindows()) {</span>
                // Work around an issue on Windows whereby you can't rename over existing files.
<span class="nc" id="L1299">                File canonical = destFile.getCanonicalFile();</span>
<span class="nc bnc" id="L1300" title="All 4 branches missed.">                if (canonical.exists() &amp;&amp; !canonical.delete())</span>
<span class="nc" id="L1301">                    throw new IOException(&quot;Failed to delete canonical wallet file for replacement with autosave&quot;);</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">                if (temp.renameTo(canonical))</span>
<span class="nc" id="L1303">                    return;  // else fall through.</span>
<span class="nc" id="L1304">                throw new IOException(&quot;Failed to rename &quot; + temp + &quot; to &quot; + canonical);</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">            } else if (!temp.renameTo(destFile)) {</span>
<span class="nc" id="L1306">                throw new IOException(&quot;Failed to rename &quot; + temp + &quot; to &quot; + destFile);</span>
            }
<span class="nc" id="L1308">        } catch (RuntimeException e) {</span>
<span class="nc" id="L1309">            log.error(&quot;Failed whilst saving wallet&quot;, e);</span>
<span class="nc" id="L1310">            throw e;</span>
        } finally {
<span class="nc" id="L1312">            lock.unlock();</span>
<span class="nc bnc" id="L1313" title="All 6 branches missed.">            if (stream != null) {</span>
<span class="nc" id="L1314">                stream.close();</span>
            }
<span class="nc bnc" id="L1316" title="All 6 branches missed.">            if (temp.exists()) {</span>
<span class="nc" id="L1317">                log.warn(&quot;Temp file still exists after failed save.&quot;);</span>
            }
<span class="nc" id="L1319">        }</span>
<span class="nc" id="L1320">    }</span>

    /**
     * Uses protobuf serialization to save the wallet to the given file. To learn more about this file format, see
     * {@link WalletProtobufSerializer}. Writes out first to a temporary file in the same directory and then renames
     * once written.
     */
    public void saveToFile(File f) throws IOException {
<span class="nc" id="L1328">        File directory = f.getAbsoluteFile().getParentFile();</span>
<span class="nc" id="L1329">        File temp = File.createTempFile(&quot;wallet&quot;, null, directory);</span>
<span class="nc" id="L1330">        saveToFile(temp, f);</span>
<span class="nc" id="L1331">    }</span>

    /**
     * &lt;p&gt;Whether or not the wallet will ignore pending transactions that fail the selected
     * {@link RiskAnalysis}. By default, if a transaction is considered risky then it won't enter the wallet
     * and won't trigger any event listeners. If you set this property to true, then all transactions will
     * be allowed in regardless of risk. For example, the {@link DefaultRiskAnalysis} checks for non-finality of
     * transactions.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this property is not serialized. You have to set it each time a Wallet object is constructed,
     * even if it's loaded from a protocol buffer.&lt;/p&gt;
     */
    public void setAcceptRiskyTransactions(boolean acceptRiskyTransactions) {
<span class="nc" id="L1344">        lock.lock();</span>
        try {
<span class="nc" id="L1346">            this.acceptRiskyTransactions = acceptRiskyTransactions;</span>
        } finally {
<span class="nc" id="L1348">            lock.unlock();</span>
<span class="nc" id="L1349">        }</span>
<span class="nc" id="L1350">    }</span>

    /**
     * See {@link Wallet#setAcceptRiskyTransactions(boolean)} for an explanation of this property.
     */
    public boolean isAcceptRiskyTransactions() {
<span class="nc" id="L1356">        lock.lock();</span>
        try {
<span class="nc" id="L1358">            return acceptRiskyTransactions;</span>
        } finally {
<span class="nc" id="L1360">            lock.unlock();</span>
<span class="nc" id="L1361">        }</span>
    }

    /**
     * Sets the {@link RiskAnalysis} implementation to use for deciding whether received pending transactions are risky
     * or not. If the analyzer says a transaction is risky, by default it will be dropped. You can customize this
     * behaviour with {@link #setAcceptRiskyTransactions(boolean)}.
     */
    public void setRiskAnalyzer(RiskAnalysis.Analyzer analyzer) {
<span class="nc" id="L1370">        lock.lock();</span>
        try {
<span class="nc" id="L1372">            this.riskAnalyzer = checkNotNull(analyzer);</span>
        } finally {
<span class="nc" id="L1374">            lock.unlock();</span>
<span class="nc" id="L1375">        }</span>
<span class="nc" id="L1376">    }</span>

    /**
     * Gets the current {@link RiskAnalysis} implementation. The default is {@link DefaultRiskAnalysis}.
     */
    public RiskAnalysis.Analyzer getRiskAnalyzer() {
<span class="nc" id="L1382">        lock.lock();</span>
        try {
<span class="nc" id="L1384">            return riskAnalyzer;</span>
        } finally {
<span class="nc" id="L1386">            lock.unlock();</span>
<span class="nc" id="L1387">        }</span>
    }

    /**
     * &lt;p&gt;Sets up the wallet to auto-save itself to the given file, using temp files with atomic renames to ensure
     * consistency. After connecting to a file, you no longer need to save the wallet manually, it will do it
     * whenever necessary. Protocol buffer serialization will be used.&lt;/p&gt;
     *
     * &lt;p&gt;If delayTime is set, a background thread will be created and the wallet will only be saved to
     * disk every so many time units. If no changes have occurred for the given time period, nothing will be written.
     * In this way disk IO can be rate limited. It's a good idea to set this as otherwise the wallet can change very
     * frequently, eg if there are a lot of transactions in it or during block sync, and there will be a lot of redundant
     * writes. Note that when a new key is added, that always results in an immediate save regardless of
     * delayTime. &lt;b&gt;You should still save the wallet manually when your program is about to shut down as the JVM
     * will not wait for the background thread.&lt;/b&gt;&lt;/p&gt;
     *
     * &lt;p&gt;An event listener can be provided. If a delay &gt;0 was specified, it will be called on a background thread
     * with the wallet locked when an auto-save occurs. If delay is zero or you do something that always triggers
     * an immediate save, like adding a key, the event listener will be invoked on the calling threads.&lt;/p&gt;
     *
     * @param f The destination file to save to.
     * @param delayTime How many time units to wait until saving the wallet on a background thread.
     * @param timeUnit the unit of measurement for delayTime.
     * @param eventListener callback to be informed when the auto-save thread does things, or null
     */
    public WalletFiles autosaveToFile(File f, long delayTime, TimeUnit timeUnit,
                                      @Nullable WalletFiles.Listener eventListener) {
<span class="nc" id="L1414">        lock.lock();</span>
        try {
<span class="nc bnc" id="L1416" title="All 2 branches missed.">            checkState(vFileManager == null, &quot;Already auto saving this wallet.&quot;);</span>
<span class="nc" id="L1417">            WalletFiles manager = new WalletFiles(this, f, delayTime, timeUnit);</span>
<span class="nc bnc" id="L1418" title="All 2 branches missed.">            if (eventListener != null)</span>
<span class="nc" id="L1419">                manager.setListener(eventListener);</span>
<span class="nc" id="L1420">            vFileManager = manager;</span>
<span class="nc" id="L1421">            return manager;</span>
        } finally {
<span class="nc" id="L1423">            lock.unlock();</span>
<span class="nc" id="L1424">        }</span>
    }

    /**
     * &lt;p&gt;
     * Disables auto-saving, after it had been enabled with
     * {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, site.mtnsj.wallet.WalletFiles.Listener)}
     * before. This method blocks until finished.
     * &lt;/p&gt;
     */
    public void shutdownAutosaveAndWait() {
<span class="nc" id="L1435">        lock.lock();</span>
        try {
<span class="nc" id="L1437">            WalletFiles files = vFileManager;</span>
<span class="nc" id="L1438">            vFileManager = null;</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">            checkState(files != null, &quot;Auto saving not enabled.&quot;);</span>
<span class="nc" id="L1440">            files.shutdownAndWait();</span>
        } finally {
<span class="nc" id="L1442">            lock.unlock();</span>
<span class="nc" id="L1443">        }</span>
<span class="nc" id="L1444">    }</span>

    /** Requests an asynchronous save on a background thread */
    protected void saveLater() {
<span class="fc" id="L1448">        WalletFiles files = vFileManager;</span>
<span class="pc bpc" id="L1449" title="1 of 2 branches missed.">        if (files != null)</span>
<span class="nc" id="L1450">            files.saveLater();</span>
<span class="fc" id="L1451">    }</span>

    /** If auto saving is enabled, do an immediate sync write to disk ignoring any delays. */
    protected void saveNow() {
<span class="fc" id="L1455">        WalletFiles files = vFileManager;</span>
<span class="pc bpc" id="L1456" title="1 of 2 branches missed.">        if (files != null) {</span>
            try {
<span class="nc" id="L1458">                files.saveNow();  // This calls back into saveToFile().</span>
<span class="nc" id="L1459">            } catch (IOException e) {</span>
                // Can't really do much at this point, just let the API user know.
<span class="nc" id="L1461">                log.error(&quot;Failed to save wallet to disk!&quot;, e);</span>
<span class="nc" id="L1462">                Thread.UncaughtExceptionHandler handler = Threading.uncaughtExceptionHandler;</span>
<span class="nc bnc" id="L1463" title="All 2 branches missed.">                if (handler != null)</span>
<span class="nc" id="L1464">                    handler.uncaughtException(Thread.currentThread(), e);</span>
<span class="nc" id="L1465">            }</span>
        }
<span class="fc" id="L1467">    }</span>

    /**
     * Uses protobuf serialization to save the wallet to the given file stream. To learn more about this file format, see
     * {@link WalletProtobufSerializer}.
     */
    public void saveToFileStream(OutputStream f) throws IOException {
<span class="fc" id="L1474">        lock.lock();</span>
        try {
<span class="fc" id="L1476">            new WalletProtobufSerializer().writeWallet(this, f);</span>
        } finally {
<span class="pc" id="L1478">            lock.unlock();</span>
<span class="pc" id="L1479">        }</span>
<span class="fc" id="L1480">    }</span>

    /** Returns the parameters this wallet was created with. */
    public NetworkParameters getParams() {
<span class="fc" id="L1484">        return params;</span>
    }

    /** Returns the API context that this wallet was created with. */
    public Context getContext() {
<span class="nc" id="L1489">        return context;</span>
    }

    /**
     * &lt;p&gt;Returns a wallet deserialized from the given file. Extensions previously saved with the wallet can be
     * deserialized by calling @{@link WalletExtension#deserializeWalletExtension(Wallet, byte[])}}&lt;/p&gt;
     *
     * @param file the wallet file to read
     * @param walletExtensions extensions possibly added to the wallet.
     */
    public static Wallet loadFromFile(File file, @Nullable WalletExtension... walletExtensions) throws UnreadableWalletException {
        try {
<span class="nc" id="L1501">            FileInputStream stream = null;</span>
            try {
<span class="nc" id="L1503">                stream = new FileInputStream(file);</span>
<span class="nc" id="L1504">                return loadFromFileStream(stream, walletExtensions);</span>
            } finally {
<span class="nc bnc" id="L1506" title="All 4 branches missed.">                if (stream != null) stream.close();</span>
<span class="nc" id="L1507">            }</span>
<span class="nc" id="L1508">        } catch (IOException e) {</span>
<span class="nc" id="L1509">            throw new UnreadableWalletException(&quot;Could not open file&quot;, e);</span>
        }
    }

    /**
     * Returns if this wallet is structurally consistent, so e.g. no duplicate transactions. First inconsistency and a
     * dump of the wallet will be logged.
     */
    public boolean isConsistent() {
        try {
<span class="fc" id="L1519">            isConsistentOrThrow();</span>
<span class="fc" id="L1520">            return true;</span>
<span class="nc" id="L1521">        } catch (IllegalStateException x) {</span>
<span class="nc" id="L1522">            log.error(x.getMessage());</span>
            try {
<span class="nc" id="L1524">                log.error(toString());</span>
<span class="nc" id="L1525">            } catch (RuntimeException x2) {</span>
<span class="nc" id="L1526">                log.error(&quot;Printing inconsistent wallet failed&quot;, x2);</span>
<span class="nc" id="L1527">            }</span>
<span class="nc" id="L1528">            return false;</span>
        }
    }

    /**
     * Variant of {@link Wallet#isConsistent()} that throws an {@link IllegalStateException} describing the first
     * inconsistency.
     */
    public void isConsistentOrThrow() throws IllegalStateException {
<span class="fc" id="L1537">        lock.lock();</span>
        try {
<span class="fc" id="L1539">            Set&lt;Transaction&gt; transactions = getTransactions(true);</span>

<span class="fc" id="L1541">            Set&lt;Sha256Hash&gt; hashes = new HashSet&lt;Sha256Hash&gt;();</span>
<span class="fc bfc" id="L1542" title="All 2 branches covered.">            for (Transaction tx : transactions) {</span>
<span class="fc" id="L1543">                hashes.add(tx.getHash());</span>
<span class="fc" id="L1544">            }</span>

<span class="fc" id="L1546">            int size1 = transactions.size();</span>
<span class="pc bpc" id="L1547" title="1 of 2 branches missed.">            if (size1 != hashes.size()) {</span>
<span class="nc" id="L1548">                throw new IllegalStateException(&quot;Two transactions with same hash&quot;);</span>
            }

<span class="fc" id="L1551">            int size2 = unspent.size() + spent.size() + pending.size() + dead.size();</span>
<span class="pc bpc" id="L1552" title="1 of 2 branches missed.">            if (size1 != size2) {</span>
<span class="nc" id="L1553">                throw new IllegalStateException(&quot;Inconsistent wallet sizes: &quot; + size1 + &quot;, &quot; + size2);</span>
            }

<span class="fc bfc" id="L1556" title="All 2 branches covered.">            for (Transaction tx : unspent.values()) {</span>
<span class="pc bpc" id="L1557" title="1 of 2 branches missed.">                if (!isTxConsistent(tx, false)) {</span>
<span class="nc" id="L1558">                    throw new IllegalStateException(&quot;Inconsistent unspent tx: &quot; + tx.getHashAsString());</span>
                }
<span class="fc" id="L1560">            }</span>

<span class="fc bfc" id="L1562" title="All 2 branches covered.">            for (Transaction tx : spent.values()) {</span>
<span class="pc bpc" id="L1563" title="1 of 2 branches missed.">                if (!isTxConsistent(tx, true)) {</span>
<span class="nc" id="L1564">                    throw new IllegalStateException(&quot;Inconsistent spent tx: &quot; + tx.getHashAsString());</span>
                }
<span class="fc" id="L1566">            }</span>
        } finally {
<span class="pc" id="L1568">            lock.unlock();</span>
<span class="pc" id="L1569">        }</span>
<span class="fc" id="L1570">    }</span>

    /*
     * If isSpent - check that all my outputs spent, otherwise check that there at least
     * one unspent.
     */
    @VisibleForTesting
    boolean isTxConsistent(final Transaction tx, final boolean isSpent) {
<span class="fc" id="L1578">        boolean isActuallySpent = true;</span>
<span class="fc bfc" id="L1579" title="All 2 branches covered.">        for (TransactionOutput o : tx.getOutputs()) {</span>
<span class="fc bfc" id="L1580" title="All 2 branches covered.">            if (o.isAvailableForSpending()) {</span>
<span class="fc bfc" id="L1581" title="All 2 branches covered.">                if (o.isMineOrWatched(this)) isActuallySpent = false;</span>
<span class="pc bpc" id="L1582" title="1 of 2 branches missed.">                if (o.getSpentBy() != null) {</span>
<span class="nc" id="L1583">                    log.error(&quot;isAvailableForSpending != spentBy&quot;);</span>
<span class="nc" id="L1584">                    return false;</span>
                }
            } else {
<span class="pc bpc" id="L1587" title="1 of 2 branches missed.">                if (o.getSpentBy() == null) {</span>
<span class="nc" id="L1588">                    log.error(&quot;isAvailableForSpending != spentBy&quot;);</span>
<span class="nc" id="L1589">                    return false;</span>
                }
            }
<span class="fc" id="L1592">        }</span>
<span class="pc bpc" id="L1593" title="1 of 2 branches missed.">        return isActuallySpent == isSpent;</span>
    }

    /** Returns a wallet deserialized from the given input stream and wallet extensions. */
    public static Wallet loadFromFileStream(InputStream stream, @Nullable WalletExtension... walletExtensions) throws UnreadableWalletException {
<span class="fc" id="L1598">        Wallet wallet = new WalletProtobufSerializer().readWallet(stream, walletExtensions);</span>
<span class="pc bpc" id="L1599" title="1 of 2 branches missed.">        if (!wallet.isConsistent()) {</span>
<span class="nc" id="L1600">            log.error(&quot;Loaded an inconsistent wallet&quot;);</span>
        }
<span class="fc" id="L1602">        return wallet;</span>
    }

    //endregion

    /******************************************************************************************************************/

    //region Inbound transaction reception and processing

    /**
     * Called by the {@link BlockChain} when we receive a new filtered block that contains a transactions previously
     * received by a call to {@link #receivePending}.&lt;p&gt;
     *
     * This is necessary for the internal book-keeping Wallet does. When a transaction is received that sends us
     * coins it is added to a pool so we can use it later to create spends. When a transaction is received that
     * consumes outputs they are marked as spent so they won't be used in future.&lt;p&gt;
     *
     * A transaction that spends our own coins can be received either because a spend we created was accepted by the
     * network and thus made it into a block, or because our keys are being shared between multiple instances and
     * some other node spent the coins instead. We still have to know about that to avoid accidentally trying to
     * double spend.&lt;p&gt;
     *
     * A transaction may be received multiple times if is included into blocks in parallel chains. The blockType
     * parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     * inactive side chain. We must still record these transactions and the blocks they appear in because a future
     * block might change which chain is best causing a reorganize. A re-org can totally change our balance!
     */
    @Override
    public boolean notifyTransactionIsInBlock(Sha256Hash txHash, StoredBlock block,
                                              BlockChain.NewBlockType blockType,
                                              int relativityOffset) throws VerificationException {
<span class="nc" id="L1633">        lock.lock();</span>
        try {
<span class="nc" id="L1635">            Transaction tx = transactions.get(txHash);</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">            if (tx == null) {</span>
<span class="nc" id="L1637">                tx = riskDropped.get(txHash);</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">                if (tx != null) {</span>
                    // If this happens our risk analysis is probably wrong and should be improved.
<span class="nc" id="L1640">                    log.info(&quot;Risk analysis dropped tx {} but was included in block anyway&quot;, tx.getHash());</span>
                } else {
                    // False positive that was broadcast to us and ignored by us because it was irrelevant to our keys.
<span class="nc" id="L1643">                    return false;</span>
                }
            }
<span class="nc" id="L1646">            receive(tx, block, blockType, relativityOffset);</span>
<span class="nc" id="L1647">            return true;</span>
        } finally {
<span class="nc" id="L1649">            lock.unlock();</span>
<span class="nc" id="L1650">        }</span>
    }

    /**
     * &lt;p&gt;Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     * and want to record it. Note that we &lt;b&gt;cannot verify these transactions at all&lt;/b&gt;, they may spend fictional
     * coins or be otherwise invalid. They are useful to inform the user about coins they can expect to receive soon,
     * and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     * be double spent as an optimization.&lt;/p&gt;
     *
     * &lt;p&gt;This is the same as {@link Wallet#receivePending(Transaction, java.util.List)} but allows you to override the
     * {@link Wallet#isPendingTransactionRelevant(Transaction)} sanity-check to keep track of transactions that are not
     * spendable or spend our coins. This can be useful when you want to keep track of transaction confidence on
     * arbitrary transactions. Note that transactions added in this way will still be relayed to peers and appear in
     * transaction lists like any other pending transaction (even when not relevant).&lt;/p&gt;
     */
    public void receivePending(Transaction tx, @Nullable List&lt;Transaction&gt; dependencies, boolean overrideIsRelevant) throws VerificationException {
        // Can run in a peer thread. This method will only be called if a prior call to isPendingTransactionRelevant
        // returned true, so we already know by this point that it sends coins to or from our wallet, or is a double
        // spend against one of our other pending transactions.
<span class="nc" id="L1670">        lock.lock();</span>
        try {
<span class="nc" id="L1672">            tx.verify();</span>
            // Ignore it if we already know about this transaction. Receiving a pending transaction never moves it
            // between pools.
<span class="nc" id="L1675">            EnumSet&lt;Pool&gt; containingPools = getContainingPools(tx);</span>
<span class="nc bnc" id="L1676" title="All 2 branches missed.">            if (!containingPools.equals(EnumSet.noneOf(Pool.class))) {</span>
<span class="nc" id="L1677">                log.debug(&quot;Received tx we already saw in a block or created ourselves: &quot; + tx.getHashAsString());</span>
<span class="nc" id="L1678">                return;</span>
            }
            // Repeat the check of relevancy here, even though the caller may have already done so - this is to avoid
            // race conditions where receivePending may be being called in parallel.
<span class="nc bnc" id="L1682" title="All 4 branches missed.">            if (!overrideIsRelevant &amp;&amp; !isPendingTransactionRelevant(tx))</span>
<span class="nc" id="L1683">                return;</span>
<span class="nc bnc" id="L1684" title="All 4 branches missed.">            if (isTransactionRisky(tx, dependencies) &amp;&amp; !acceptRiskyTransactions) {</span>
                // isTransactionRisky already logged the reason.
<span class="nc" id="L1686">                riskDropped.put(tx.getHash(), tx);</span>
<span class="nc" id="L1687">                log.warn(&quot;There are now {} risk dropped transactions being kept in memory&quot;, riskDropped.size());</span>
<span class="nc" id="L1688">                return;</span>
            }
<span class="nc" id="L1690">            Coin valueSentToMe = tx.getValueSentToMe(this);</span>
<span class="nc" id="L1691">            Coin valueSentFromMe = tx.getValueSentFromMe(this);</span>
<span class="nc bnc" id="L1692" title="All 2 branches missed.">            if (log.isInfoEnabled()) {</span>
<span class="nc" id="L1693">                log.info(String.format(Locale.US, &quot;Received a pending transaction %s that spends %s from our own wallet,&quot; +</span>
<span class="nc" id="L1694">                        &quot; and sends us %s&quot;, tx.getHashAsString(), valueSentFromMe.toFriendlyString(),</span>
<span class="nc" id="L1695">                        valueSentToMe.toFriendlyString()));</span>
            }
<span class="nc bnc" id="L1697" title="All 2 branches missed.">            if (tx.getConfidence().getSource().equals(TransactionConfidence.Source.UNKNOWN)) {</span>
<span class="nc" id="L1698">                log.warn(&quot;Wallet received transaction with an unknown source. Consider tagging it!&quot;);</span>
            }
            // If this tx spends any of our unspent outputs, mark them as spent now, then add to the pending pool. This
            // ensures that if some other client that has our keys broadcasts a spend we stay in sync. Also updates the
            // timestamp on the transaction and registers/runs event listeners.
<span class="nc" id="L1703">            commitTx(tx);</span>
        } finally {
<span class="nc" id="L1705">            lock.unlock();</span>
<span class="nc" id="L1706">        }</span>
        // maybeRotateKeys() will ignore pending transactions so we don't bother calling it here (see the comments
        // in that function for an explanation of why).
<span class="nc" id="L1709">    }</span>

    public void receiveLock(Transaction tx) throws VerificationException {
        // Can run in a peer thread. This method will only be called if a prior call to isPendingTransactionLockRelevant
        // returned true, so we already know by this point that it sends coins to or from our wallet, or is a double
        // spend against one of our other pending transactions.
<span class="nc" id="L1715">        lock.lock();</span>
        try {
<span class="nc" id="L1717">            tx.verify();</span>

<span class="nc" id="L1719">            Transaction lockedTx = pending.get(tx.getHash());</span>
            //lockedTx.getConfidence().setConfidenceType(ConfidenceType.INSTANTX_LOCKED);
<span class="nc" id="L1721">            confidenceChanged.put(lockedTx, TransactionConfidence.Listener.ChangeReason.TYPE);</span>

            //TODO:  this is causing problems later, the transaction doesn't get setAppearedInBlock, etc, Wallet crashes.
            //unspent.put(lockedTx.getHash(), lockedTx);
            //pending.remove(lockedTx);

        } finally {
<span class="nc" id="L1728">            lock.unlock();</span>
<span class="nc" id="L1729">        }</span>
        // maybeRotateKeys() will ignore pending transactions so we don't bother calling it here (see the comments
        // in that function for an explanation of why).
<span class="nc" id="L1732">    }</span>

    /**
     * Given a transaction and an optional list of dependencies (recursive/flattened), returns true if the given
     * transaction would be rejected by the analyzer, or false otherwise. The result of this call is independent
     * of the value of {@link #isAcceptRiskyTransactions()}. Risky transactions yield a logged warning. If you
     * want to know the reason why a transaction is risky, create an instance of the {@link RiskAnalysis} yourself
     * using the factory returned by {@link #getRiskAnalyzer()} and use it directly.
     */
    public boolean isTransactionRisky(Transaction tx, @Nullable List&lt;Transaction&gt; dependencies) {
<span class="nc" id="L1742">        lock.lock();</span>
        try {
<span class="nc bnc" id="L1744" title="All 2 branches missed.">            if (dependencies == null)</span>
<span class="nc" id="L1745">                dependencies = ImmutableList.of();</span>
<span class="nc" id="L1746">            RiskAnalysis analysis = riskAnalyzer.create(this, tx, dependencies);</span>
<span class="nc" id="L1747">            RiskAnalysis.Result result = analysis.analyze();</span>
<span class="nc bnc" id="L1748" title="All 2 branches missed.">            if (result != RiskAnalysis.Result.OK) {</span>
<span class="nc" id="L1749">                log.warn(&quot;Pending transaction was considered risky: {}\n{}&quot;, analysis, tx);</span>
<span class="nc" id="L1750">                return true;</span>
            }
<span class="nc" id="L1752">            return false;</span>
        } finally {
<span class="nc" id="L1754">            lock.unlock();</span>
<span class="nc" id="L1755">        }</span>
    }

    /**
     * &lt;p&gt;Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     * and want to record it. Note that we &lt;b&gt;cannot verify these transactions at all&lt;/b&gt;, they may spend fictional
     * coins or be otherwise invalid. They are useful to inform the user about coins they can expect to receive soon,
     * and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     * be double spent as an optimization.&lt;/p&gt;
     *
     * &lt;p&gt;Before this method is called, {@link Wallet#isPendingTransactionRelevant(Transaction)} should have been
     * called to decide whether the wallet cares about the transaction - if it does, then this method expects the
     * transaction and any dependencies it has which are still in the memory pool.&lt;/p&gt;
     */
    public void receivePending(Transaction tx, @Nullable List&lt;Transaction&gt; dependencies) throws VerificationException {
<span class="nc" id="L1770">        receivePending(tx, dependencies, false);</span>
<span class="nc" id="L1771">    }</span>

    /**
     * This method is used by a {@link Peer} to find out if a transaction that has been announced is interesting,
     * that is, whether we should bother downloading its dependencies and exploring the transaction to decide how
     * risky it is. If this method returns true then {@link Wallet#receivePending(Transaction, java.util.List)}
     * will soon be called with the transactions dependencies as well.
     */
    public boolean isPendingTransactionRelevant(Transaction tx) throws ScriptException {
<span class="nc" id="L1780">        lock.lock();</span>
        try {
            // Ignore it if we already know about this transaction. Receiving a pending transaction never moves it
            // between pools.
<span class="nc" id="L1784">            EnumSet&lt;Pool&gt; containingPools = getContainingPools(tx);</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">            if (!containingPools.equals(EnumSet.noneOf(Pool.class))) {</span>
<span class="nc" id="L1786">                log.debug(&quot;Received tx we already saw in a block or created ourselves: &quot; + tx.getHashAsString());</span>
<span class="nc" id="L1787">                return false;</span>
            }
            // We only care about transactions that:
            //   - Send us coins
            //   - Spend our coins
            //   - Double spend a tx in our wallet
<span class="nc bnc" id="L1793" title="All 2 branches missed.">            if (!isTransactionRelevant(tx)) {</span>
<span class="nc" id="L1794">                log.debug(&quot;Received tx that isn't relevant to this wallet, discarding.&quot;);</span>
<span class="nc" id="L1795">                return false;</span>
            }
<span class="nc" id="L1797">            return true;</span>
        } finally {
<span class="nc" id="L1799">            lock.unlock();</span>
<span class="nc" id="L1800">        }</span>
    }

    public boolean isPendingTransactionLockRelevant(Transaction tx) throws ScriptException {
<span class="nc" id="L1804">        lock.lock();</span>
        try {
<span class="nc" id="L1806">            boolean hasPendingTxLockRequest = getPendingTransactions().contains(tx);</span>
<span class="nc bnc" id="L1807" title="All 2 branches missed.">            if(!hasPendingTxLockRequest)</span>
<span class="nc" id="L1808">                return false;</span>
            // Ignore it if we already know about this transaction. Receiving a pending transaction never moves it
            // between pools.
            /*EnumSet&lt;Pool&gt; containingPools = getContainingPools(tx);
            if (!containingPools.equals(EnumSet.noneOf(Pool.class))) {
                log.debug(&quot;Received tx we already saw in a block or created ourselves: &quot; + tx.getHashAsString());
                return false;
            }*/
            // We only care about transactions that:
            //   - Send us coins
            //   - Spend our coins
<span class="nc bnc" id="L1819" title="All 2 branches missed.">            if (!isTransactionRelevant(tx)) {</span>
<span class="nc" id="L1820">                log.debug(&quot;Received tx that isn't relevant to this wallet, discarding.&quot;);</span>
<span class="nc" id="L1821">                return false;</span>
            }
<span class="nc" id="L1823">            return true;</span>
        } finally {
<span class="nc" id="L1825">            lock.unlock();</span>
<span class="nc" id="L1826">        }</span>
    }

    /**
     * &lt;p&gt;Returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs,
     * and also returns true if tx has inputs that are spending outputs which are
     * not ours but which are spent by pending transactions.&lt;/p&gt;
     *
     * &lt;p&gt;Note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet,
     * it will not be considered relevant.&lt;/p&gt;
     */
    public boolean isTransactionRelevant(Transaction tx) throws ScriptException {
<span class="fc" id="L1838">        lock.lock();</span>
        try {
<span class="fc bfc" id="L1840" title="All 2 branches covered.">            return tx.getValueSentFromMe(this).signum() &gt; 0 ||</span>
<span class="fc bfc" id="L1841" title="All 2 branches covered.">                   tx.getValueSentToMe(this).signum() &gt; 0 ||</span>
<span class="pc bpc" id="L1842" title="1 of 2 branches missed.">                   !findDoubleSpendsAgainst(tx, transactions).isEmpty();</span>
        } finally {
<span class="pc" id="L1844">            lock.unlock();</span>
<span class="nc" id="L1845">        }</span>
    }

    /**
     * Finds transactions in the specified candidates that double spend &quot;tx&quot;. Not a general check, but it can work even if
     * the double spent inputs are not ours.
     * @return The set of transactions that double spend &quot;tx&quot;.
     */
    private Set&lt;Transaction&gt; findDoubleSpendsAgainst(Transaction tx, Map&lt;Sha256Hash, Transaction&gt; candidates) {
<span class="fc" id="L1854">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc bfc" id="L1855" title="All 2 branches covered.">        if (tx.isCoinBase()) return Sets.newHashSet();</span>
        // Compile a set of outpoints that are spent by tx.
<span class="fc" id="L1857">        HashSet&lt;TransactionOutPoint&gt; outpoints = new HashSet&lt;TransactionOutPoint&gt;();</span>
<span class="fc bfc" id="L1858" title="All 2 branches covered.">        for (TransactionInput input : tx.getInputs()) {</span>
<span class="fc" id="L1859">            outpoints.add(input.getOutpoint());</span>
<span class="fc" id="L1860">        }</span>
        // Now for each pending transaction, see if it shares any outpoints with this tx.
<span class="fc" id="L1862">        Set&lt;Transaction&gt; doubleSpendTxns = Sets.newHashSet();</span>
<span class="fc bfc" id="L1863" title="All 2 branches covered.">        for (Transaction p : candidates.values()) {</span>
<span class="fc bfc" id="L1864" title="All 2 branches covered.">            for (TransactionInput input : p.getInputs()) {</span>
                // This relies on the fact that TransactionOutPoint equality is defined at the protocol not object
                // level - outpoints from two different inputs that point to the same output compare the same.
<span class="fc" id="L1867">                TransactionOutPoint outpoint = input.getOutpoint();</span>
<span class="fc bfc" id="L1868" title="All 2 branches covered.">                if (outpoints.contains(outpoint)) {</span>
                    // It does, it's a double spend against the candidates, which makes it relevant.
<span class="fc" id="L1870">                    doubleSpendTxns.add(p);</span>
                }
<span class="fc" id="L1872">            }</span>
<span class="fc" id="L1873">        }</span>
<span class="fc" id="L1874">        return doubleSpendTxns;</span>
    }

    /**
     * Adds to txSet all the txns in txPool spending outputs of txns in txSet,
     * and all txns spending the outputs of those txns, recursively.
     */
    void addTransactionsDependingOn(Set&lt;Transaction&gt; txSet, Set&lt;Transaction&gt; txPool) {
<span class="fc" id="L1882">        Map&lt;Sha256Hash, Transaction&gt; txQueue = new LinkedHashMap&lt;Sha256Hash, Transaction&gt;();</span>
<span class="fc bfc" id="L1883" title="All 2 branches covered.">        for (Transaction tx : txSet) {</span>
<span class="fc" id="L1884">            txQueue.put(tx.getHash(), tx);</span>
<span class="fc" id="L1885">        }</span>
<span class="fc bfc" id="L1886" title="All 2 branches covered.">        while(!txQueue.isEmpty()) {</span>
<span class="fc" id="L1887">            Transaction tx = txQueue.remove(txQueue.keySet().iterator().next());</span>
<span class="fc bfc" id="L1888" title="All 2 branches covered.">            for (Transaction anotherTx : txPool) {</span>
<span class="fc bfc" id="L1889" title="All 2 branches covered.">                if (anotherTx.equals(tx)) continue;</span>
<span class="fc bfc" id="L1890" title="All 2 branches covered.">                for (TransactionInput input : anotherTx.getInputs()) {</span>
<span class="fc bfc" id="L1891" title="All 2 branches covered.">                    if (input.getOutpoint().getHash().equals(tx.getHash())) {</span>
<span class="pc bpc" id="L1892" title="1 of 2 branches missed.">                        if (txQueue.get(anotherTx.getHash()) == null) {</span>
<span class="fc" id="L1893">                            txQueue.put(anotherTx.getHash(), anotherTx);</span>
<span class="fc" id="L1894">                            txSet.add(anotherTx);</span>
                        }
                    }
<span class="fc" id="L1897">                }</span>
<span class="fc" id="L1898">            }</span>
<span class="fc" id="L1899">        }</span>
<span class="fc" id="L1900">    }</span>

    /**
     * Called by the {@link BlockChain} when we receive a new block that sends coins to one of our addresses or
     * spends coins from one of our addresses (note that a single transaction can do both).&lt;p&gt;
     *
     * This is necessary for the internal book-keeping Wallet does. When a transaction is received that sends us
     * coins it is added to a pool so we can use it later to create spends. When a transaction is received that
     * consumes outputs they are marked as spent so they won't be used in future.&lt;p&gt;
     *
     * A transaction that spends our own coins can be received either because a spend we created was accepted by the
     * network and thus made it into a block, or because our keys are being shared between multiple instances and
     * some other node spent the coins instead. We still have to know about that to avoid accidentally trying to
     * double spend.&lt;p&gt;
     *
     * A transaction may be received multiple times if is included into blocks in parallel chains. The blockType
     * parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     * inactive side chain. We must still record these transactions and the blocks they appear in because a future
     * block might change which chain is best causing a reorganize. A re-org can totally change our balance!
     */
    @Override
    public void receiveFromBlock(Transaction tx, StoredBlock block,
                                 BlockChain.NewBlockType blockType,
                                 int relativityOffset) throws VerificationException {
<span class="fc" id="L1924">        lock.lock();</span>
        try {
<span class="fc bfc" id="L1926" title="All 2 branches covered.">            if (!isTransactionRelevant(tx))</span>
<span class="fc" id="L1927">                return;</span>
<span class="fc" id="L1928">            receive(tx, block, blockType, relativityOffset);</span>
        } finally {
<span class="pc" id="L1930">            lock.unlock();</span>
<span class="pc" id="L1931">        }</span>
<span class="fc" id="L1932">    }</span>

    // Whether to do a saveNow or saveLater when we are notified of the next best block.
<span class="fc" id="L1935">    private boolean hardSaveOnNextBlock = false;</span>

    private void receive(Transaction tx, StoredBlock block, BlockChain.NewBlockType blockType,
                         int relativityOffset) throws VerificationException {
        // Runs in a peer thread.
<span class="fc" id="L1940">        checkState(lock.isHeldByCurrentThread());</span>

<span class="fc" id="L1942">        Coin prevBalance = getBalance();</span>
<span class="fc" id="L1943">        Sha256Hash txHash = tx.getHash();</span>
<span class="fc bfc" id="L1944" title="All 2 branches covered.">        boolean bestChain = blockType == BlockChain.NewBlockType.BEST_CHAIN;</span>
<span class="fc bfc" id="L1945" title="All 2 branches covered.">        boolean sideChain = blockType == BlockChain.NewBlockType.SIDE_CHAIN;</span>

<span class="fc" id="L1947">        Coin valueSentFromMe = tx.getValueSentFromMe(this);</span>
<span class="fc" id="L1948">        Coin valueSentToMe = tx.getValueSentToMe(this);</span>
<span class="fc" id="L1949">        Coin valueDifference = valueSentToMe.subtract(valueSentFromMe);</span>

<span class="fc bfc" id="L1951" title="All 2 branches covered.">        log.info(&quot;Received tx{} for {}: {} [{}] in block {}&quot;, sideChain ? &quot; on a side chain&quot; : &quot;&quot;,</span>
<span class="pc bpc" id="L1952" title="1 of 2 branches missed.">                valueDifference.toFriendlyString(), tx.getHashAsString(), relativityOffset,</span>
<span class="pc" id="L1953">                block != null ? block.getHeader().getHash() : &quot;(unit test)&quot;);</span>

        // Inform the key chains that the issued keys were observed in a transaction, so they know to
        // calculate more keys for the next Bloom filters.
<span class="fc" id="L1957">        markKeysAsUsed(tx);</span>

<span class="fc" id="L1959">        onWalletChangedSuppressions++;</span>

        // If this transaction is already in the wallet we may need to move it into a different pool. At the very
        // least we need to ensure we're manipulating the canonical object rather than a duplicate.
        {
<span class="fc" id="L1964">            Transaction tmp = transactions.get(tx.getHash());</span>
<span class="fc bfc" id="L1965" title="All 2 branches covered.">            if (tmp != null)</span>
<span class="fc" id="L1966">                tx = tmp;</span>
        }

<span class="fc bfc" id="L1969" title="All 2 branches covered.">        boolean wasPending = pending.remove(txHash) != null;</span>
<span class="fc bfc" id="L1970" title="All 2 branches covered.">        if (wasPending)</span>
<span class="fc" id="L1971">            log.info(&quot;  &lt;-pending&quot;);</span>

<span class="fc bfc" id="L1973" title="All 2 branches covered.">        if (bestChain) {</span>
<span class="fc bfc" id="L1974" title="All 2 branches covered.">            boolean wasDead = dead.remove(txHash) != null;</span>
<span class="fc bfc" id="L1975" title="All 2 branches covered.">            if (wasDead)</span>
<span class="fc" id="L1976">                log.info(&quot;  &lt;-dead&quot;);</span>
<span class="fc bfc" id="L1977" title="All 2 branches covered.">            if (wasPending) {</span>
                // Was pending and is now confirmed. Disconnect the outputs in case we spent any already: they will be
                // re-connected by processTxFromBestChain below.
<span class="fc bfc" id="L1980" title="All 2 branches covered.">                for (TransactionOutput output : tx.getOutputs()) {</span>
<span class="fc" id="L1981">                    final TransactionInput spentBy = output.getSpentBy();</span>
<span class="fc bfc" id="L1982" title="All 2 branches covered.">                    if (spentBy != null) {</span>
<span class="fc" id="L1983">                        checkState(myUnspents.add(output));</span>
<span class="fc" id="L1984">                        spentBy.disconnect();</span>
                    }
<span class="fc" id="L1986">                }</span>
            }
<span class="fc bfc" id="L1988" title="All 4 branches covered.">            processTxFromBestChain(tx, wasPending || wasDead);</span>
<span class="fc" id="L1989">        } else {</span>
<span class="fc" id="L1990">            checkState(sideChain);</span>
            // Transactions that appear in a side chain will have that appearance recorded below - we assume that
            // some miners are also trying to include the transaction into the current best chain too, so let's treat
            // it as pending, except we don't need to do any risk analysis on it.
<span class="fc bfc" id="L1994" title="All 2 branches covered.">            if (wasPending) {</span>
                // Just put it back in without touching the connections or confidence.
<span class="fc" id="L1996">                addWalletTransaction(Pool.PENDING, tx);</span>
<span class="fc" id="L1997">                log.info(&quot;  -&gt;pending&quot;);</span>
            } else {
                // Ignore the case where a tx appears on a side chain at the same time as the best chain (this is
                // quite normal and expected).
<span class="fc" id="L2001">                Sha256Hash hash = tx.getHash();</span>
<span class="pc bpc" id="L2002" title="1 of 6 branches missed.">                if (!unspent.containsKey(hash) &amp;&amp; !spent.containsKey(hash) &amp;&amp; !dead.containsKey(hash)) {</span>
                    // Otherwise put it (possibly back) into pending.
                    // Committing it updates the spent flags and inserts into the pool as well.
<span class="fc" id="L2005">                    commitTx(tx);</span>
                }
            }
        }

<span class="pc bpc" id="L2010" title="1 of 2 branches missed.">        if (block != null) {</span>
            // Mark the tx as appearing in this block so we can find it later after a re-org. This also tells the tx
            // confidence object about the block and sets its depth appropriately.
<span class="fc" id="L2013">            tx.setBlockAppearance(block, bestChain, relativityOffset);</span>
            //added for Dash
            //todo furszy: commented.
<span class="pc bpc" id="L2016" title="1 of 2 branches missed.">            if (context.instantSend!=null)</span>
<span class="nc" id="L2017">                context.instantSend.syncTransaction(tx, block);</span>
<span class="fc bfc" id="L2018" title="All 2 branches covered.">            if (bestChain) {</span>
                // Don't notify this tx of work done in notifyNewBestBlock which will be called immediately after
                // this method has been called by BlockChain for all relevant transactions. Otherwise we'd double
                // count.
<span class="fc" id="L2022">                ignoreNextNewBlock.add(txHash);</span>

                // When a tx is received from the best chain, if other txns that spend this tx are IN_CONFLICT,
                // change its confidence to PENDING (Unless they are also spending other txns IN_CONFLICT).
                // Consider dependency chains.
<span class="fc" id="L2027">                Set&lt;Transaction&gt; currentTxDependencies = Sets.newHashSet(tx);</span>
<span class="fc" id="L2028">                addTransactionsDependingOn(currentTxDependencies, getTransactions(true));</span>
<span class="fc" id="L2029">                currentTxDependencies.remove(tx);</span>
<span class="fc" id="L2030">                List&lt;Transaction&gt; currentTxDependenciesSorted = sortTxnsByDependency(currentTxDependencies);</span>
<span class="fc bfc" id="L2031" title="All 2 branches covered.">                for (Transaction txDependency : currentTxDependenciesSorted) {</span>
<span class="pc bpc" id="L2032" title="1 of 2 branches missed.">                    if (txDependency.getConfidence().getConfidenceType().equals(ConfidenceType.IN_CONFLICT)) {</span>
<span class="nc bnc" id="L2033" title="All 2 branches missed.">                        if (isNotSpendingTxnsInConfidenceType(txDependency, ConfidenceType.IN_CONFLICT)) {</span>
<span class="nc" id="L2034">                            txDependency.getConfidence().setConfidenceType(ConfidenceType.PENDING);</span>
<span class="nc" id="L2035">                            confidenceChanged.put(txDependency, TransactionConfidence.Listener.ChangeReason.TYPE);</span>
                        }
                    }
<span class="fc" id="L2038">                }</span>
            }
        }

<span class="fc" id="L2042">        onWalletChangedSuppressions--;</span>

        // Side chains don't affect confidence.
<span class="fc bfc" id="L2045" title="All 2 branches covered.">        if (bestChain) {</span>
            // notifyNewBestBlock will be invoked next and will then call maybeQueueOnWalletChanged for us.
<span class="fc" id="L2047">            confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE);</span>
        } else {
<span class="fc" id="L2049">            maybeQueueOnWalletChanged();</span>
        }

        // Inform anyone interested that we have received or sent coins but only if:
        //  - This is not due to a re-org.
        //  - The coins appeared on the best chain.
        //  - We did in fact receive some new money.
        //  - We have not already informed the user about the coins when we received the tx broadcast, or for our
        //    own spends. If users want to know when a broadcast tx becomes confirmed, they need to use tx confidence
        //    listeners.
<span class="fc bfc" id="L2059" title="All 4 branches covered.">        if (!insideReorg &amp;&amp; bestChain) {</span>
<span class="fc" id="L2060">            Coin newBalance = getBalance();  // This is slow.</span>
<span class="fc" id="L2061">            log.info(&quot;Balance is now: &quot; + newBalance.toFriendlyString());</span>
<span class="fc bfc" id="L2062" title="All 2 branches covered.">            if (!wasPending) {</span>
<span class="fc" id="L2063">                int diff = valueDifference.signum();</span>
                // We pick one callback based on the value difference, though a tx can of course both send and receive
                // coins from the wallet.
<span class="fc bfc" id="L2066" title="All 2 branches covered.">                if (diff &gt; 0) {</span>
<span class="fc" id="L2067">                    queueOnCoinsReceived(tx, prevBalance, newBalance);</span>
<span class="pc bpc" id="L2068" title="1 of 2 branches missed.">                } else if (diff &lt; 0) {</span>
<span class="fc" id="L2069">                    queueOnCoinsSent(tx, prevBalance, newBalance);</span>
                }
            }
<span class="fc" id="L2072">            checkBalanceFuturesLocked(newBalance);</span>
        }

<span class="fc" id="L2075">        informConfidenceListenersIfNotReorganizing();</span>
<span class="fc" id="L2076">        isConsistentOrThrow();</span>
        // Optimization for the case where a block has tons of relevant transactions.
<span class="fc" id="L2078">        saveLater();</span>
<span class="fc" id="L2079">        hardSaveOnNextBlock = true;</span>
<span class="fc" id="L2080">    }</span>

    /** Finds if tx is NOT spending other txns which are in the specified confidence type */
    private boolean isNotSpendingTxnsInConfidenceType(Transaction tx, ConfidenceType confidenceType) {
<span class="fc bfc" id="L2084" title="All 2 branches covered.">        for (TransactionInput txInput : tx.getInputs()) {</span>
<span class="fc" id="L2085">            Transaction connectedTx = this.getTransaction(txInput.getOutpoint().getHash());</span>
<span class="pc bpc" id="L2086" title="1 of 4 branches missed.">            if (connectedTx != null &amp;&amp; connectedTx.getConfidence().getConfidenceType().equals(confidenceType)) {</span>
<span class="nc" id="L2087">                return false;</span>
            }
<span class="fc" id="L2089">        }</span>
<span class="fc" id="L2090">        return true;</span>
    }

    /**
     * Creates and returns a new List with the same txns as inputSet
     * but txns are sorted by depencency (a topological sort).
     * If tx B spends tx A, then tx A should be before tx B on the returned List.
     * Several invocations to this method with the same inputSet could result in lists with txns in different order,
     * as there is no guarantee on the order of the returned txns besides what was already stated.
     */
    List&lt;Transaction&gt; sortTxnsByDependency(Set&lt;Transaction&gt; inputSet) {
<span class="fc" id="L2101">        ArrayList&lt;Transaction&gt; result = new ArrayList&lt;Transaction&gt;(inputSet);</span>
<span class="pc bpc" id="L2102" title="1 of 2 branches missed.">        for (int i = 0; i &lt; result.size()-1; i++) {</span>
            boolean txAtISpendsOtherTxInTheList;
            do {
<span class="nc" id="L2105">                txAtISpendsOtherTxInTheList = false;</span>
<span class="nc bnc" id="L2106" title="All 2 branches missed.">                for (int j = i+1; j &lt; result.size(); j++) {</span>
<span class="nc bnc" id="L2107" title="All 2 branches missed.">                    if (spends(result.get(i), result.get(j))) {</span>
<span class="nc" id="L2108">                        Transaction transactionAtI = result.remove(i);</span>
<span class="nc" id="L2109">                        result.add(j, transactionAtI);</span>
<span class="nc" id="L2110">                        txAtISpendsOtherTxInTheList = true;</span>
<span class="nc" id="L2111">                        break;</span>
                    }
                }
<span class="nc bnc" id="L2114" title="All 2 branches missed.">            } while (txAtISpendsOtherTxInTheList);</span>
        }
<span class="fc" id="L2116">        return result;</span>
    }

    /** Finds whether txA spends txB */
    boolean spends(Transaction txA, Transaction txB) {
<span class="nc bnc" id="L2121" title="All 2 branches missed.">        for (TransactionInput txInput : txA.getInputs()) {</span>
<span class="nc bnc" id="L2122" title="All 2 branches missed.">            if (txInput.getOutpoint().getHash().equals(txB.getHash())) {</span>
<span class="nc" id="L2123">                return true;</span>
            }
<span class="nc" id="L2125">        }</span>
<span class="nc" id="L2126">        return false;</span>
    }

    private void informConfidenceListenersIfNotReorganizing() {
<span class="fc bfc" id="L2130" title="All 2 branches covered.">        if (insideReorg)</span>
<span class="fc" id="L2131">            return;</span>
<span class="fc bfc" id="L2132" title="All 2 branches covered.">        for (Map.Entry&lt;Transaction, TransactionConfidence.Listener.ChangeReason&gt; entry : confidenceChanged.entrySet()) {</span>
<span class="fc" id="L2133">            final Transaction tx = entry.getKey();</span>
<span class="fc" id="L2134">            tx.getConfidence().queueListeners(entry.getValue());</span>
<span class="fc" id="L2135">            queueOnTransactionConfidenceChanged(tx);</span>
<span class="fc" id="L2136">        }</span>
<span class="fc" id="L2137">        confidenceChanged.clear();</span>
<span class="fc" id="L2138">    }</span>

    /**
     * &lt;p&gt;Called by the {@link BlockChain} when a new block on the best chain is seen, AFTER relevant wallet
     * transactions are extracted and sent to us UNLESS the new block caused a re-org, in which case this will
     * not be called (the {@link Wallet#reorganize(StoredBlock, java.util.List, java.util.List)} method will
     * call this one in that case).&lt;/p&gt;
     * &lt;p/&gt;
     * &lt;p&gt;Used to update confidence data in each transaction and last seen block hash. Triggers auto saving.
     * Invokes the onWalletChanged event listener if there were any affected transactions.&lt;/p&gt;
     */
    @Override
    public void notifyNewBestBlock(StoredBlock block) throws VerificationException {
        // Check to see if this block has been seen before.
<span class="fc" id="L2152">        Sha256Hash newBlockHash = block.getHeader().getHash();</span>
<span class="pc bpc" id="L2153" title="1 of 2 branches missed.">        if (newBlockHash.equals(getLastBlockSeenHash()))</span>
<span class="nc" id="L2154">            return;</span>
<span class="fc" id="L2155">        lock.lock();</span>
        try {
            // Store the new block hash.
<span class="fc" id="L2158">            setLastBlockSeenHash(newBlockHash);</span>
<span class="fc" id="L2159">            setLastBlockSeenHeight(block.getHeight());</span>
<span class="fc" id="L2160">            setLastBlockSeenTimeSecs(block.getHeader().getTimeSeconds());</span>
            // Notify all the BUILDING transactions of the new block.
            // This is so that they can update their depth.
<span class="fc" id="L2163">            Set&lt;Transaction&gt; transactions = getTransactions(true);</span>
<span class="fc bfc" id="L2164" title="All 2 branches covered.">            for (Transaction tx : transactions) {</span>
<span class="fc bfc" id="L2165" title="All 2 branches covered.">                if (ignoreNextNewBlock.contains(tx.getHash())) {</span>
                    // tx was already processed in receive() due to it appearing in this block, so we don't want to
                    // increment the tx confidence depth twice, it'd result in miscounting.
<span class="fc" id="L2168">                    ignoreNextNewBlock.remove(tx.getHash());</span>
                    //TODO:  put this code below, this part has been changed.
                } else {
<span class="fc" id="L2171">                    TransactionConfidence confidence = tx.getConfidence();</span>
<span class="fc bfc" id="L2172" title="All 2 branches covered.">                    if (confidence.getConfidenceType() == ConfidenceType.BUILDING) {</span>
                        // Erase the set of seen peers once the tx is so deep that it seems unlikely to ever go
                        // pending again. We could clear this data the moment a tx is seen in the block chain, but
                        // in cases where the chain re-orgs, this would mean that wallets would perceive a newly
                        // pending tx has zero confidence at all, which would not be right: we expect it to be
                        // included once again. We could have a separate was-in-chain-and-now-isn't confidence type
                        // but this way is backwards compatible with existing software, and the new state probably
                        // wouldn't mean anything different to just remembering peers anyway.
<span class="pc bpc" id="L2180" title="1 of 2 branches missed.">                        if (confidence.incrementDepthInBlocks() &gt; context.getEventHorizon())</span>
<span class="nc" id="L2181">                            confidence.clearBroadcastBy();</span>
<span class="fc" id="L2182">                        confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.DEPTH);</span>
                    }
                }
<span class="fc" id="L2185">            }</span>

<span class="fc" id="L2187">            informConfidenceListenersIfNotReorganizing();</span>
<span class="fc" id="L2188">            maybeQueueOnWalletChanged();</span>

<span class="fc bfc" id="L2190" title="All 2 branches covered.">            if (hardSaveOnNextBlock) {</span>
<span class="fc" id="L2191">                saveNow();</span>
<span class="fc" id="L2192">                hardSaveOnNextBlock = false;</span>
            } else {
                // Coalesce writes to avoid throttling on disk access when catching up with the chain.
<span class="fc" id="L2195">                saveLater();</span>
            }
        } finally {
<span class="pc" id="L2198">            lock.unlock();</span>
<span class="pc" id="L2199">        }</span>
<span class="fc" id="L2200">    }</span>

    /**
     * Handle when a transaction becomes newly active on the best chain, either due to receiving a new block or a
     * re-org. Places the tx into the right pool, handles coinbase transactions, handles double-spends and so on.
     */
    private void processTxFromBestChain(Transaction tx, boolean forceAddToPool) throws VerificationException {
<span class="fc" id="L2207">        checkState(lock.isHeldByCurrentThread());</span>
<span class="pc bpc" id="L2208" title="1 of 2 branches missed.">        checkState(!pending.containsKey(tx.getHash()));</span>

        // This TX may spend our existing outputs even though it was not pending. This can happen in unit
        // tests, if keys are moved between wallets, if we're catching up to the chain given only a set of keys,
        // or if a dead coinbase transaction has moved back onto the main chain.
<span class="pc bpc" id="L2213" title="1 of 4 branches missed.">        boolean isDeadCoinbase = tx.isCoinBase() &amp;&amp; dead.containsKey(tx.getHash());</span>
<span class="pc bpc" id="L2214" title="1 of 2 branches missed.">        if (isDeadCoinbase) {</span>
            // There is a dead coinbase tx being received on the best chain. A coinbase tx is made dead when it moves
            // to a side chain but it can be switched back on a reorg and resurrected back to spent or unspent.
            // So take it out of the dead pool. Note that we don't resurrect dependent transactions here, even though
            // we could. Bitcoin Core nodes on the network have deleted the dependent transactions from their mempools
            // entirely by this point. We could and maybe should rebroadcast them so the network remembers and tries
            // to confirm them again. But this is a deeply unusual edge case that due to the maturity rule should never
            // happen in practice, thus for simplicities sake we ignore it here.
<span class="nc" id="L2222">            log.info(&quot;  coinbase tx &lt;-dead: confidence {}&quot;, tx.getHashAsString(),</span>
<span class="nc" id="L2223">                    tx.getConfidence().getConfidenceType().name());</span>
<span class="nc" id="L2224">            dead.remove(tx.getHash());</span>
        }

        // Update tx and other unspent/pending transactions by connecting inputs/outputs.
<span class="fc" id="L2228">        updateForSpends(tx, true);</span>

        // Now make sure it ends up in the right pool. Also, handle the case where this TX is double-spending
        // against our pending transactions. Note that a tx may double spend our pending transactions and also send
        // us money/spend our money.
<span class="fc bfc" id="L2233" title="All 2 branches covered.">        boolean hasOutputsToMe = tx.getValueSentToMe(this).signum() &gt; 0;</span>
<span class="fc bfc" id="L2234" title="All 2 branches covered.">        if (hasOutputsToMe) {</span>
            // Needs to go into either unspent or spent (if the outputs were already spent by a pending tx).
<span class="fc bfc" id="L2236" title="All 2 branches covered.">            if (tx.isEveryOwnedOutputSpent(this)) {</span>
<span class="fc" id="L2237">                log.info(&quot;  tx {} -&gt;spent (by pending)&quot;, tx.getHashAsString());</span>
<span class="fc" id="L2238">                addWalletTransaction(Pool.SPENT, tx);</span>
            } else {
<span class="fc" id="L2240">                log.info(&quot;  tx {} -&gt;unspent&quot;, tx.getHashAsString());</span>
<span class="fc" id="L2241">                addWalletTransaction(Pool.UNSPENT, tx);</span>
            }
<span class="pc bpc" id="L2243" title="1 of 2 branches missed.">        } else if (tx.getValueSentFromMe(this).signum() &gt; 0) {</span>
            // Didn't send us any money, but did spend some. Keep it around for record keeping purposes.
<span class="fc" id="L2245">            log.info(&quot;  tx {} -&gt;spent&quot;, tx.getHashAsString());</span>
<span class="fc" id="L2246">            addWalletTransaction(Pool.SPENT, tx);</span>
<span class="nc bnc" id="L2247" title="All 2 branches missed.">        } else if (forceAddToPool) {</span>
            // Was manually added to pending, so we should keep it to notify the user of confidence information
<span class="nc" id="L2249">            log.info(&quot;  tx {} -&gt;spent (manually added)&quot;, tx.getHashAsString());</span>
<span class="nc" id="L2250">            addWalletTransaction(Pool.SPENT, tx);</span>
        }

        // Kill txns in conflict with this tx
<span class="fc" id="L2254">        Set&lt;Transaction&gt; doubleSpendTxns = findDoubleSpendsAgainst(tx, pending);</span>
<span class="fc bfc" id="L2255" title="All 2 branches covered.">        if (!doubleSpendTxns.isEmpty()) {</span>
            // no need to addTransactionsDependingOn(doubleSpendTxns) because killTxns() already kills dependencies;
<span class="fc" id="L2257">            killTxns(doubleSpendTxns, tx);</span>
        }
<span class="fc" id="L2259">    }</span>

    /**
     * &lt;p&gt;Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so. If
     * fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks
     * the spent flags appropriately.&lt;/p&gt;
     *
     * &lt;p&gt;It can be called in two contexts. One is when we receive a transaction on the best chain but it wasn't pending,
     * this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching
     * up with the block chain. It can also happen if a block includes a transaction we never saw at broadcast time.
     * If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.&lt;/p&gt;
     *
     * &lt;p&gt;The other context it can be called is from {@link Wallet#receivePending(Transaction, java.util.List)},
     * ie we saw a tx be broadcast or one was submitted directly that spends our own coins. If this tx double spends
     * it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will
     * win, if we are wrong then when a block appears the tx will go dead.&lt;/p&gt;
     *
     * @param tx The transaction which is being updated.
     * @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
     */
    private void updateForSpends(Transaction tx, boolean fromChain) throws VerificationException {
<span class="fc" id="L2280">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc bfc" id="L2281" title="All 2 branches covered.">        if (fromChain)</span>
<span class="pc bpc" id="L2282" title="1 of 2 branches missed.">            checkState(!pending.containsKey(tx.getHash()));</span>
<span class="fc bfc" id="L2283" title="All 2 branches covered.">        for (TransactionInput input : tx.getInputs()) {</span>
<span class="fc" id="L2284">            TransactionInput.ConnectionResult result = input.connect(unspent, TransactionInput.ConnectMode.ABORT_ON_CONFLICT);</span>
<span class="fc bfc" id="L2285" title="All 2 branches covered.">            if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {</span>
                // Not found in the unspent map. Try again with the spent map.
<span class="fc" id="L2287">                result = input.connect(spent, TransactionInput.ConnectMode.ABORT_ON_CONFLICT);</span>
<span class="fc bfc" id="L2288" title="All 2 branches covered.">                if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {</span>
                    // Not found in the unspent and spent maps. Try again with the pending map.
<span class="fc" id="L2290">                    result = input.connect(pending, TransactionInput.ConnectMode.ABORT_ON_CONFLICT);</span>
<span class="fc bfc" id="L2291" title="All 2 branches covered.">                    if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {</span>
                        // Doesn't spend any of our outputs or is coinbase.
<span class="fc" id="L2293">                        continue;</span>
                    }
                }
            }

<span class="fc" id="L2298">            TransactionOutput output = checkNotNull(input.getConnectedOutput());</span>
<span class="fc bfc" id="L2299" title="All 2 branches covered.">            if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {</span>
<span class="fc bfc" id="L2300" title="All 2 branches covered.">                if (fromChain) {</span>
                    // Can be:
                    // (1) We already marked this output as spent when we saw the pending transaction (most likely).
                    //     Now it's being confirmed of course, we cannot mark it as spent again.
                    // (2) A double spend from chain: this will be handled later by findDoubleSpendsAgainst()/killTxns().
                    //
                    // In any case, nothing to do here.
                } else {
                    // We saw two pending transactions that double spend each other. We don't know which will win.
                    // This can happen in the case of bad network nodes that mutate transactions. Do a hex dump
                    // so the exact nature of the mutation can be examined.
<span class="fc" id="L2311">                    log.warn(&quot;Saw two pending transactions double spend each other&quot;);</span>
<span class="fc" id="L2312">                    log.warn(&quot;  offending input is input {}&quot;, tx.getInputs().indexOf(input));</span>
<span class="fc" id="L2313">                    log.warn(&quot;{}: {}&quot;, tx.getHash(), Utils.HEX.encode(tx.unsafeBitcoinSerialize()));</span>
<span class="fc" id="L2314">                    Transaction other = output.getSpentBy().getParentTransaction();</span>
<span class="fc" id="L2315">                    log.warn(&quot;{}: {}&quot;, other.getHash(), Utils.HEX.encode(other.unsafeBitcoinSerialize()));</span>
<span class="fc" id="L2316">                }</span>
<span class="pc bpc" id="L2317" title="1 of 2 branches missed.">            } else if (result == TransactionInput.ConnectionResult.SUCCESS) {</span>
                // Otherwise we saw a transaction spend our coins, but we didn't try and spend them ourselves yet.
                // The outputs are already marked as spent by the connect call above, so check if there are any more for
                // us to use. Move if not.
<span class="fc" id="L2321">                Transaction connected = checkNotNull(input.getConnectedTransaction());</span>
<span class="fc" id="L2322">                log.info(&quot;  marked {} as spent by {}&quot;, input.getOutpoint(), tx.getHashAsString());</span>
<span class="fc" id="L2323">                maybeMovePool(connected, &quot;prevtx&quot;);</span>
                // Just because it's connected doesn't mean it's actually ours: sometimes we have total visibility.
<span class="pc bpc" id="L2325" title="1 of 2 branches missed.">                if (output.isMineOrWatched(this)) {</span>
<span class="fc" id="L2326">                    checkState(myUnspents.remove(output));</span>
                }
            }
<span class="fc" id="L2329">        }</span>
        // Now check each output and see if there is a pending transaction which spends it. This shouldn't normally
        // ever occur because we expect transactions to arrive in temporal order, but this assumption can be violated
        // when we receive a pending transaction from the mempool that is relevant to us, which spends coins that we
        // didn't see arrive on the best chain yet. For instance, because of a chain replay or because of our keys were
        // used by another wallet somewhere else. Also, unconfirmed transactions can arrive from the mempool in more or
        // less random order.
<span class="fc bfc" id="L2336" title="All 2 branches covered.">        for (Transaction pendingTx : pending.values()) {</span>
<span class="fc bfc" id="L2337" title="All 2 branches covered.">            for (TransactionInput input : pendingTx.getInputs()) {</span>
<span class="fc" id="L2338">                TransactionInput.ConnectionResult result = input.connect(tx, TransactionInput.ConnectMode.ABORT_ON_CONFLICT);</span>
<span class="fc bfc" id="L2339" title="All 2 branches covered.">                if (fromChain) {</span>
                    // This TX is supposed to have just appeared on the best chain, so its outputs should not be marked
                    // as spent yet. If they are, it means something is happening out of order.
<span class="pc bpc" id="L2342" title="1 of 2 branches missed.">                    checkState(result != TransactionInput.ConnectionResult.ALREADY_SPENT);</span>
                }
<span class="fc bfc" id="L2344" title="All 2 branches covered.">                if (result == TransactionInput.ConnectionResult.SUCCESS) {</span>
<span class="fc" id="L2345">                    log.info(&quot;Connected pending tx input {}:{}&quot;,</span>
<span class="fc" id="L2346">                            pendingTx.getHashAsString(), pendingTx.getInputs().indexOf(input));</span>

                    // The unspents map might not have it if we never saw this tx until it was included in the chain
                    // and thus becomes spent the moment we become aware of it.
<span class="pc bpc" id="L2350" title="1 of 2 branches missed.">                    if (myUnspents.remove(input.getConnectedOutput()))</span>
<span class="fc" id="L2351">                        log.info(&quot;Removed from UNSPENTS: {}&quot;, input.getConnectedOutput());</span>
                }
<span class="fc" id="L2353">            }</span>
<span class="fc" id="L2354">        }</span>
<span class="fc bfc" id="L2355" title="All 2 branches covered.">        if (!fromChain) {</span>
<span class="fc" id="L2356">            maybeMovePool(tx, &quot;pendingtx&quot;);</span>
        } else {
            // If the transactions outputs are now all spent, it will be moved into the spent pool by the
            // processTxFromBestChain method.
        }
<span class="fc" id="L2361">    }</span>

    // Updates the wallet when a double spend occurs. overridingTx can be null for the case of coinbases
    private void killTxns(Set&lt;Transaction&gt; txnsToKill, @Nullable Transaction overridingTx) {
<span class="fc" id="L2365">        LinkedList&lt;Transaction&gt; work = new LinkedList&lt;Transaction&gt;(txnsToKill);</span>
<span class="fc bfc" id="L2366" title="All 2 branches covered.">        while (!work.isEmpty()) {</span>
<span class="fc" id="L2367">            final Transaction tx = work.poll();</span>
<span class="fc bfc" id="L2368" title="All 2 branches covered.">            log.warn(&quot;TX {} killed{}&quot;, tx.getHashAsString(),</span>
<span class="fc" id="L2369">                    overridingTx != null ? &quot; by &quot; + overridingTx.getHashAsString() : &quot;&quot;);</span>
<span class="fc" id="L2370">            log.warn(&quot;Disconnecting each input and moving connected transactions.&quot;);</span>
            // TX could be pending (finney attack), or in unspent/spent (coinbase killed by reorg).
<span class="fc" id="L2372">            pending.remove(tx.getHash());</span>
<span class="fc" id="L2373">            unspent.remove(tx.getHash());</span>
<span class="fc" id="L2374">            spent.remove(tx.getHash());</span>
<span class="fc" id="L2375">            addWalletTransaction(Pool.DEAD, tx);</span>
<span class="fc bfc" id="L2376" title="All 2 branches covered.">            for (TransactionInput deadInput : tx.getInputs()) {</span>
<span class="fc" id="L2377">                Transaction connected = deadInput.getConnectedTransaction();</span>
<span class="fc bfc" id="L2378" title="All 2 branches covered.">                if (connected == null) continue;</span>
<span class="pc bpc" id="L2379" title="2 of 6 branches missed.">                if (connected.getConfidence().getConfidenceType() != ConfidenceType.DEAD &amp;&amp; deadInput.getConnectedOutput().getSpentBy() != null &amp;&amp; deadInput.getConnectedOutput().getSpentBy().equals(deadInput)) {</span>
<span class="fc" id="L2380">                    checkState(myUnspents.add(deadInput.getConnectedOutput()));</span>
<span class="fc" id="L2381">                    log.info(&quot;Added to UNSPENTS: {} in {}&quot;, deadInput.getConnectedOutput(), deadInput.getConnectedOutput().getParentTransaction().getHash());</span>
                }
<span class="fc" id="L2383">                deadInput.disconnect();</span>
<span class="fc" id="L2384">                maybeMovePool(connected, &quot;kill&quot;);</span>
<span class="fc" id="L2385">            }</span>
<span class="fc" id="L2386">            tx.getConfidence().setOverridingTransaction(overridingTx);</span>
<span class="fc" id="L2387">            confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE);</span>
            // Now kill any transactions we have that depended on this one.
<span class="fc bfc" id="L2389" title="All 2 branches covered.">            for (TransactionOutput deadOutput : tx.getOutputs()) {</span>
<span class="fc bfc" id="L2390" title="All 2 branches covered.">                if (myUnspents.remove(deadOutput))</span>
<span class="fc" id="L2391">                    log.info(&quot;XX Removed from UNSPENTS: {}&quot;, deadOutput);</span>
<span class="fc" id="L2392">                TransactionInput connected = deadOutput.getSpentBy();</span>
<span class="fc bfc" id="L2393" title="All 2 branches covered.">                if (connected == null) continue;</span>
<span class="fc" id="L2394">                final Transaction parentTransaction = connected.getParentTransaction();</span>
<span class="fc" id="L2395">                log.info(&quot;This death invalidated dependent tx {}&quot;, parentTransaction.getHash());</span>
<span class="fc" id="L2396">                work.push(parentTransaction);</span>
<span class="fc" id="L2397">            }</span>
<span class="fc" id="L2398">        }</span>
<span class="fc bfc" id="L2399" title="All 2 branches covered.">        if (overridingTx == null)</span>
<span class="fc" id="L2400">            return;</span>
<span class="fc" id="L2401">        log.warn(&quot;Now attempting to connect the inputs of the overriding transaction.&quot;);</span>
<span class="fc bfc" id="L2402" title="All 2 branches covered.">        for (TransactionInput input : overridingTx.getInputs()) {</span>
<span class="fc" id="L2403">            TransactionInput.ConnectionResult result = input.connect(unspent, TransactionInput.ConnectMode.DISCONNECT_ON_CONFLICT);</span>
<span class="pc bpc" id="L2404" title="1 of 2 branches missed.">            if (result == TransactionInput.ConnectionResult.SUCCESS) {</span>
<span class="fc" id="L2405">                maybeMovePool(input.getConnectedTransaction(), &quot;kill&quot;);</span>
<span class="fc" id="L2406">                myUnspents.remove(input.getConnectedOutput());</span>
<span class="fc" id="L2407">                log.info(&quot;Removing from UNSPENTS: {}&quot;, input.getConnectedOutput());</span>
            } else {
<span class="nc" id="L2409">                result = input.connect(spent, TransactionInput.ConnectMode.DISCONNECT_ON_CONFLICT);</span>
<span class="nc bnc" id="L2410" title="All 2 branches missed.">                if (result == TransactionInput.ConnectionResult.SUCCESS) {</span>
<span class="nc" id="L2411">                    maybeMovePool(input.getConnectedTransaction(), &quot;kill&quot;);</span>
<span class="nc" id="L2412">                    myUnspents.remove(input.getConnectedOutput());</span>
<span class="nc" id="L2413">                    log.info(&quot;Removing from UNSPENTS: {}&quot;, input.getConnectedOutput());</span>
                }
            }
<span class="fc" id="L2416">        }</span>
<span class="fc" id="L2417">    }</span>

    /**
     * If the transactions outputs are all marked as spent, and it's in the unspent map, move it.
     * If the owned transactions outputs are not all marked as spent, and it's in the spent map, move it.
     */
    private void maybeMovePool(Transaction tx, String context) {
<span class="fc" id="L2424">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc bfc" id="L2425" title="All 2 branches covered.">        if (tx.isEveryOwnedOutputSpent(this)) {</span>
            // There's nothing left I can spend in this transaction.
<span class="fc bfc" id="L2427" title="All 2 branches covered.">            if (unspent.remove(tx.getHash()) != null) {</span>
<span class="pc bpc" id="L2428" title="1 of 2 branches missed.">                if (log.isInfoEnabled()) {</span>
<span class="nc" id="L2429">                    log.info(&quot;  {} {} &lt;-unspent -&gt;spent&quot;, tx.getHashAsString(), context);</span>
                }
<span class="fc" id="L2431">                spent.put(tx.getHash(), tx);</span>
            }
        } else {
<span class="fc bfc" id="L2434" title="All 2 branches covered.">            if (spent.remove(tx.getHash()) != null) {</span>
<span class="pc bpc" id="L2435" title="1 of 2 branches missed.">                if (log.isInfoEnabled()) {</span>
<span class="nc" id="L2436">                    log.info(&quot;  {} {} &lt;-spent -&gt;unspent&quot;, tx.getHashAsString(), context);</span>
                }
<span class="fc" id="L2438">                unspent.put(tx.getHash(), tx);</span>
            }
        }
<span class="fc" id="L2441">    }</span>

    /**
     * Calls {@link Wallet#commitTx} if tx is not already in the pending pool
     *
     * @return true if the tx was added to the wallet, or false if it was already in the pending pool
     */
    public boolean maybeCommitTx(Transaction tx) throws VerificationException {
<span class="fc" id="L2449">        tx.verify();</span>
<span class="fc" id="L2450">        lock.lock();</span>
        try {
<span class="pc bpc" id="L2452" title="1 of 2 branches missed.">            if (pending.containsKey(tx.getHash()))</span>
<span class="nc" id="L2453">                return false;</span>
<span class="fc" id="L2454">            log.info(&quot;commitTx of {}&quot;, tx.getHashAsString());</span>
<span class="fc" id="L2455">            Coin balance = getBalance();</span>
<span class="fc" id="L2456">            tx.setUpdateTime(Utils.now());</span>
            // Put any outputs that are sending money back to us into the unspents map, and calculate their total value.
<span class="fc" id="L2458">            Coin valueSentToMe = Coin.ZERO;</span>
<span class="fc bfc" id="L2459" title="All 2 branches covered.">            for (TransactionOutput o : tx.getOutputs()) {</span>
<span class="fc bfc" id="L2460" title="All 2 branches covered.">                if (!o.isMineOrWatched(this)) continue;</span>
<span class="fc" id="L2461">                valueSentToMe = valueSentToMe.add(o.getValue());</span>
<span class="fc" id="L2462">            }</span>
            // Mark the outputs we're spending as spent so we won't try and use them in future creations. This will also
            // move any transactions that are now fully spent to the spent map so we can skip them when creating future
            // spends.
<span class="fc" id="L2466">            updateForSpends(tx, false);</span>

<span class="fc" id="L2468">            Set&lt;Transaction&gt; doubleSpendPendingTxns = findDoubleSpendsAgainst(tx, pending);</span>
<span class="fc" id="L2469">            Set&lt;Transaction&gt; doubleSpendUnspentTxns = findDoubleSpendsAgainst(tx, unspent);</span>
<span class="fc" id="L2470">            Set&lt;Transaction&gt; doubleSpendSpentTxns = findDoubleSpendsAgainst(tx, spent);</span>

<span class="fc bfc" id="L2472" title="All 2 branches covered.">            if (!doubleSpendUnspentTxns.isEmpty() ||</span>
<span class="pc bpc" id="L2473" title="1 of 2 branches missed.">                !doubleSpendSpentTxns.isEmpty() ||</span>
<span class="pc bpc" id="L2474" title="1 of 2 branches missed.">                !isNotSpendingTxnsInConfidenceType(tx, ConfidenceType.DEAD)) {</span>
                // tx is a double spend against a tx already in the best chain or spends outputs of a DEAD tx.
                // Add tx to the dead pool and schedule confidence listener notifications.
<span class="fc" id="L2477">                log.info(&quot;-&gt;dead: {}&quot;, tx.getHashAsString());</span>
<span class="fc" id="L2478">                tx.getConfidence().setConfidenceType(ConfidenceType.DEAD);</span>
<span class="fc" id="L2479">                confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE);</span>
<span class="fc" id="L2480">                addWalletTransaction(Pool.DEAD, tx);</span>
<span class="fc bfc" id="L2481" title="All 2 branches covered.">            } else if (!doubleSpendPendingTxns.isEmpty() ||</span>
<span class="pc bpc" id="L2482" title="1 of 2 branches missed.">                !isNotSpendingTxnsInConfidenceType(tx, ConfidenceType.IN_CONFLICT)) {</span>
                // tx is a double spend against a pending tx or spends outputs of a tx already IN_CONFLICT.
                // Add tx to the pending pool. Update the confidence type of tx, the txns in conflict with tx and all
                // their dependencies to IN_CONFLICT and schedule confidence listener notifications.
<span class="fc" id="L2486">                log.info(&quot;-&gt;pending (IN_CONFLICT): {}&quot;, tx.getHashAsString());</span>
<span class="fc" id="L2487">                addWalletTransaction(Pool.PENDING, tx);</span>
<span class="fc" id="L2488">                doubleSpendPendingTxns.add(tx);</span>
<span class="fc" id="L2489">                addTransactionsDependingOn(doubleSpendPendingTxns, getTransactions(true));</span>
<span class="fc bfc" id="L2490" title="All 2 branches covered.">                for (Transaction doubleSpendTx : doubleSpendPendingTxns) {</span>
<span class="fc" id="L2491">                    doubleSpendTx.getConfidence().setConfidenceType(ConfidenceType.IN_CONFLICT);</span>
<span class="fc" id="L2492">                    confidenceChanged.put(doubleSpendTx, TransactionConfidence.Listener.ChangeReason.TYPE);</span>
<span class="fc" id="L2493">                }</span>
            } else {
                // No conflict detected.
                // Add to the pending pool and schedule confidence listener notifications.
<span class="fc" id="L2497">                log.info(&quot;-&gt;pending: {}&quot;, tx.getHashAsString());</span>
<span class="fc" id="L2498">                tx.getConfidence().setConfidenceType(ConfidenceType.PENDING);</span>
<span class="pc bpc" id="L2499" title="1 of 2 branches missed.">                if(tx instanceof TransactionLockRequest) //TODO:InstantX - may need to adjust the ones above too?</span>
<span class="nc" id="L2500">                    tx.getConfidence().setIXType(IXType.IX_REQUEST);//setConfidenceType(ConfidenceType.INSTANTX_PENDING);</span>
                //else tx.getConfidence().setConfidenceType(ConfidenceType.PENDING);
<span class="fc" id="L2502">                confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE);</span>
<span class="fc" id="L2503">                addWalletTransaction(Pool.PENDING, tx);</span>
            }
<span class="pc bpc" id="L2505" title="1 of 2 branches missed.">            if (log.isInfoEnabled())</span>
<span class="nc" id="L2506">                log.info(&quot;Estimated balance is now: {}&quot;, getBalance(BalanceType.ESTIMATED).toFriendlyString());</span>


            // Mark any keys used in the outputs as &quot;used&quot;, this allows wallet UI's to auto-advance the current key
            // they are showing to the user in qr codes etc.
<span class="fc" id="L2511">            markKeysAsUsed(tx);</span>
            try {
<span class="fc" id="L2513">                Coin valueSentFromMe = tx.getValueSentFromMe(this);</span>
<span class="fc" id="L2514">                Coin newBalance = balance.add(valueSentToMe).subtract(valueSentFromMe);</span>
<span class="fc bfc" id="L2515" title="All 2 branches covered.">                if (valueSentToMe.signum() &gt; 0) {</span>
<span class="fc" id="L2516">                    checkBalanceFuturesLocked(null);</span>
<span class="fc" id="L2517">                    queueOnCoinsReceived(tx, balance, newBalance);</span>
                }
<span class="fc bfc" id="L2519" title="All 2 branches covered.">                if (valueSentFromMe.signum() &gt; 0)</span>
<span class="fc" id="L2520">                    queueOnCoinsSent(tx, balance, newBalance);</span>

<span class="fc" id="L2522">                maybeQueueOnWalletChanged();</span>
<span class="nc" id="L2523">            } catch (ScriptException e) {</span>
                // Cannot happen as we just created this transaction ourselves.
<span class="nc" id="L2525">                throw new RuntimeException(e);</span>
<span class="fc" id="L2526">            }</span>

<span class="fc" id="L2528">            isConsistentOrThrow();</span>

            //Dash Specific
<span class="pc bpc" id="L2531" title="3 of 4 branches missed.">            if(tx.getConfidence().isIX() &amp;&amp; tx.getConfidence().getSource() == Source.SELF) {</span>
<span class="nc" id="L2532">                context.instantSend.processTxLockRequest((TransactionLockRequest)tx);</span>
            }

<span class="fc" id="L2535">            informConfidenceListenersIfNotReorganizing();</span>
<span class="fc" id="L2536">            saveNow();</span>
        } finally {
<span class="pc" id="L2538">            lock.unlock();</span>
<span class="pc" id="L2539">        }</span>
<span class="fc" id="L2540">        return true;</span>
    }

    /**
     * &lt;p&gt;Updates the wallet with the given transaction: puts it into the pending pool, sets the spent flags and runs
     * the onCoinsSent/onCoinsReceived event listener. Used in two situations:&lt;/p&gt;
     *
     * &lt;ol&gt;
     *     &lt;li&gt;When we have just successfully transmitted the tx we created to the network.&lt;/li&gt;
     *     &lt;li&gt;When we receive a pending transaction that didn't appear in the chain yet, and we did not create it.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;Triggers an auto save.&lt;/p&gt;
     */
    public void commitTx(Transaction tx) throws VerificationException {
<span class="fc" id="L2555">        checkArgument(maybeCommitTx(tx), &quot;commitTx called on the same transaction twice&quot;);</span>
<span class="fc" id="L2556">    }</span>

    //endregion

    /******************************************************************************************************************/

    //region Event listeners

    /**
     * Adds an event listener object. Methods on this object are called when something interesting happens,
     * like receiving money. Runs the listener methods in the user thread.
     */
    public void addEventListener(WalletEventListener listener) {
<span class="nc" id="L2569">        addChangeEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L2570">        addCoinsReceivedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L2571">        addCoinsSentEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L2572">        addKeyChainEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L2573">        addReorganizeEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L2574">        addScriptChangeEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L2575">        addTransactionConfidenceEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L2576">    }</span>

    /** Use the more specific listener methods instead */
    @Deprecated
    public void addEventListener(WalletEventListener listener, Executor executor) {
<span class="nc" id="L2581">        addCoinsReceivedEventListener(executor, listener);</span>
<span class="nc" id="L2582">        addCoinsSentEventListener(executor, listener);</span>
<span class="nc" id="L2583">        addChangeEventListener(executor, listener);</span>
<span class="nc" id="L2584">        addKeyChainEventListener(executor, listener);</span>
<span class="nc" id="L2585">        addReorganizeEventListener(executor, listener);</span>
<span class="nc" id="L2586">        addScriptChangeEventListener(executor, listener);</span>
<span class="nc" id="L2587">        addTransactionConfidenceEventListener(executor, listener);</span>
<span class="nc" id="L2588">    }</span>

    /**
     * Adds an event listener object. Methods on this object are called when something interesting happens,
     * like receiving money. Runs the listener methods in the user thread.
     */
    public void addChangeEventListener(WalletChangeEventListener listener) {
<span class="fc" id="L2595">        addChangeEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L2596">    }</span>

    /**
     * Adds an event listener object. Methods on this object are called when something interesting happens,
     * like receiving money. The listener is executed by the given executor.
     */
    public void addChangeEventListener(Executor executor, WalletChangeEventListener listener) {
        // This is thread safe, so we don't need to take the lock.
<span class="fc" id="L2604">        changeListeners.add(new ListenerRegistration&lt;WalletChangeEventListener&gt;(listener, executor));</span>
<span class="fc" id="L2605">    }</span>

    /**
     * Adds an event listener object called when coins are received.
     * Runs the listener methods in the user thread.
     */
    public void addCoinsReceivedEventListener(WalletCoinsReceivedEventListener listener) {
<span class="fc" id="L2612">        addCoinsReceivedEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L2613">    }</span>

    /**
     * Adds an event listener object called when coins are received.
     * The listener is executed by the given executor.
     */
    public void addCoinsReceivedEventListener(Executor executor, WalletCoinsReceivedEventListener listener) {
        // This is thread safe, so we don't need to take the lock.
<span class="fc" id="L2621">        coinsReceivedListeners.add(new ListenerRegistration&lt;WalletCoinsReceivedEventListener&gt;(listener, executor));</span>
<span class="fc" id="L2622">    }</span>

    /**
     * Adds an event listener object called when coins are sent.
     * Runs the listener methods in the user thread.
     */
    public void addCoinsSentEventListener(WalletCoinsSentEventListener listener) {
<span class="nc" id="L2629">        addCoinsSentEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L2630">    }</span>

    /**
     * Adds an event listener object called when coins are sent.
     * The listener is executed by the given executor.
     */
    public void addCoinsSentEventListener(Executor executor, WalletCoinsSentEventListener listener) {
        // This is thread safe, so we don't need to take the lock.
<span class="nc" id="L2638">        coinsSentListeners.add(new ListenerRegistration&lt;WalletCoinsSentEventListener&gt;(listener, executor));</span>
<span class="nc" id="L2639">    }</span>

    /**
     * Adds an event listener object. Methods on this object are called when keys are
     * added. The listener is executed in the user thread.
     */
    public void addKeyChainEventListener(KeyChainEventListener listener) {
<span class="nc" id="L2646">        keyChainGroup.addEventListener(listener, Threading.USER_THREAD);</span>
<span class="nc" id="L2647">    }</span>

    /**
     * Adds an event listener object. Methods on this object are called when keys are
     * added. The listener is executed by the given executor.
     */
    public void addKeyChainEventListener(Executor executor, KeyChainEventListener listener) {
<span class="nc" id="L2654">        keyChainGroup.addEventListener(listener, executor);</span>
<span class="nc" id="L2655">    }</span>

    /**
     * Adds an event listener object. Methods on this object are called when something interesting happens,
     * like receiving money. Runs the listener methods in the user thread.
     */
    public void addReorganizeEventListener(WalletReorganizeEventListener listener) {
<span class="fc" id="L2662">        addReorganizeEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L2663">    }</span>

    /**
     * Adds an event listener object. Methods on this object are called when something interesting happens,
     * like receiving money. The listener is executed by the given executor.
     */
    public void addReorganizeEventListener(Executor executor, WalletReorganizeEventListener listener) {
        // This is thread safe, so we don't need to take the lock.
<span class="fc" id="L2671">        reorganizeListeners.add(new ListenerRegistration&lt;WalletReorganizeEventListener&gt;(listener, executor));</span>
<span class="fc" id="L2672">    }</span>

    /**
     * Adds an event listener object. Methods on this object are called when scripts
     * watched by this wallet change. Runs the listener methods in the user thread.
     */
    public void addScriptsChangeEventListener(ScriptsChangeEventListener listener) {
<span class="nc" id="L2679">        addScriptChangeEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L2680">    }</span>

    /**
     * Adds an event listener object. Methods on this object are called when scripts
     * watched by this wallet change. The listener is executed by the given executor.
     */
    public void addScriptChangeEventListener(Executor executor, ScriptsChangeEventListener listener) {
        // This is thread safe, so we don't need to take the lock.
<span class="nc" id="L2688">        scriptChangeListeners.add(new ListenerRegistration&lt;ScriptsChangeEventListener&gt;(listener, executor));</span>
<span class="nc" id="L2689">    }</span>

    /**
     * Adds an event listener object. Methods on this object are called when confidence
     * of a transaction changes. Runs the listener methods in the user thread.
     */
    public void addTransactionConfidenceEventListener(TransactionConfidenceEventListener listener) {
<span class="fc" id="L2696">        addTransactionConfidenceEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L2697">    }</span>

    /**
     * Adds an event listener object. Methods on this object are called when confidence
     * of a transaction changes. The listener is executed by the given executor.
     */
    public void addTransactionConfidenceEventListener(Executor executor, TransactionConfidenceEventListener listener) {
        // This is thread safe, so we don't need to take the lock.
<span class="fc" id="L2705">        transactionConfidenceListeners.add(new ListenerRegistration&lt;TransactionConfidenceEventListener&gt;(listener, executor));</span>
<span class="fc" id="L2706">    }</span>

    /**
     * Removes the given event listener object. Returns true if the listener was removed, false if that listener
     * was never added.
     * @deprecated use the fine-grain event listeners instead.
     */
    @Deprecated
    public boolean removeEventListener(WalletEventListener listener) {
<span class="nc bnc" id="L2715" title="All 2 branches missed.">        return removeChangeEventListener(listener) ||</span>
<span class="nc bnc" id="L2716" title="All 2 branches missed.">            removeCoinsReceivedEventListener(listener) ||</span>
<span class="nc bnc" id="L2717" title="All 2 branches missed.">            removeCoinsSentEventListener(listener) ||</span>
<span class="nc bnc" id="L2718" title="All 2 branches missed.">            removeKeyChainEventListener(listener) ||</span>
<span class="nc bnc" id="L2719" title="All 2 branches missed.">            removeReorganizeEventListener(listener) ||</span>
<span class="nc bnc" id="L2720" title="All 2 branches missed.">            removeTransactionConfidenceEventListener(listener);</span>
    }

    /**
     * Removes the given event listener object. Returns true if the listener was removed, false if that listener
     * was never added.
     */
    public boolean removeChangeEventListener(WalletChangeEventListener listener) {
<span class="nc" id="L2728">        return ListenerRegistration.removeFromList(listener, changeListeners);</span>
    }

    /**
     * Removes the given event listener object. Returns true if the listener was removed, false if that listener
     * was never added.
     */
    public boolean removeCoinsReceivedEventListener(WalletCoinsReceivedEventListener listener) {
<span class="nc" id="L2736">        return ListenerRegistration.removeFromList(listener, coinsReceivedListeners);</span>
    }

    /**
     * Removes the given event listener object. Returns true if the listener was removed, false if that listener
     * was never added.
     */
    public boolean removeCoinsSentEventListener(WalletCoinsSentEventListener listener) {
<span class="nc" id="L2744">        return ListenerRegistration.removeFromList(listener, coinsSentListeners);</span>
    }

    /**
     * Removes the given event listener object. Returns true if the listener was removed, false if that listener
     * was never added.
     */
    public boolean removeKeyChainEventListener(KeyChainEventListener listener) {
<span class="nc" id="L2752">        return keyChainGroup.removeEventListener(listener);</span>
    }

    /**
     * Removes the given event listener object. Returns true if the listener was removed, false if that listener
     * was never added.
     */
    public boolean removeReorganizeEventListener(WalletReorganizeEventListener listener) {
<span class="nc" id="L2760">        return ListenerRegistration.removeFromList(listener, reorganizeListeners);</span>
    }

    /**
     * Removes the given event listener object. Returns true if the listener was removed, false if that listener
     * was never added.
     */
    public boolean removeScriptChangeEventListener(ScriptsChangeEventListener listener) {
<span class="nc" id="L2768">        return ListenerRegistration.removeFromList(listener, scriptChangeListeners);</span>
    }

    /**
     * Removes the given event listener object. Returns true if the listener was removed, false if that listener
     * was never added.
     */
    public boolean removeTransactionConfidenceEventListener(TransactionConfidenceEventListener listener) {
<span class="nc" id="L2776">        return ListenerRegistration.removeFromList(listener, transactionConfidenceListeners);</span>
    }

    private void queueOnTransactionConfidenceChanged(final Transaction tx) {
<span class="fc" id="L2780">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc bfc" id="L2781" title="All 2 branches covered.">        for (final ListenerRegistration&lt;TransactionConfidenceEventListener&gt; registration : transactionConfidenceListeners) {</span>
<span class="pc bpc" id="L2782" title="1 of 2 branches missed.">            if (registration.executor == Threading.SAME_THREAD) {</span>
<span class="nc" id="L2783">                registration.listener.onTransactionConfidenceChanged(this, tx);</span>
            } else {
<span class="fc" id="L2785">                registration.executor.execute(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L2788">                        registration.listener.onTransactionConfidenceChanged(Wallet.this, tx);</span>
<span class="fc" id="L2789">                    }</span>
                });
            }
<span class="fc" id="L2792">        }</span>
<span class="fc" id="L2793">    }</span>

    protected void maybeQueueOnWalletChanged() {
        // Don't invoke the callback in some circumstances, eg, whilst we are re-organizing or fiddling with
        // transactions due to a new block arriving. It will be called later instead.
<span class="fc" id="L2798">        checkState(lock.isHeldByCurrentThread());</span>
<span class="pc bpc" id="L2799" title="1 of 2 branches missed.">        checkState(onWalletChangedSuppressions &gt;= 0);</span>
<span class="fc bfc" id="L2800" title="All 2 branches covered.">        if (onWalletChangedSuppressions &gt; 0) return;</span>
<span class="fc bfc" id="L2801" title="All 2 branches covered.">        for (final ListenerRegistration&lt;WalletChangeEventListener&gt; registration : changeListeners) {</span>
<span class="fc" id="L2802">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L2805">                    registration.listener.onWalletChanged(Wallet.this);</span>
<span class="fc" id="L2806">                }</span>
            });
<span class="fc" id="L2808">        }</span>
<span class="fc" id="L2809">    }</span>

    protected void queueOnCoinsReceived(final Transaction tx, final Coin balance, final Coin newBalance) {
<span class="fc" id="L2812">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc bfc" id="L2813" title="All 2 branches covered.">        for (final ListenerRegistration&lt;WalletCoinsReceivedEventListener&gt; registration : coinsReceivedListeners) {</span>
<span class="fc" id="L2814">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L2817">                    registration.listener.onCoinsReceived(Wallet.this, tx, balance, newBalance);</span>
<span class="fc" id="L2818">                }</span>
            });
<span class="fc" id="L2820">        }</span>
<span class="fc" id="L2821">    }</span>

    protected void queueOnCoinsSent(final Transaction tx, final Coin prevBalance, final Coin newBalance) {
<span class="fc" id="L2824">        checkState(lock.isHeldByCurrentThread());</span>
<span class="pc bpc" id="L2825" title="1 of 2 branches missed.">        for (final ListenerRegistration&lt;WalletCoinsSentEventListener&gt; registration : coinsSentListeners) {</span>
<span class="nc" id="L2826">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L2829">                    registration.listener.onCoinsSent(Wallet.this, tx, prevBalance, newBalance);</span>
<span class="nc" id="L2830">                }</span>
            });
<span class="nc" id="L2832">        }</span>
<span class="fc" id="L2833">    }</span>

    protected void queueOnReorganize() {
<span class="fc" id="L2836">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L2837">        checkState(insideReorg);</span>
<span class="fc bfc" id="L2838" title="All 2 branches covered.">        for (final ListenerRegistration&lt;WalletReorganizeEventListener&gt; registration : reorganizeListeners) {</span>
<span class="fc" id="L2839">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L2842">                    registration.listener.onReorganize(Wallet.this);</span>
<span class="fc" id="L2843">                }</span>
            });
<span class="fc" id="L2845">        }</span>
<span class="fc" id="L2846">    }</span>


    protected void queueOnScriptsChanged(final List&lt;Script&gt; scripts, final boolean isAddingScripts) {
<span class="nc bnc" id="L2850" title="All 2 branches missed.">        for (final ListenerRegistration&lt;ScriptsChangeEventListener&gt; registration : scriptChangeListeners) {</span>
<span class="nc" id="L2851">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L2854">                    registration.listener.onScriptsChanged(Wallet.this, scripts, isAddingScripts);</span>
<span class="nc" id="L2855">                }</span>
            });
<span class="nc" id="L2857">        }</span>
<span class="nc" id="L2858">    }</span>

    //endregion

    /******************************************************************************************************************/

    //region Vending transactions and other internal state

    /**
     * Returns a set of all transactions in the wallet.
     * @param includeDead     If true, transactions that were overridden by a double spend are included.
     */
    public Set&lt;Transaction&gt; getTransactions(boolean includeDead) {
<span class="fc" id="L2871">        lock.lock();</span>
        try {
<span class="fc" id="L2873">            Set&lt;Transaction&gt; all = new HashSet&lt;Transaction&gt;();</span>
<span class="fc" id="L2874">            all.addAll(unspent.values());</span>
<span class="fc" id="L2875">            all.addAll(spent.values());</span>
<span class="fc" id="L2876">            all.addAll(pending.values());</span>
<span class="pc bpc" id="L2877" title="1 of 2 branches missed.">            if (includeDead)</span>
<span class="fc" id="L2878">                all.addAll(dead.values());</span>
<span class="fc" id="L2879">            return all;</span>
        } finally {
<span class="pc" id="L2881">            lock.unlock();</span>
<span class="nc" id="L2882">        }</span>
    }

    /**
     * Returns a set of all WalletTransactions in the wallet.
     */
    public Iterable&lt;WalletTransaction&gt; getWalletTransactions() {
<span class="fc" id="L2889">        lock.lock();</span>
        try {
<span class="fc" id="L2891">            Set&lt;WalletTransaction&gt; all = new HashSet&lt;WalletTransaction&gt;();</span>
<span class="fc" id="L2892">            addWalletTransactionsToSet(all, Pool.UNSPENT, unspent.values());</span>
<span class="fc" id="L2893">            addWalletTransactionsToSet(all, Pool.SPENT, spent.values());</span>
<span class="fc" id="L2894">            addWalletTransactionsToSet(all, Pool.DEAD, dead.values());</span>
<span class="fc" id="L2895">            addWalletTransactionsToSet(all, Pool.PENDING, pending.values());</span>
<span class="fc" id="L2896">            return all;</span>
        } finally {
<span class="pc" id="L2898">            lock.unlock();</span>
<span class="nc" id="L2899">        }</span>
    }

    private static void addWalletTransactionsToSet(Set&lt;WalletTransaction&gt; txns,
                                                   Pool poolType, Collection&lt;Transaction&gt; pool) {
<span class="fc bfc" id="L2904" title="All 2 branches covered.">        for (Transaction tx : pool) {</span>
<span class="fc" id="L2905">            txns.add(new WalletTransaction(poolType, tx));</span>
<span class="fc" id="L2906">        }</span>
<span class="fc" id="L2907">    }</span>

    /**
     * Adds a transaction that has been associated with a particular wallet pool. This is intended for usage by
     * deserialization code, such as the {@link WalletProtobufSerializer} class. It isn't normally useful for
     * applications. It does not trigger auto saving.
     */
    public void addWalletTransaction(WalletTransaction wtx) {
<span class="fc" id="L2915">        lock.lock();</span>
        try {
<span class="fc" id="L2917">            addWalletTransaction(wtx.getPool(), wtx.getTransaction());</span>
        } finally {
<span class="pc" id="L2919">            lock.unlock();</span>
<span class="pc" id="L2920">        }</span>
<span class="fc" id="L2921">    }</span>

    /**
     * Adds the given transaction to the given pools and registers a confidence change listener on it.
     */
    private void addWalletTransaction(Pool pool, Transaction tx) {
<span class="fc" id="L2927">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L2928">        transactions.put(tx.getHash(), tx);</span>
<span class="pc bpc" id="L2929" title="1 of 5 branches missed.">        switch (pool) {</span>
        case UNSPENT:
            //case INSTANTX_LOCKED:
<span class="pc bpc" id="L2932" title="1 of 2 branches missed.">            if (unspent.containsKey(tx.getHash())) System.out.println(&quot;Unspent pool contains: &quot;+tx.getHashAsString());</span>
<span class="pc bpc" id="L2933" title="1 of 2 branches missed.">            checkState(unspent.put(tx.getHash(), tx) == null);</span>
<span class="fc" id="L2934">            break;</span>
        case SPENT:
<span class="pc bpc" id="L2936" title="1 of 2 branches missed.">            boolean b = spent.put(tx.getHash(), tx) == null;</span>
<span class="fc" id="L2937">            log.error(&quot;### Transaction already on the SPENT pool.. &quot;+tx.toString());</span>
            //checkState(spent.put(tx.getHash(), tx) == null);
<span class="fc" id="L2939">            break;</span>
        case PENDING:
        //case INSTANTX_PENDING:

<span class="pc bpc" id="L2943" title="1 of 2 branches missed.">            checkState(pending.put(tx.getHash(), tx) == null);</span>
<span class="fc" id="L2944">            break;</span>
        case DEAD:
<span class="pc bpc" id="L2946" title="1 of 2 branches missed.">            checkState(dead.put(tx.getHash(), tx) == null);</span>
<span class="fc" id="L2947">            break;</span>
        default:
<span class="nc" id="L2949">            throw new RuntimeException(&quot;Unknown wallet transaction type &quot; + pool);</span>
        }
<span class="fc bfc" id="L2951" title="All 4 branches covered.">        if (pool == Pool.UNSPENT || pool == Pool.PENDING) {</span>
<span class="fc bfc" id="L2952" title="All 2 branches covered.">            for (TransactionOutput output : tx.getOutputs()) {</span>
<span class="pc bpc" id="L2953" title="1 of 4 branches missed.">                if (output.isAvailableForSpending() &amp;&amp; output.isMineOrWatched(this))</span>
<span class="fc" id="L2954">                    myUnspents.add(output);</span>
<span class="fc" id="L2955">            }</span>
        }
        // This is safe even if the listener has been added before, as TransactionConfidence ignores duplicate
        // registration requests. That makes the code in the wallet simpler.
<span class="fc" id="L2959">        tx.getConfidence().addEventListener(Threading.SAME_THREAD, txConfidenceListener);</span>
<span class="fc" id="L2960">    }</span>

    /**
     * Returns all non-dead, active transactions ordered by recency.
     */
    public List&lt;Transaction&gt; getTransactionsByTime() {
<span class="nc" id="L2966">        return getRecentTransactions(0, false);</span>
    }

    /**
     * Returns an list of N transactions, ordered by increasing age. Transactions on side chains are not included.
     * Dead transactions (overridden by double spends) are optionally included. &lt;p&gt;
     * &lt;p/&gt;
     * Note: the current implementation is O(num transactions in wallet). Regardless of how many transactions are
     * requested, the cost is always the same. In future, requesting smaller numbers of transactions may be faster
     * depending on how the wallet is implemented (eg if backed by a database).
     */
    public List&lt;Transaction&gt; getRecentTransactions(int numTransactions, boolean includeDead) {
<span class="nc" id="L2978">        lock.lock();</span>
        try {
<span class="nc bnc" id="L2980" title="All 2 branches missed.">            checkArgument(numTransactions &gt;= 0);</span>
            // Firstly, put all transactions into an array.
<span class="nc" id="L2982">            int size = unspent.size() + spent.size() + pending.size();</span>
<span class="nc bnc" id="L2983" title="All 4 branches missed.">            if (numTransactions &gt; size || numTransactions == 0) {</span>
<span class="nc" id="L2984">                numTransactions = size;</span>
            }
<span class="nc" id="L2986">            ArrayList&lt;Transaction&gt; all = new ArrayList&lt;Transaction&gt;(getTransactions(includeDead));</span>
            // Order by update time.
<span class="nc" id="L2988">            Collections.sort(all, Transaction.SORT_TX_BY_UPDATE_TIME);</span>
<span class="nc bnc" id="L2989" title="All 2 branches missed.">            if (numTransactions == all.size()) {</span>
<span class="nc" id="L2990">                return all;</span>
            } else {
<span class="nc" id="L2992">                all.subList(numTransactions, all.size()).clear();</span>
<span class="nc" id="L2993">                return all;</span>
            }
        } finally {
<span class="nc" id="L2996">            lock.unlock();</span>
<span class="nc" id="L2997">        }</span>
    }

    /**
     * Returns a transaction object given its hash, if it exists in this wallet, or null otherwise.
     */
    @Nullable
    public Transaction getTransaction(Sha256Hash hash) {
<span class="fc" id="L3005">        lock.lock();</span>
        try {
<span class="fc" id="L3007">            return transactions.get(hash);</span>
        } finally {
<span class="pc" id="L3009">            lock.unlock();</span>
<span class="nc" id="L3010">        }</span>
    }

    /** {@inheritDoc} */
    @Override
    public Map&lt;Sha256Hash, Transaction&gt; getTransactionPool(Pool pool) {
<span class="fc" id="L3016">        lock.lock();</span>
        try {
<span class="pc bpc" id="L3018" title="2 of 5 branches missed.">            switch (pool) {</span>
                case UNSPENT:
<span class="fc" id="L3020">                    return unspent;</span>
                //case INSTANTX_LOCKED:
                case SPENT:
<span class="fc" id="L3023">                    return spent;</span>
                //case INSTANTX_PENDING:
                case PENDING:
<span class="fc" id="L3026">                    return pending;</span>
                case DEAD:
<span class="nc" id="L3028">                    return dead;</span>
                default:
<span class="nc" id="L3030">                    throw new RuntimeException(&quot;Unknown wallet transaction type &quot; + pool);</span>
            }
        } finally {
<span class="pc" id="L3033">            lock.unlock();</span>
<span class="nc" id="L3034">        }</span>
    }

    /**
     * Prepares the wallet for a blockchain replay. Removes all transactions (as they would get in the way of the
     * replay) and makes the wallet think it has never seen a block. {@link WalletEventListener#onWalletChanged} will
     * be fired.
     */
    public void reset() {
<span class="nc" id="L3043">        lock.lock();</span>
        try {
<span class="nc" id="L3045">            clearTransactions();</span>
<span class="nc" id="L3046">            lastBlockSeenHash = null;</span>
<span class="nc" id="L3047">            lastBlockSeenHeight = -1; // Magic value for 'never'.</span>
<span class="nc" id="L3048">            lastBlockSeenTimeSecs = 0;</span>
<span class="nc" id="L3049">            saveLater();</span>
<span class="nc" id="L3050">            maybeQueueOnWalletChanged();</span>
        } finally {
<span class="nc" id="L3052">            lock.unlock();</span>
<span class="nc" id="L3053">        }</span>
<span class="nc" id="L3054">    }</span>

    /**
     * Deletes transactions which appeared above the given block height from the wallet, but does not touch the keys.
     * This is useful if you have some keys and wish to replay the block chain into the wallet in order to pick them up.
     * Triggers auto saving.
     */
    public void clearTransactions(int fromHeight) {
<span class="nc" id="L3062">        lock.lock();</span>
        try {
<span class="nc bnc" id="L3064" title="All 2 branches missed.">            if (fromHeight == 0) {</span>
<span class="nc" id="L3065">                clearTransactions();</span>
<span class="nc" id="L3066">                saveLater();</span>
            } else {
<span class="nc" id="L3068">                throw new UnsupportedOperationException();</span>
            }
        } finally {
<span class="nc" id="L3071">            lock.unlock();</span>
<span class="nc" id="L3072">        }</span>
<span class="nc" id="L3073">    }</span>

    private void clearTransactions() {
<span class="nc" id="L3076">        unspent.clear();</span>
<span class="nc" id="L3077">        spent.clear();</span>
<span class="nc" id="L3078">        pending.clear();</span>
<span class="nc" id="L3079">        dead.clear();</span>
<span class="nc" id="L3080">        transactions.clear();</span>
<span class="nc" id="L3081">        myUnspents.clear();</span>
<span class="nc" id="L3082">    }</span>

    /**
     * Returns all the outputs that match addresses or scripts added via {@link #addWatchedAddress(Address)} or
     * {@link #addWatchedScripts(java.util.List)}.
     * @param excludeImmatureCoinbases Whether to ignore outputs that are unspendable due to being immature.
     */
    public List&lt;TransactionOutput&gt; getWatchedOutputs(boolean excludeImmatureCoinbases) {
<span class="nc" id="L3090">        lock.lock();</span>
<span class="nc" id="L3091">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L3093">            LinkedList&lt;TransactionOutput&gt; candidates = Lists.newLinkedList();</span>
<span class="nc bnc" id="L3094" title="All 2 branches missed.">            for (Transaction tx : Iterables.concat(unspent.values(), pending.values())) {</span>
<span class="nc bnc" id="L3095" title="All 4 branches missed.">                if (excludeImmatureCoinbases &amp;&amp; !tx.isMature()) continue;</span>
<span class="nc bnc" id="L3096" title="All 2 branches missed.">                for (TransactionOutput output : tx.getOutputs()) {</span>
<span class="nc bnc" id="L3097" title="All 2 branches missed.">                    if (!output.isAvailableForSpending()) continue;</span>
                    try {
<span class="nc" id="L3099">                        Script scriptPubKey = output.getScriptPubKey();</span>
<span class="nc bnc" id="L3100" title="All 2 branches missed.">                        if (!watchedScripts.contains(scriptPubKey)) continue;</span>
<span class="nc" id="L3101">                        candidates.add(output);</span>
<span class="nc" id="L3102">                    } catch (ScriptException e) {</span>
                        // Ignore
<span class="nc" id="L3104">                    }</span>
<span class="nc" id="L3105">                }</span>
<span class="nc" id="L3106">            }</span>
<span class="nc" id="L3107">            return candidates;</span>
        } finally {
<span class="nc" id="L3109">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L3110">            lock.unlock();</span>
<span class="nc" id="L3111">        }</span>
    }

    /**
     * Clean up the wallet. Currently, it only removes risky pending transaction from the wallet and only if their
     * outputs have not been spent.
     */
    public void cleanup() {
<span class="nc" id="L3119">        lock.lock();</span>
        try {
<span class="nc" id="L3121">            boolean dirty = false;</span>
<span class="nc bnc" id="L3122" title="All 2 branches missed.">            for (Iterator&lt;Transaction&gt; i = pending.values().iterator(); i.hasNext();) {</span>
<span class="nc" id="L3123">                Transaction tx = i.next();</span>
<span class="nc bnc" id="L3124" title="All 4 branches missed.">                if (isTransactionRisky(tx, null) &amp;&amp; !acceptRiskyTransactions) {</span>
<span class="nc" id="L3125">                    log.debug(&quot;Found risky transaction {} in wallet during cleanup.&quot;, tx.getHashAsString());</span>
<span class="nc bnc" id="L3126" title="All 2 branches missed.">                    if (!tx.isAnyOutputSpent()) {</span>
                        // Sync myUnspents with the change.
<span class="nc bnc" id="L3128" title="All 2 branches missed.">                        for (TransactionInput input : tx.getInputs()) {</span>
<span class="nc" id="L3129">                            TransactionOutput output = input.getConnectedOutput();</span>
<span class="nc bnc" id="L3130" title="All 2 branches missed.">                            if (output == null) continue;</span>
<span class="nc bnc" id="L3131" title="All 2 branches missed.">                            if (output.isMineOrWatched(this))</span>
<span class="nc" id="L3132">                                checkState(myUnspents.add(output));</span>
<span class="nc" id="L3133">                            input.disconnect();</span>
<span class="nc" id="L3134">                        }</span>
<span class="nc bnc" id="L3135" title="All 2 branches missed.">                        for (TransactionOutput output : tx.getOutputs())</span>
<span class="nc" id="L3136">                            myUnspents.remove(output);</span>

<span class="nc" id="L3138">                        i.remove();</span>
<span class="nc" id="L3139">                        transactions.remove(tx.getHash());</span>
<span class="nc" id="L3140">                        dirty = true;</span>
<span class="nc" id="L3141">                        log.info(&quot;Removed transaction {} from pending pool during cleanup.&quot;, tx.getHashAsString());</span>
                    } else {
<span class="nc" id="L3143">                        log.info(</span>
                                &quot;Cannot remove transaction {} from pending pool during cleanup, as it's already spent partially.&quot;,
<span class="nc" id="L3145">                                tx.getHashAsString());</span>
                    }
                }
<span class="nc" id="L3148">            }</span>
<span class="nc bnc" id="L3149" title="All 2 branches missed.">            if (dirty) {</span>
<span class="nc" id="L3150">                isConsistentOrThrow();</span>
<span class="nc" id="L3151">                saveLater();</span>
<span class="nc bnc" id="L3152" title="All 2 branches missed.">                if (log.isInfoEnabled())</span>
<span class="nc" id="L3153">                    log.info(&quot;Estimated balance is now: {}&quot;, getBalance(BalanceType.ESTIMATED).toFriendlyString());</span>
            }
        } finally {
<span class="nc" id="L3156">            lock.unlock();</span>
<span class="nc" id="L3157">        }</span>
<span class="nc" id="L3158">    }</span>

    EnumSet&lt;Pool&gt; getContainingPools(Transaction tx) {
<span class="nc" id="L3161">        lock.lock();</span>
        try {
<span class="nc" id="L3163">            EnumSet&lt;Pool&gt; result = EnumSet.noneOf(Pool.class);</span>
<span class="nc" id="L3164">            Sha256Hash txHash = tx.getHash();</span>
<span class="nc bnc" id="L3165" title="All 2 branches missed.">            if (unspent.containsKey(txHash)) {</span>
<span class="nc" id="L3166">                result.add(Pool.UNSPENT);</span>
            }
<span class="nc bnc" id="L3168" title="All 2 branches missed.">            if (spent.containsKey(txHash)) {</span>
<span class="nc" id="L3169">                result.add(Pool.SPENT);</span>
            }
<span class="nc bnc" id="L3171" title="All 2 branches missed.">            if (pending.containsKey(txHash)) {</span>
<span class="nc" id="L3172">                result.add(Pool.PENDING);</span>
            }
<span class="nc bnc" id="L3174" title="All 2 branches missed.">            if (dead.containsKey(txHash)) {</span>
<span class="nc" id="L3175">                result.add(Pool.DEAD);</span>
            }
<span class="nc" id="L3177">            return result;</span>
        } finally {
<span class="nc" id="L3179">            lock.unlock();</span>
<span class="nc" id="L3180">        }</span>
    }

    @VisibleForTesting
    public int getPoolSize(WalletTransaction.Pool pool) {
<span class="nc" id="L3185">        lock.lock();</span>
        try {
<span class="nc bnc" id="L3187" title="All 5 branches missed.">            switch (pool) {</span>
                case UNSPENT:
<span class="nc" id="L3189">                    return unspent.size();</span>
                case SPENT:
<span class="nc" id="L3191">                    return spent.size();</span>
                case PENDING:
<span class="nc" id="L3193">                    return pending.size();</span>
                case DEAD:
<span class="nc" id="L3195">                    return dead.size();</span>
            }
<span class="nc" id="L3197">            throw new RuntimeException(&quot;Unreachable&quot;);</span>
        } finally {
<span class="nc" id="L3199">            lock.unlock();</span>
<span class="nc" id="L3200">        }</span>
    }

    @VisibleForTesting
    public boolean poolContainsTxHash(final WalletTransaction.Pool pool, final Sha256Hash txHash) {
<span class="fc" id="L3205">        lock.lock();</span>
        try {
<span class="pc bpc" id="L3207" title="1 of 5 branches missed.">            switch (pool) {</span>
                case UNSPENT:
<span class="fc" id="L3209">                    return unspent.containsKey(txHash);</span>
                case SPENT:
<span class="fc" id="L3211">                    return spent.containsKey(txHash);</span>
                case PENDING:
<span class="fc" id="L3213">                    return pending.containsKey(txHash);</span>
                case DEAD:
<span class="fc" id="L3215">                    return dead.containsKey(txHash);</span>
            }
<span class="nc" id="L3217">            throw new RuntimeException(&quot;Unreachable&quot;);</span>
        } finally {
<span class="pc" id="L3219">            lock.unlock();</span>
<span class="nc" id="L3220">        }</span>
    }

    /** Returns a copy of the internal unspent outputs list */
    public List&lt;TransactionOutput&gt; getUnspents() {
<span class="nc" id="L3225">        lock.lock();</span>
        try {
<span class="nc" id="L3227">            return new ArrayList&lt;TransactionOutput&gt;(myUnspents);</span>
        } finally {
<span class="nc" id="L3229">            lock.unlock();</span>
<span class="nc" id="L3230">        }</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L3235">        return toString(false, true, true, null);</span>
    }


    /**
     * Formats the wallet as a human readable piece of text. Intended for debugging, the format is not meant to be
     * stable or human readable.
     * @param includePrivateKeys Whether raw private key data should be included.
     * @param includeTransactions Whether to print transaction data.
     * @param includeExtensions Whether to print extension data.
     * @param chain If set, will be used to estimate lock times for block timelocked transactions.
     */
    public String toString(boolean includePrivateKeys, boolean includeTransactions, boolean includeExtensions,
                           @Nullable AbstractBlockChain chain) {
<span class="nc" id="L3249">        lock.lock();</span>
<span class="nc" id="L3250">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L3252">            StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L3253">            Coin estimatedBalance = getBalance(BalanceType.ESTIMATED);</span>
<span class="nc" id="L3254">            Coin availableBalance = getBalance(BalanceType.AVAILABLE_SPENDABLE);</span>
<span class="nc" id="L3255">            builder.append(&quot;Wallet containing &quot;).append(estimatedBalance.toFriendlyString()).append(&quot; (spendable: &quot;)</span>
<span class="nc" id="L3256">                    .append(availableBalance.toFriendlyString()).append(&quot;) in:\n&quot;);</span>
<span class="nc" id="L3257">            builder.append(&quot;  &quot;).append(pending.size()).append(&quot; pending transactions\n&quot;);</span>
<span class="nc" id="L3258">            builder.append(&quot;  &quot;).append(unspent.size()).append(&quot; unspent transactions\n&quot;);</span>
<span class="nc" id="L3259">            builder.append(&quot;  &quot;).append(spent.size()).append(&quot; spent transactions\n&quot;);</span>
<span class="nc" id="L3260">            builder.append(&quot;  &quot;).append(dead.size()).append(&quot; dead transactions\n&quot;);</span>
<span class="nc" id="L3261">            final Date lastBlockSeenTime = getLastBlockSeenTime();</span>
<span class="nc bnc" id="L3262" title="All 2 branches missed.">            builder.append(&quot;Last seen best block: &quot;).append(getLastBlockSeenHeight()).append(&quot; (&quot;)</span>
<span class="nc" id="L3263">                    .append(lastBlockSeenTime == null ? &quot;time unknown&quot; : Utils.dateTimeFormat(lastBlockSeenTime))</span>
<span class="nc" id="L3264">                    .append(&quot;): &quot;).append(getLastBlockSeenHash()).append('\n');</span>
<span class="nc" id="L3265">            final KeyCrypter crypter = keyChainGroup.getKeyCrypter();</span>
<span class="nc bnc" id="L3266" title="All 2 branches missed.">            if (crypter != null)</span>
<span class="nc" id="L3267">                builder.append(&quot;Encryption: &quot;).append(crypter).append('\n');</span>
<span class="nc bnc" id="L3268" title="All 2 branches missed.">            if (isWatching())</span>
<span class="nc" id="L3269">                builder.append(&quot;Wallet is watching.\n&quot;);</span>

            // Do the keys.
<span class="nc" id="L3272">            builder.append(&quot;\nKeys:\n&quot;);</span>
<span class="nc" id="L3273">            builder.append(&quot;Earliest creation time: &quot;).append(Utils.dateTimeFormat(getEarliestKeyCreationTime() * 1000))</span>
<span class="nc" id="L3274">                    .append('\n');</span>
<span class="nc" id="L3275">            final Date keyRotationTime = getKeyRotationTime();</span>
<span class="nc bnc" id="L3276" title="All 2 branches missed.">            if (keyRotationTime != null)</span>
<span class="nc" id="L3277">                builder.append(&quot;Key rotation time:      &quot;).append(Utils.dateTimeFormat(keyRotationTime)).append('\n');</span>
<span class="nc" id="L3278">            builder.append(keyChainGroup.toString(includePrivateKeys));</span>

<span class="nc bnc" id="L3280" title="All 2 branches missed.">            if (!watchedScripts.isEmpty()) {</span>
<span class="nc" id="L3281">                builder.append(&quot;\nWatched scripts:\n&quot;);</span>
<span class="nc bnc" id="L3282" title="All 2 branches missed.">                for (Script script : watchedScripts) {</span>
<span class="nc" id="L3283">                    builder.append(&quot;  &quot;).append(script).append(&quot;\n&quot;);</span>
<span class="nc" id="L3284">                }</span>
            }

<span class="nc bnc" id="L3287" title="All 2 branches missed.">            if (includeTransactions) {</span>
                // Print the transactions themselves
<span class="nc bnc" id="L3289" title="All 2 branches missed.">                if (pending.size() &gt; 0) {</span>
<span class="nc" id="L3290">                    builder.append(&quot;\n&gt;&gt;&gt; PENDING:\n&quot;);</span>
<span class="nc" id="L3291">                    toStringHelper(builder, pending, chain, Transaction.SORT_TX_BY_UPDATE_TIME);</span>
                }
<span class="nc bnc" id="L3293" title="All 2 branches missed.">                if (unspent.size() &gt; 0) {</span>
<span class="nc" id="L3294">                    builder.append(&quot;\n&gt;&gt;&gt; UNSPENT:\n&quot;);</span>
<span class="nc" id="L3295">                    toStringHelper(builder, unspent, chain, Transaction.SORT_TX_BY_HEIGHT);</span>
                }
<span class="nc bnc" id="L3297" title="All 2 branches missed.">                if (spent.size() &gt; 0) {</span>
<span class="nc" id="L3298">                    builder.append(&quot;\n&gt;&gt;&gt; SPENT:\n&quot;);</span>
<span class="nc" id="L3299">                    toStringHelper(builder, spent, chain, Transaction.SORT_TX_BY_HEIGHT);</span>
                }
<span class="nc bnc" id="L3301" title="All 2 branches missed.">                if (dead.size() &gt; 0) {</span>
<span class="nc" id="L3302">                    builder.append(&quot;\n&gt;&gt;&gt; DEAD:\n&quot;);</span>
<span class="nc" id="L3303">                    toStringHelper(builder, dead, chain, Transaction.SORT_TX_BY_UPDATE_TIME);</span>
                }
            }
<span class="nc bnc" id="L3306" title="All 4 branches missed.">            if (includeExtensions &amp;&amp; extensions.size() &gt; 0) {</span>
<span class="nc" id="L3307">                builder.append(&quot;\n&gt;&gt;&gt; EXTENSIONS:\n&quot;);</span>
<span class="nc bnc" id="L3308" title="All 2 branches missed.">                for (WalletExtension extension : extensions.values()) {</span>
<span class="nc" id="L3309">                    builder.append(extension).append(&quot;\n\n&quot;);</span>
<span class="nc" id="L3310">                }</span>
            }
<span class="nc" id="L3312">            return builder.toString();</span>
        } finally {
<span class="nc" id="L3314">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L3315">            lock.unlock();</span>
<span class="nc" id="L3316">        }</span>
    }

    private void toStringHelper(StringBuilder builder, Map&lt;Sha256Hash, Transaction&gt; transactionMap,
                                @Nullable AbstractBlockChain chain, @Nullable Comparator&lt;Transaction&gt; sortOrder) {
<span class="nc" id="L3321">        checkState(lock.isHeldByCurrentThread());</span>

        final Collection&lt;Transaction&gt; txns;
<span class="nc bnc" id="L3324" title="All 2 branches missed.">        if (sortOrder != null) {</span>
<span class="nc" id="L3325">            txns = new TreeSet&lt;Transaction&gt;(sortOrder);</span>
<span class="nc" id="L3326">            txns.addAll(transactionMap.values());</span>
        } else {
<span class="nc" id="L3328">            txns = transactionMap.values();</span>
        }

<span class="nc bnc" id="L3331" title="All 2 branches missed.">        for (Transaction tx : txns) {</span>
            try {
<span class="nc" id="L3333">                builder.append(&quot;Sends &quot;);</span>
<span class="nc" id="L3334">                builder.append(tx.getValueSentFromMe(this).toFriendlyString());</span>
<span class="nc" id="L3335">                builder.append(&quot; and receives &quot;);</span>
<span class="nc" id="L3336">                builder.append(tx.getValueSentToMe(this).toFriendlyString());</span>
<span class="nc" id="L3337">                builder.append(&quot;, total value &quot;);</span>
<span class="nc" id="L3338">                builder.append(tx.getValue(this).toFriendlyString());</span>
<span class="nc" id="L3339">                builder.append(&quot;.\n&quot;);</span>
<span class="nc" id="L3340">            } catch (ScriptException e) {</span>
                // Ignore and don't print this line.
<span class="nc" id="L3342">            }</span>
<span class="nc" id="L3343">            builder.append(tx.toString(chain));</span>
<span class="nc" id="L3344">        }</span>
<span class="nc" id="L3345">    }</span>

    /**
     * Returns an immutable view of the transactions currently waiting for network confirmations.
     */
    public Collection&lt;Transaction&gt; getPendingTransactions() {
<span class="nc" id="L3351">        lock.lock();</span>
        try {
<span class="nc" id="L3353">            return Collections.unmodifiableCollection(pending.values());</span>
        } finally {
<span class="nc" id="L3355">            lock.unlock();</span>
<span class="nc" id="L3356">        }</span>
    }

    /**
     * Returns the earliest creation time of keys or watched scripts in this wallet, in seconds since the epoch, ie the min
     * of {@link site.mtnsj.core.ECKey#getCreationTimeSeconds()}. This can return zero if at least one key does
     * not have that data (was created before key timestamping was implemented). &lt;p&gt;
     *
     * This method is most often used in conjunction with {@link PeerGroup#setFastCatchupTimeSecs(long)} in order to
     * optimize chain download for new users of wallet apps. Backwards compatibility notice: if you get zero from this
     * method, you can instead use the time of the first release of your software, as it's guaranteed no users will
     * have wallets pre-dating this time. &lt;p&gt;
     *
     * If there are no keys in the wallet, the current time is returned.
     */
    @Override
    public long getEarliestKeyCreationTime() {
<span class="nc" id="L3373">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L3375">            long earliestTime = keyChainGroup.getEarliestKeyCreationTime();</span>
<span class="nc bnc" id="L3376" title="All 2 branches missed.">            for (Script script : watchedScripts)</span>
<span class="nc" id="L3377">                earliestTime = Math.min(script.getCreationTimeSeconds(), earliestTime);</span>
<span class="nc bnc" id="L3378" title="All 2 branches missed.">            if (earliestTime == Long.MAX_VALUE)</span>
<span class="nc" id="L3379">                return Utils.currentTimeSeconds();</span>
<span class="nc" id="L3380">            return earliestTime;</span>
        } finally {
<span class="nc" id="L3382">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L3383">        }</span>
    }

    /** Returns the hash of the last seen best-chain block, or null if the wallet is too old to store this data. */
    @Nullable
    public Sha256Hash getLastBlockSeenHash() {
<span class="fc" id="L3389">        lock.lock();</span>
        try {
<span class="fc" id="L3391">            return lastBlockSeenHash;</span>
        } finally {
<span class="pc" id="L3393">            lock.unlock();</span>
<span class="nc" id="L3394">        }</span>
    }

    public void setLastBlockSeenHash(@Nullable Sha256Hash lastBlockSeenHash) {
<span class="fc" id="L3398">        lock.lock();</span>
        try {
<span class="fc" id="L3400">            this.lastBlockSeenHash = lastBlockSeenHash;</span>
        } finally {
<span class="pc" id="L3402">            lock.unlock();</span>
<span class="pc" id="L3403">        }</span>
<span class="fc" id="L3404">    }</span>

    public void setLastBlockSeenHeight(int lastBlockSeenHeight) {
<span class="fc" id="L3407">        lock.lock();</span>
        try {
<span class="fc" id="L3409">            this.lastBlockSeenHeight = lastBlockSeenHeight;</span>
        } finally {
<span class="pc" id="L3411">            lock.unlock();</span>
<span class="pc" id="L3412">        }</span>
<span class="fc" id="L3413">    }</span>

    public void setLastBlockSeenTimeSecs(long timeSecs) {
<span class="fc" id="L3416">        lock.lock();</span>
        try {
<span class="fc" id="L3418">            lastBlockSeenTimeSecs = timeSecs;</span>
        } finally {
<span class="pc" id="L3420">            lock.unlock();</span>
<span class="pc" id="L3421">        }</span>
<span class="fc" id="L3422">    }</span>

    /**
     * Returns the UNIX time in seconds since the epoch extracted from the last best seen block header. This timestamp
     * is &lt;b&gt;not&lt;/b&gt; the local time at which the block was first observed by this application but rather what the block
     * (i.e. miner) self declares. It is allowed to have some significant drift from the real time at which the block
     * was found, although most miners do use accurate times. If this wallet is old and does not have a recorded
     * time then this method returns zero.
     */
    public long getLastBlockSeenTimeSecs() {
<span class="fc" id="L3432">        lock.lock();</span>
        try {
<span class="fc" id="L3434">            return lastBlockSeenTimeSecs;</span>
        } finally {
<span class="pc" id="L3436">            lock.unlock();</span>
<span class="nc" id="L3437">        }</span>
    }

    /**
     * Returns a {@link Date} representing the time extracted from the last best seen block header. This timestamp
     * is &lt;b&gt;not&lt;/b&gt; the local time at which the block was first observed by this application but rather what the block
     * (i.e. miner) self declares. It is allowed to have some significant drift from the real time at which the block
     * was found, although most miners do use accurate times. If this wallet is old and does not have a recorded
     * time then this method returns null.
     */
    @Nullable
    public Date getLastBlockSeenTime() {
<span class="nc" id="L3449">        final long secs = getLastBlockSeenTimeSecs();</span>
<span class="nc bnc" id="L3450" title="All 2 branches missed.">        if (secs == 0)</span>
<span class="nc" id="L3451">            return null;</span>
        else
<span class="nc" id="L3453">            return new Date(secs * 1000);</span>
    }

    /**
     * Returns the height of the last seen best-chain block. Can be 0 if a wallet is brand new or -1 if the wallet
     * is old and doesn't have that data.
     */
    public int getLastBlockSeenHeight() {
<span class="fc" id="L3461">        lock.lock();</span>
        try {
<span class="fc" id="L3463">            return lastBlockSeenHeight;</span>
        } finally {
<span class="pc" id="L3465">            lock.unlock();</span>
<span class="nc" id="L3466">        }</span>
    }

    /**
     * Get the version of the Wallet.
     * This is an int you can use to indicate which versions of wallets your code understands,
     * and which come from the future (and hence cannot be safely loaded).
     */
    public int getVersion() {
<span class="fc" id="L3475">        return version;</span>
    }

    /**
     * Set the version number of the wallet. See {@link Wallet#getVersion()}.
     */
    public void setVersion(int version) {
<span class="fc" id="L3482">        this.version = version;</span>
<span class="fc" id="L3483">    }</span>

    /**
     * Set the description of the wallet.
     * This is a Unicode encoding string typically entered by the user as descriptive text for the wallet.
     */
    public void setDescription(String description) {
<span class="nc" id="L3490">        this.description = description;</span>
<span class="nc" id="L3491">    }</span>

    /**
     * Get the description of the wallet. See {@link Wallet#setDescription(String))}
     */
    public String getDescription() {
<span class="fc" id="L3497">        return description;</span>
    }

    //endregion

    /******************************************************************************************************************/

    //region Balance and balance futures

    /**
     * &lt;p&gt;It's possible to calculate a wallets balance from multiple points of view. This enum selects which
     * {@link #getBalance(BalanceType)} should use.&lt;/p&gt;
     *
     * &lt;p&gt;Consider a real-world example: you buy a snack costing $5 but you only have a $10 bill. At the start you have
     * $10 viewed from every possible angle. After you order the snack you hand over your $10 bill. From the
     * perspective of your wallet you have zero dollars (AVAILABLE). But you know in a few seconds the shopkeeper
     * will give you back $5 change so most people in practice would say they have $5 (ESTIMATED).&lt;/p&gt;
     *
     * &lt;p&gt;The fact that the wallet can track transactions which are not spendable by itself (&quot;watching wallets&quot;) adds
     * another type of balance to the mix. Although the wallet won't do this by default, advanced use cases that
     * override the relevancy checks can end up with a mix of spendable and unspendable transactions.&lt;/p&gt;
     */
<span class="pc" id="L3519">    public enum BalanceType {</span>
        /**
         * Balance calculated assuming all pending transactions are in fact included into the best chain by miners.
         * This includes the value of immature coinbase transactions.
         */
<span class="fc" id="L3524">        ESTIMATED,</span>

        /**
         * Balance that could be safely used to create new spends, if we had all the needed private keys. This is
         * whatever the default coin selector would make available, which by default means transaction outputs with at
         * least 1 confirmation and pending transactions created by our own wallet which have been propagated across
         * the network. Whether we &lt;i&gt;actually&lt;/i&gt; have the private keys or not is irrelevant for this balance type.
         */
<span class="fc" id="L3532">        AVAILABLE,</span>

        /** Same as ESTIMATED but only for outputs we have the private keys for and can sign ourselves. */
<span class="fc" id="L3535">        ESTIMATED_SPENDABLE,</span>
        /** Same as AVAILABLE but only for outputs we have the private keys for and can sign ourselves. */
<span class="fc" id="L3537">        AVAILABLE_SPENDABLE</span>
    }

    /** @deprecated Use {@link #getBalance()} instead as including watched balances is now the default behaviour */
    @Deprecated
    public Coin getWatchedBalance() {
<span class="nc" id="L3543">        return getBalance();</span>
    }

    /** @deprecated Use {@link #getBalance(CoinSelector)} instead as including watched balances is now the default behaviour */
    @Deprecated
    public Coin getWatchedBalance(CoinSelector selector) {
<span class="nc" id="L3549">        return getBalance(selector);</span>
    }

    /**
     * Returns the AVAILABLE balance of this wallet. See {@link BalanceType#AVAILABLE} for details on what this
     * means.
     */
    public Coin getBalance() {
<span class="fc" id="L3557">        return getBalance(BalanceType.AVAILABLE);</span>
    }

    /**
     * Returns the balance of this wallet as calculated by the provided balanceType.
     */
    public Coin getBalance(BalanceType balanceType) {
<span class="fc" id="L3564">        lock.lock();</span>
        try {
<span class="pc bpc" id="L3566" title="1 of 4 branches missed.">            if (balanceType == BalanceType.AVAILABLE || balanceType == BalanceType.AVAILABLE_SPENDABLE) {</span>
<span class="pc bpc" id="L3567" title="1 of 2 branches missed.">                List&lt;TransactionOutput&gt; candidates = calculateAllSpendCandidates(true, balanceType == BalanceType.AVAILABLE_SPENDABLE);</span>
<span class="fc" id="L3568">                CoinSelection selection = coinSelector.select(NetworkParameters.MAX_MONEY, candidates);</span>
<span class="fc" id="L3569">                return selection.valueGathered;</span>
<span class="pc bpc" id="L3570" title="3 of 4 branches missed.">            } else if (balanceType == BalanceType.ESTIMATED || balanceType == BalanceType.ESTIMATED_SPENDABLE) {</span>
<span class="pc bpc" id="L3571" title="1 of 2 branches missed.">                List&lt;TransactionOutput&gt; all = calculateAllSpendCandidates(false, balanceType == BalanceType.ESTIMATED_SPENDABLE);</span>
<span class="fc" id="L3572">                Coin value = Coin.ZERO;</span>
<span class="fc bfc" id="L3573" title="All 2 branches covered.">                for (TransactionOutput out : all) value = value.add(out.getValue());</span>
<span class="fc" id="L3574">                return value;</span>
            } else {
<span class="nc" id="L3576">                throw new AssertionError(&quot;Unknown balance type&quot;);  // Unreachable.</span>
            }
        } finally {
<span class="pc" id="L3579">            lock.unlock();</span>
<span class="nc" id="L3580">        }</span>
    }

    /**
     * Returns the balance that would be considered spendable by the given coin selector, including watched outputs
     * (i.e. balance includes outputs we don't have the private keys for). Just asks it to select as many coins as
     * possible and returns the total.
     */
    public Coin getBalance(CoinSelector selector) {
<span class="nc" id="L3589">        lock.lock();</span>
        try {
<span class="nc" id="L3591">            checkNotNull(selector);</span>
<span class="nc" id="L3592">            List&lt;TransactionOutput&gt; candidates = calculateAllSpendCandidates(true, false);</span>
<span class="nc" id="L3593">            CoinSelection selection = selector.select(params.getMaxMoney(), candidates);</span>
<span class="nc" id="L3594">            return selection.valueGathered;</span>
        } finally {
<span class="nc" id="L3596">            lock.unlock();</span>
<span class="nc" id="L3597">        }</span>
    }

<span class="nc" id="L3600">    private static class BalanceFutureRequest {</span>
        public SettableFuture&lt;Coin&gt; future;
        public Coin value;
        public BalanceType type;
    }
<span class="fc" id="L3605">    @GuardedBy(&quot;lock&quot;) private List&lt;BalanceFutureRequest&gt; balanceFutureRequests = Lists.newLinkedList();</span>

    /**
     * &lt;p&gt;Returns a future that will complete when the balance of the given type has becom equal or larger to the given
     * value. If the wallet already has a large enough balance the future is returned in a pre-completed state. Note
     * that this method is not blocking, if you want to actually wait immediately, you have to call .get() on
     * the result.&lt;/p&gt;
     *
     * &lt;p&gt;Also note that by the time the future completes, the wallet may have changed yet again if something else
     * is going on in parallel, so you should treat the returned balance as advisory and be prepared for sending
     * money to fail! Finally please be aware that any listeners on the future will run either on the calling thread
     * if it completes immediately, or eventually on a background thread if the balance is not yet at the right
     * level. If you do something that means you know the balance should be sufficient to trigger the future,
     * you can use {@link site.mtnsj.utils.Threading#waitForUserCode()} to block until the future had a
     * chance to be updated.&lt;/p&gt;
     */
    public ListenableFuture&lt;Coin&gt; getBalanceFuture(final Coin value, final BalanceType type) {
<span class="nc" id="L3622">        lock.lock();</span>
        try {
<span class="nc" id="L3624">            final SettableFuture&lt;Coin&gt; future = SettableFuture.create();</span>
<span class="nc" id="L3625">            final Coin current = getBalance(type);</span>
<span class="nc bnc" id="L3626" title="All 2 branches missed.">            if (current.compareTo(value) &gt;= 0) {</span>
                // Already have enough.
<span class="nc" id="L3628">                future.set(current);</span>
            } else {
                // Will be checked later in checkBalanceFutures. We don't just add an event listener for ourselves
                // here so that running getBalanceFuture().get() in the user code thread works - generally we must
                // avoid giving the user back futures that require the user code thread to be free.
<span class="nc" id="L3633">                BalanceFutureRequest req = new BalanceFutureRequest();</span>
<span class="nc" id="L3634">                req.future = future;</span>
<span class="nc" id="L3635">                req.value = value;</span>
<span class="nc" id="L3636">                req.type = type;</span>
<span class="nc" id="L3637">                balanceFutureRequests.add(req);</span>
            }
<span class="nc" id="L3639">            return future;</span>
        } finally {
<span class="nc" id="L3641">            lock.unlock();</span>
<span class="nc" id="L3642">        }</span>
    }

    // Runs any balance futures in the user code thread.
    @SuppressWarnings(&quot;FieldAccessNotGuarded&quot;)
    private void checkBalanceFuturesLocked(@Nullable Coin avail) {
<span class="fc" id="L3648">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L3649">        final ListIterator&lt;BalanceFutureRequest&gt; it = balanceFutureRequests.listIterator();</span>
<span class="pc bpc" id="L3650" title="1 of 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L3651">            final BalanceFutureRequest req = it.next();</span>
<span class="nc" id="L3652">            Coin val = getBalance(req.type);   // This could be slow for lots of futures.</span>
<span class="nc bnc" id="L3653" title="All 2 branches missed.">            if (val.compareTo(req.value) &lt; 0) continue;</span>
            // Found one that's finished.
<span class="nc" id="L3655">            it.remove();</span>
<span class="nc" id="L3656">            final Coin v = val;</span>
            // Don't run any user-provided future listeners with our lock held.
<span class="nc" id="L3658">            Threading.USER_THREAD.execute(new Runnable() {</span>
                @Override public void run() {
<span class="nc" id="L3660">                    req.future.set(v);</span>
<span class="nc" id="L3661">                }</span>
            });
<span class="nc" id="L3663">        }</span>
<span class="fc" id="L3664">    }</span>

    /**
     * Returns the amount of bitcoin ever received via output. &lt;b&gt;This is not the balance!&lt;/b&gt; If an output spends from a
     * transaction whose inputs are also to our wallet, the input amounts are deducted from the outputs contribution, with a minimum of zero
     * contribution. The idea behind this is we avoid double counting money sent to us.
     * @return the total amount of satoshis received, regardless of whether it was spent or not.
     */
    public Coin getTotalReceived() {
<span class="nc" id="L3673">        Coin total = Coin.ZERO;</span>

        // Include outputs to us if they were not just change outputs, ie the inputs to us summed to less
        // than the outputs to us.
<span class="nc bnc" id="L3677" title="All 2 branches missed.">        for (Transaction tx: transactions.values()) {</span>
<span class="nc" id="L3678">            Coin txTotal = Coin.ZERO;</span>
<span class="nc bnc" id="L3679" title="All 2 branches missed.">            for (TransactionOutput output : tx.getOutputs()) {</span>
<span class="nc bnc" id="L3680" title="All 2 branches missed.">                if (output.isMine(this)) {</span>
<span class="nc" id="L3681">                    txTotal = txTotal.add(output.getValue());</span>
                }
<span class="nc" id="L3683">            }</span>
<span class="nc bnc" id="L3684" title="All 2 branches missed.">            for (TransactionInput in : tx.getInputs()) {</span>
<span class="nc" id="L3685">                TransactionOutput prevOut = in.getConnectedOutput();</span>
<span class="nc bnc" id="L3686" title="All 4 branches missed.">                if (prevOut != null &amp;&amp; prevOut.isMine(this)) {</span>
<span class="nc" id="L3687">                    txTotal = txTotal.subtract(prevOut.getValue());</span>
                }
<span class="nc" id="L3689">            }</span>
<span class="nc bnc" id="L3690" title="All 2 branches missed.">            if (txTotal.isPositive()) {</span>
<span class="nc" id="L3691">                total = total.add(txTotal);</span>
            }
<span class="nc" id="L3693">        }</span>
<span class="nc" id="L3694">        return total;</span>
    }

    /**
     * Returns the amount of bitcoin ever sent via output. If an output is sent to our own wallet, because of change or
     * rotating keys or whatever, we do not count it. If the wallet was
     * involved in a shared transaction, i.e. there is some input to the transaction that we don't have the key for, then
     * we multiply the sum of the output values by the proportion of satoshi coming in to our inputs. Essentially we treat
     * inputs as pooling into the transaction, becoming fungible and being equally distributed to all outputs.
     * @return the total amount of satoshis sent by us
     */
    public Coin getTotalSent() {
<span class="nc" id="L3706">        Coin total = Coin.ZERO;</span>

<span class="nc bnc" id="L3708" title="All 2 branches missed.">        for (Transaction tx: transactions.values()) {</span>
            // Count spent outputs to only if they were not to us. This means we don't count change outputs.
<span class="nc" id="L3710">            Coin txOutputTotal = Coin.ZERO;</span>
<span class="nc bnc" id="L3711" title="All 2 branches missed.">            for (TransactionOutput out : tx.getOutputs()) {</span>
<span class="nc bnc" id="L3712" title="All 2 branches missed.">                if (out.isMine(this) == false) {</span>
<span class="nc" id="L3713">                    txOutputTotal = txOutputTotal.add(out.getValue());</span>
                }
<span class="nc" id="L3715">            }</span>

            // Count the input values to us
<span class="nc" id="L3718">            Coin txOwnedInputsTotal = Coin.ZERO;</span>
<span class="nc bnc" id="L3719" title="All 2 branches missed.">            for (TransactionInput in : tx.getInputs()) {</span>
<span class="nc" id="L3720">                TransactionOutput prevOut = in.getConnectedOutput();</span>
<span class="nc bnc" id="L3721" title="All 4 branches missed.">                if (prevOut != null &amp;&amp; prevOut.isMine(this)) {</span>
<span class="nc" id="L3722">                    txOwnedInputsTotal = txOwnedInputsTotal.add(prevOut.getValue());</span>
                }
<span class="nc" id="L3724">            }</span>

            // If there is an input that isn't from us, i.e. this is a shared transaction
<span class="nc" id="L3727">            Coin txInputsTotal = tx.getInputSum();</span>
<span class="nc bnc" id="L3728" title="All 2 branches missed.">            if (txOwnedInputsTotal != txInputsTotal) {</span>

                // multiply our output total by the appropriate proportion to account for the inputs that we don't own
<span class="nc" id="L3731">                BigInteger txOutputTotalNum = new BigInteger(txOutputTotal.toString());</span>
<span class="nc" id="L3732">                txOutputTotalNum = txOutputTotalNum.multiply(new BigInteger(txOwnedInputsTotal.toString()));</span>
<span class="nc" id="L3733">                txOutputTotalNum = txOutputTotalNum.divide(new BigInteger(txInputsTotal.toString()));</span>
<span class="nc" id="L3734">                txOutputTotal = Coin.valueOf(txOutputTotalNum.longValue());</span>
            }
<span class="nc" id="L3736">            total = total.add(txOutputTotal);</span>

<span class="nc" id="L3738">        }</span>
<span class="nc" id="L3739">        return total;</span>
    }

    //endregion

    /******************************************************************************************************************/

    //region Creating and sending transactions

    /** A SendResult is returned to you as part of sending coins to a recipient. */
<span class="nc" id="L3749">    public static class SendResult {</span>
        /** The Bitcoin transaction message that moves the money. */
        public Transaction tx;
        /** A future that will complete once the tx message has been successfully broadcast to the network. This is just the result of calling broadcast.future() */
        public ListenableFuture&lt;Transaction&gt; broadcastComplete;
        /** The broadcast object returned by the linked TransactionBroadcaster */
        public TransactionBroadcast broadcast;
    }

    /**
     * Enumerates possible resolutions for missing signatures.
     */
<span class="pc" id="L3761">    public enum MissingSigsMode {</span>
        /** Input script will have OP_0 instead of missing signatures */
<span class="fc" id="L3763">        USE_OP_ZERO,</span>
        /**
         * Missing signatures will be replaced by dummy sigs. This is useful when you'd like to know the fee for
         * a transaction without knowing the user's password, as fee depends on size.
         */
<span class="fc" id="L3768">        USE_DUMMY_SIG,</span>
        /**
         * If signature is missing, {@link site.mtnsj.signers.TransactionSigner.MissingSignatureException}
         * will be thrown for P2SH and {@link ECKey.MissingPrivateKeyException} for other tx types.
         */
<span class="fc" id="L3773">        THROW</span>
    }

    /**
     * &lt;p&gt;Statelessly creates a transaction that sends the given value to address. The change is sent to
     * {@link Wallet#currentChangeAddress()}, so you must have added at least one key.&lt;/p&gt;
     *
     * &lt;p&gt;If you just want to send money quickly, you probably want
     * {@link Wallet#sendCoins(TransactionBroadcaster, Address, Coin)} instead. That will create the sending
     * transaction, commit to the wallet and broadcast it to the network all in one go. This method is lower level
     * and lets you see the proposed transaction before anything is done with it.&lt;/p&gt;
     *
     * &lt;p&gt;This is a helper method that is equivalent to using {@link SendRequest#to(Address, Coin)}
     * followed by {@link Wallet#completeTx(Wallet.SendRequest)} and returning the requests transaction object.
     * Note that this means a fee may be automatically added if required, if you want more control over the process,
     * just do those two steps yourself.&lt;/p&gt;
     *
     * &lt;p&gt;IMPORTANT: This method does NOT update the wallet. If you call createSend again you may get two transactions
     * that spend the same coins. You have to call {@link Wallet#commitTx(Transaction)} on the created transaction to
     * prevent this, but that should only occur once the transaction has been accepted by the network. This implies
     * you cannot have more than one outstanding sending tx at once.&lt;/p&gt;
     *
     * &lt;p&gt;You MUST ensure that the value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction
     * will almost certainly be rejected by the network as dust.&lt;/p&gt;
     *
     * @param address The Bitcoin address to send the money to.
     * @param value How much currency to send.
     * @return either the created Transaction or null if there are insufficient coins.
     * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     * @throws DustySendRequested if the resultant transaction would violate the dust rules.
     * @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     * @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     * @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     */
    public Transaction createSend(Address address, Coin value) throws InsufficientMoneyException {
<span class="fc" id="L3808">        SendRequest req = SendRequest.to(address, value);</span>
<span class="pc bpc" id="L3809" title="1 of 2 branches missed.">        if (params.getId().equals(NetworkParameters.ID_UNITTESTNET))</span>
<span class="fc" id="L3810">            req.shuffleOutputs = false;</span>
<span class="fc" id="L3811">        completeTx(req);</span>
<span class="fc" id="L3812">        return req.tx;</span>
    }

    /**
     * Sends coins to the given address but does not broadcast the resulting pending transaction. It is still stored
     * in the wallet, so when the wallet is added to a {@link PeerGroup} or {@link Peer} the transaction will be
     * announced to the network. The given {@link SendRequest} is completed first using
     * {@link Wallet#completeTx(Wallet.SendRequest)} to make it valid.
     *
     * @return the Transaction that was created
     * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     * @throws IllegalArgumentException if you try and complete the same SendRequest twice
     * @throws DustySendRequested if the resultant transaction would violate the dust rules.
     * @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     * @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     * @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     */
    public Transaction sendCoinsOffline(SendRequest request) throws InsufficientMoneyException {
<span class="nc" id="L3830">        lock.lock();</span>
        try {
<span class="nc" id="L3832">            completeTx(request);</span>
<span class="nc" id="L3833">            commitTx(request.tx);</span>
<span class="nc" id="L3834">            return request.tx;</span>
        } finally {
<span class="nc" id="L3836">            lock.unlock();</span>
<span class="nc" id="L3837">        }</span>
    }

    /**
     * &lt;p&gt;Sends coins to the given address, via the given {@link PeerGroup}. Change is returned to
     * {@link Wallet#currentChangeAddress()}. Note that a fee may be automatically added if one may be required for the
     * transaction to be confirmed.&lt;/p&gt;
     *
     * &lt;p&gt;The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     * is complete. Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     * the socket. Otherwise when the transaction is written out and we heard it back from a different peer.&lt;/p&gt;
     *
     * &lt;p&gt;Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     * successfully broadcast. This means that even if the network hasn't heard about your transaction you won't be
     * able to spend those same coins again.&lt;/p&gt;
     *
     * &lt;p&gt;You MUST ensure that value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction will
     * almost certainly be rejected by the network as dust.&lt;/p&gt;
     *
     * @param broadcaster a {@link TransactionBroadcaster} to use to send the transactions out.
     * @param to Which address to send coins to.
     * @param value How much value to send.
     * @return An object containing the transaction that was created, and a future for the broadcast of it.
     * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     * @throws DustySendRequested if the resultant transaction would violate the dust rules.
     * @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     * @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     * @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     */
    public SendResult sendCoins(TransactionBroadcaster broadcaster, Address to, Coin value) throws InsufficientMoneyException {
<span class="nc" id="L3867">        SendRequest request = SendRequest.to(to, value);</span>
<span class="nc" id="L3868">        return sendCoins(broadcaster, request);</span>
    }

    /**
     * &lt;p&gt;Sends coins according to the given request, via the given {@link TransactionBroadcaster}.&lt;/p&gt;
     *
     * &lt;p&gt;The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     * is complete. Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     * the socket. Otherwise when the transaction is written out and we heard it back from a different peer.&lt;/p&gt;
     *
     * &lt;p&gt;Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     * successfully broadcast. This means that even if the network hasn't heard about your transaction you won't be
     * able to spend those same coins again.&lt;/p&gt;
     *
     * @param broadcaster the target to use for broadcast.
     * @param request the SendRequest that describes what to do, get one using static methods on SendRequest itself.
     * @return An object containing the transaction that was created, and a future for the broadcast of it.
     * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     * @throws IllegalArgumentException if you try and complete the same SendRequest twice
     * @throws DustySendRequested if the resultant transaction would violate the dust rules.
     * @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     * @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     * @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     */
    public SendResult sendCoins(TransactionBroadcaster broadcaster, SendRequest request) throws InsufficientMoneyException {
        // Should not be locked here, as we're going to call into the broadcaster and that might want to hold its
        // own lock. sendCoinsOffline handles everything that needs to be locked.
<span class="nc bnc" id="L3895" title="All 2 branches missed.">        checkState(!lock.isHeldByCurrentThread());</span>

        // Commit the TX to the wallet immediately so the spent coins won't be reused.
        // TODO: We should probably allow the request to specify tx commit only after the network has accepted it.
<span class="nc" id="L3899">        Transaction tx = sendCoinsOffline(request);</span>
<span class="nc" id="L3900">        SendResult result = new SendResult();</span>
<span class="nc" id="L3901">        result.tx = tx;</span>
        // The tx has been committed to the pending pool by this point (via sendCoinsOffline -&gt; commitTx), so it has
        // a txConfidenceListener registered. Once the tx is broadcast the peers will update the memory pool with the
        // count of seen peers, the memory pool will update the transaction confidence object, that will invoke the
        // txConfidenceListener which will in turn invoke the wallets event listener onTransactionConfidenceChanged
        // method.
<span class="nc" id="L3907">        result.broadcast = broadcaster.broadcastTransaction(tx);</span>
<span class="nc" id="L3908">        result.broadcastComplete = result.broadcast.future();</span>
<span class="nc" id="L3909">        return result;</span>
    }

    /**
     * Satisfies the given {@link SendRequest} using the default transaction broadcaster configured either via
     * {@link PeerGroup#addWallet(Wallet)} or directly with {@link #setTransactionBroadcaster(TransactionBroadcaster)}.
     *
     * @param request the SendRequest that describes what to do, get one using static methods on SendRequest itself.
     * @return An object containing the transaction that was created, and a future for the broadcast of it.
     * @throws IllegalStateException if no transaction broadcaster has been configured.
     * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     * @throws IllegalArgumentException if you try and complete the same SendRequest twice
     * @throws DustySendRequested if the resultant transaction would violate the dust rules.
     * @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     * @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     * @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     */
    public SendResult sendCoins(SendRequest request) throws InsufficientMoneyException {
<span class="nc" id="L3927">        TransactionBroadcaster broadcaster = vTransactionBroadcaster;</span>
<span class="nc bnc" id="L3928" title="All 2 branches missed.">        checkState(broadcaster != null, &quot;No transaction broadcaster is configured&quot;);</span>
<span class="nc" id="L3929">        return sendCoins(broadcaster, request);</span>
    }

    /**
     * Sends coins to the given address, via the given {@link Peer}. Change is returned to {@link Wallet#currentChangeAddress()}.
     * If an exception is thrown by {@link Peer#sendMessage(Message)} the transaction is still committed, so the
     * pending transaction must be broadcast &lt;b&gt;by you&lt;/b&gt; at some other time. Note that a fee may be automatically added
     * if one may be required for the transaction to be confirmed.
     *
     * @return The {@link Transaction} that was created or null if there was insufficient balance to send the coins.
     * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     * @throws IllegalArgumentException if you try and complete the same SendRequest twice
     * @throws DustySendRequested if the resultant transaction would violate the dust rules.
     * @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     * @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     * @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     */
    public Transaction sendCoins(Peer peer, SendRequest request) throws InsufficientMoneyException {
<span class="nc" id="L3947">        Transaction tx = sendCoinsOffline(request);</span>
<span class="nc" id="L3948">        peer.sendMessage(tx);</span>
<span class="nc" id="L3949">        return tx;</span>
    }

    /**
     * Class of exceptions thrown in {@link Wallet#completeTx(SendRequest)}.
     */
<span class="nc" id="L3955">    public static class CompletionException extends RuntimeException {}</span>
    /**
     * Thrown if the resultant transaction would violate the dust rules (an output that's too small to be worthwhile).
     */
<span class="nc" id="L3959">    public static class DustySendRequested extends CompletionException {}</span>
    /**
     * Thrown if there is more than one OP_RETURN output for the resultant transaction.
     */
<span class="nc" id="L3963">    public static class MultipleOpReturnRequested extends CompletionException {}</span>
    /**
     * Thrown when we were trying to empty the wallet, and the total amount of money we were trying to empty after
     * being reduced for the fee was smaller than the min payment. Note that the missing field will be null in this
     * case.
     */
<span class="nc" id="L3969">    public static class CouldNotAdjustDownwards extends CompletionException {}</span>
    /**
     * Thrown if the resultant transaction is too big for Bitcoin to process. Try breaking up the amounts of value.
     */
<span class="nc" id="L3973">    public static class ExceededMaxTransactionSize extends CompletionException {}</span>

    /**
     * Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs
     * according to the instructions in the request. The transaction in the request is modified by this method.
     *
     * @param req a SendRequest that contains the incomplete transaction and details for how to make it valid.
     * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     * @throws IllegalArgumentException if you try and complete the same SendRequest twice
     * @throws DustySendRequested if the resultant transaction would violate the dust rules.
     * @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     * @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     * @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     */
    public void completeTx(SendRequest req) throws InsufficientMoneyException {
<span class="fc" id="L3988">        lock.lock();</span>
        try {
<span class="pc bpc" id="L3990" title="1 of 2 branches missed.">            checkArgument(!req.completed, &quot;Given SendRequest has already been completed.&quot;);</span>
            // Calculate the amount of value we need to import.
<span class="fc" id="L3992">            Coin value = Coin.ZERO;</span>
<span class="fc bfc" id="L3993" title="All 2 branches covered.">            for (TransactionOutput output : req.tx.getOutputs()) {</span>
<span class="fc" id="L3994">                value = value.add(output.getValue());</span>
<span class="fc" id="L3995">            }</span>

<span class="fc" id="L3997">            log.info(&quot;Completing send tx with {} outputs totalling {} (not including fees)&quot;,</span>
<span class="fc" id="L3998">                    req.tx.getOutputs().size(), value.toFriendlyString());</span>

            // If any inputs have already been added, we don't need to get their value from wallet
<span class="fc" id="L4001">            Coin totalInput = Coin.ZERO;</span>
<span class="pc bpc" id="L4002" title="1 of 2 branches missed.">            for (TransactionInput input : req.tx.getInputs())</span>
<span class="nc bnc" id="L4003" title="All 2 branches missed.">                if (input.getConnectedOutput() != null)</span>
<span class="nc" id="L4004">                    totalInput = totalInput.add(input.getConnectedOutput().getValue());</span>
                else
<span class="nc" id="L4006">                    log.warn(&quot;SendRequest transaction already has inputs but we don't know how much they are worth - they will be added to fee.&quot;);</span>
<span class="fc" id="L4007">            value = value.subtract(totalInput);</span>

<span class="fc" id="L4009">            List&lt;TransactionInput&gt; originalInputs = new ArrayList&lt;TransactionInput&gt;(req.tx.getInputs());</span>

            // Check for dusty sends and the OP_RETURN limit.
<span class="pc bpc" id="L4012" title="3 of 4 branches missed.">            if (req.ensureMinRequiredFee &amp;&amp; !req.emptyWallet) { // Min fee checking is handled later for emptyWallet.</span>
<span class="nc" id="L4013">                int opReturnCount = 0;</span>
<span class="nc bnc" id="L4014" title="All 2 branches missed.">                for (TransactionOutput output : req.tx.getOutputs()) {</span>
<span class="nc bnc" id="L4015" title="All 2 branches missed.">                    if (output.isDust())</span>
<span class="nc" id="L4016">                        throw new DustySendRequested();</span>
<span class="nc bnc" id="L4017" title="All 2 branches missed.">                    if (output.getScriptPubKey().isOpReturn())</span>
<span class="nc" id="L4018">                        ++opReturnCount;</span>
<span class="nc" id="L4019">                }</span>
<span class="nc bnc" id="L4020" title="All 2 branches missed.">                if (opReturnCount &gt; 1) // Only 1 OP_RETURN per transaction allowed.</span>
<span class="nc" id="L4021">                    throw new MultipleOpReturnRequested();</span>
            }

            // Calculate a list of ALL potential candidates for spending and then ask a coin selector to provide us
            // with the actual outputs that'll be used to gather the required amount of value. In this way, users
            // can customize coin selection policies. The call below will ignore immature coinbases and outputs
            // we don't have the keys for.
<span class="pc bpc" id="L4028" title="1 of 2 branches missed.">            List&lt;TransactionOutput&gt; candidates = calculateAllSpendCandidates(true, req.missingSigsMode == MissingSigsMode.THROW);</span>

            CoinSelection bestCoinSelection;
<span class="fc" id="L4031">            TransactionOutput bestChangeOutput = null;</span>
<span class="pc bpc" id="L4032" title="1 of 2 branches missed.">            if (!req.emptyWallet) {</span>
                // This can throw InsufficientMoneyException.
<span class="fc" id="L4034">                FeeCalculation feeCalculation = calculateFee(req, value, originalInputs, req.ensureMinRequiredFee, candidates);</span>
<span class="fc" id="L4035">                bestCoinSelection = feeCalculation.bestCoinSelection;</span>
<span class="fc" id="L4036">                bestChangeOutput = feeCalculation.bestChangeOutput;</span>
<span class="fc" id="L4037">            } else {</span>
                // We're being asked to empty the wallet. What this means is ensuring &quot;tx&quot; has only a single output
                // of the total value we can currently spend as determined by the selector, and then subtracting the fee.
<span class="nc bnc" id="L4040" title="All 2 branches missed.">                checkState(req.tx.getOutputs().size() == 1, &quot;Empty wallet TX must have a single output only.&quot;);</span>
<span class="nc bnc" id="L4041" title="All 2 branches missed.">                CoinSelector selector = req.coinSelector == null ? coinSelector : req.coinSelector;</span>
<span class="nc" id="L4042">                bestCoinSelection = selector.select(params.getMaxMoney(), candidates);</span>
<span class="nc" id="L4043">                candidates = null;  // Selector took ownership and might have changed candidates. Don't access again.</span>
<span class="nc" id="L4044">                req.tx.getOutput(0).setValue(bestCoinSelection.valueGathered);</span>
<span class="nc" id="L4045">                log.info(&quot;  emptying {}&quot;, bestCoinSelection.valueGathered.toFriendlyString());</span>
            }

<span class="fc bfc" id="L4048" title="All 2 branches covered.">            for (TransactionOutput output : bestCoinSelection.gathered)</span>
<span class="fc" id="L4049">                req.tx.addInput(output);</span>

<span class="pc bpc" id="L4051" title="1 of 2 branches missed.">            if (req.emptyWallet) {</span>
<span class="nc bnc" id="L4052" title="All 2 branches missed.">                final Coin feePerKb = req.feePerKb == null ? Coin.ZERO : req.feePerKb;</span>
<span class="nc bnc" id="L4053" title="All 2 branches missed.">                if (!adjustOutputDownwardsForFee(req.tx, bestCoinSelection, feePerKb, req.ensureMinRequiredFee, req.useInstantSend))</span>
<span class="nc" id="L4054">                    throw new CouldNotAdjustDownwards();</span>
            }

<span class="fc bfc" id="L4057" title="All 2 branches covered.">            if (bestChangeOutput != null) {</span>
<span class="fc" id="L4058">                req.tx.addOutput(bestChangeOutput);</span>
<span class="fc" id="L4059">                log.info(&quot;  with {} change&quot;, bestChangeOutput.getValue().toFriendlyString());</span>
            }

            // Now shuffle the outputs to obfuscate which is the change.
<span class="pc bpc" id="L4063" title="1 of 2 branches missed.">            if (req.shuffleOutputs)</span>
<span class="nc" id="L4064">                req.tx.shuffleOutputs();</span>

            // Now sign the inputs, thus proving that we are entitled to redeem the connected outputs.
<span class="pc bpc" id="L4067" title="1 of 2 branches missed.">            if (req.signInputs)</span>
<span class="fc" id="L4068">                signTransaction(req);</span>

            // Check size.
<span class="fc" id="L4071">            final int size = req.tx.unsafeBitcoinSerialize().length;</span>
<span class="pc bpc" id="L4072" title="1 of 2 branches missed.">            if (size &gt; Transaction.MAX_STANDARD_TX_SIZE)</span>
<span class="nc" id="L4073">                throw new ExceededMaxTransactionSize();</span>

<span class="fc" id="L4075">            final Coin calculatedFee = req.tx.getFee();</span>
<span class="pc bpc" id="L4076" title="1 of 2 branches missed.">            if (calculatedFee != null)</span>
<span class="fc" id="L4077">                log.info(&quot;  with a fee of {}/kB, {} for {} bytes&quot;,</span>
<span class="fc" id="L4078">                        calculatedFee.multiply(1000).divide(size).toFriendlyString(), calculatedFee.toFriendlyString(),</span>
<span class="fc" id="L4079">                        size);</span>

            // Label the transaction as being self created. We can use this later to spend its change output even before
            // the transaction is confirmed. We deliberately won't bother notifying listeners here as there's not much
            // point - the user isn't interested in a confidence transition they made themselves.
<span class="fc" id="L4084">            req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);</span>
            // Label the transaction as being a user requested payment. This can be used to render GUI wallet
            // transaction lists more appropriately, especially when the wallet starts to generate transactions itself
            // for internal purposes.
<span class="fc" id="L4088">            req.tx.setPurpose(Transaction.Purpose.USER_PAYMENT);</span>
            // Record the exchange rate that was valid when the transaction was completed.
<span class="fc" id="L4090">            req.tx.setExchangeRate(req.exchangeRate);</span>
<span class="fc" id="L4091">            req.tx.setMemo(req.memo);</span>
<span class="fc" id="L4092">            req.completed = true;</span>
<span class="fc" id="L4093">            log.info(&quot;  completed: {}&quot;, req.tx);</span>
        } finally {
<span class="fc" id="L4095">            lock.unlock();</span>
<span class="fc" id="L4096">        }</span>
<span class="fc" id="L4097">    }</span>

    /**
     * &lt;p&gt;Given a send request containing transaction, attempts to sign it's inputs. This method expects transaction
     * to have all necessary inputs connected or they will be ignored.&lt;/p&gt;
     * &lt;p&gt;Actual signing is done by pluggable {@link #signers} and it's not guaranteed that
     * transaction will be complete in the end.&lt;/p&gt;
     */
    public void signTransaction(SendRequest req) {
<span class="fc" id="L4106">        lock.lock();</span>
        try {
<span class="fc" id="L4108">            Transaction tx = req.tx;</span>
<span class="fc" id="L4109">            List&lt;TransactionInput&gt; inputs = tx.getInputs();</span>
<span class="fc" id="L4110">            List&lt;TransactionOutput&gt; outputs = tx.getOutputs();</span>
<span class="pc bpc" id="L4111" title="1 of 2 branches missed.">            checkState(inputs.size() &gt; 0);</span>
<span class="pc bpc" id="L4112" title="1 of 2 branches missed.">            checkState(outputs.size() &gt; 0);</span>

<span class="fc" id="L4114">            KeyBag maybeDecryptingKeyBag = new DecryptingKeyBag(this, req.aesKey);</span>

<span class="fc" id="L4116">            int numInputs = tx.getInputs().size();</span>
<span class="fc bfc" id="L4117" title="All 2 branches covered.">            for (int i = 0; i &lt; numInputs; i++) {</span>
<span class="fc" id="L4118">                TransactionInput txIn = tx.getInput(i);</span>
<span class="pc bpc" id="L4119" title="1 of 2 branches missed.">                if (txIn.getConnectedOutput() == null) {</span>
                    // Missing connected output, assuming already signed.
<span class="nc" id="L4121">                    continue;</span>
                }

                try {
                    // We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                    // we sign missing pieces (to check this would require either assuming any signatures are signing
                    // standard output types or a way to get processed signatures out of script execution)
<span class="nc" id="L4128">                    txIn.getScriptSig().correctlySpends(tx, i, txIn.getConnectedOutput().getScriptPubKey());</span>
<span class="nc" id="L4129">                    log.warn(&quot;Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.&quot;, i);</span>
<span class="nc" id="L4130">                    continue;</span>
<span class="fc" id="L4131">                } catch (ScriptException e) {</span>
<span class="fc" id="L4132">                    log.debug(&quot;Input contained an incorrect signature&quot;, e);</span>
                    // Expected.
                }

<span class="fc" id="L4136">                Script scriptPubKey = txIn.getConnectedOutput().getScriptPubKey();</span>
<span class="fc" id="L4137">                RedeemData redeemData = txIn.getConnectedRedeemData(maybeDecryptingKeyBag);</span>
<span class="fc" id="L4138">                checkNotNull(redeemData, &quot;Transaction exists in wallet that we cannot redeem: %s&quot;, txIn.getOutpoint().getHash());</span>
<span class="fc" id="L4139">                txIn.setScriptSig(scriptPubKey.createEmptyInputScript(redeemData.keys.get(0), redeemData.redeemScript));</span>
            }

<span class="fc" id="L4142">            TransactionSigner.ProposedTransaction proposal = new TransactionSigner.ProposedTransaction(tx);</span>
<span class="fc bfc" id="L4143" title="All 2 branches covered.">            for (TransactionSigner signer : signers) {</span>
<span class="pc bpc" id="L4144" title="1 of 2 branches missed.">                if (!signer.signInputs(proposal, maybeDecryptingKeyBag))</span>
<span class="nc" id="L4145">                    log.info(&quot;{} returned false for the tx&quot;, signer.getClass().getName());</span>
<span class="fc" id="L4146">            }</span>

            // resolve missing sigs if any
<span class="fc" id="L4149">            new MissingSigResolutionSigner(req.missingSigsMode).signInputs(proposal, maybeDecryptingKeyBag);</span>
        } finally {
<span class="pc" id="L4151">            lock.unlock();</span>
<span class="pc" id="L4152">        }</span>
<span class="fc" id="L4153">    }</span>

    /** Reduce the value of the first output of a transaction to pay the given feePerKb as appropriate for its size. */
    private boolean adjustOutputDownwardsForFee(Transaction tx, CoinSelection coinSelection, Coin feePerKb,
            boolean ensureMinRequiredFee, boolean useInstantSend) {
<span class="nc" id="L4158">        final int size = tx.unsafeBitcoinSerialize().length + estimateBytesForSigning(coinSelection);</span>
<span class="nc" id="L4159">        Coin fee = feePerKb.multiply(size).divide(1000);</span>
<span class="nc bnc" id="L4160" title="All 4 branches missed.">        if (ensureMinRequiredFee &amp;&amp; fee.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) &lt; 0)</span>
<span class="nc" id="L4161">            fee = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;</span>
<span class="nc bnc" id="L4162" title="All 2 branches missed.">        if(useInstantSend)</span>
<span class="nc" id="L4163">            fee = TransactionLockRequest.MIN_FEE.multiply(tx.getInputs().size());</span>
<span class="nc" id="L4164">        TransactionOutput output = tx.getOutput(0);</span>
<span class="nc" id="L4165">        output.setValue(output.getValue().subtract(fee));</span>
<span class="nc bnc" id="L4166" title="All 2 branches missed.">        return !output.isDust();</span>
    }

    /**
     * Returns a list of the outputs that can potentially be spent, i.e. that we have the keys for and are unspent
     * according to our knowledge of the block chain.
     */
    public List&lt;TransactionOutput&gt; calculateAllSpendCandidates() {
<span class="nc" id="L4174">        return calculateAllSpendCandidates(true, true);</span>
    }

    /** @deprecated Use {@link #calculateAllSpendCandidates(boolean, boolean)} or the zero-parameter form instead. */
    @Deprecated
    public List&lt;TransactionOutput&gt; calculateAllSpendCandidates(boolean excludeImmatureCoinbases) {
<span class="nc" id="L4180">        return calculateAllSpendCandidates(excludeImmatureCoinbases, true);</span>
    }

    /**
     * Returns a list of all outputs that are being tracked by this wallet either from the {@link UTXOProvider}
     * (in this case the existence or not of private keys is ignored), or the wallets internal storage (the default)
     * taking into account the flags.
     *
     * @param excludeImmatureCoinbases Whether to ignore coinbase outputs that we will be able to spend in future once they mature.
     * @param excludeUnsignable Whether to ignore outputs that we are tracking but don't have the keys to sign for.
     */
    public List&lt;TransactionOutput&gt; calculateAllSpendCandidates(boolean excludeImmatureCoinbases, boolean excludeUnsignable) {
<span class="fc" id="L4192">        lock.lock();</span>
        try {
            List&lt;TransactionOutput&gt; candidates;
<span class="fc bfc" id="L4195" title="All 2 branches covered.">            if (vUTXOProvider == null) {</span>
<span class="fc" id="L4196">                candidates = new ArrayList&lt;TransactionOutput&gt;(myUnspents.size());</span>
<span class="fc bfc" id="L4197" title="All 2 branches covered.">                for (TransactionOutput output : myUnspents) {</span>
<span class="pc bpc" id="L4198" title="1 of 4 branches missed.">                    if (excludeUnsignable &amp;&amp; !canSignFor(output.getScriptPubKey())) continue;</span>
<span class="fc" id="L4199">                    Transaction transaction = checkNotNull(output.getParentTransaction());</span>
<span class="fc bfc" id="L4200" title="All 4 branches covered.">                    if (excludeImmatureCoinbases &amp;&amp; !transaction.isMature())</span>
<span class="fc" id="L4201">                        continue;</span>
<span class="fc" id="L4202">                    candidates.add(output);</span>
<span class="fc" id="L4203">                }</span>
            } else {
<span class="fc" id="L4205">                candidates = calculateAllSpendCandidatesFromUTXOProvider(excludeImmatureCoinbases);</span>
            }
<span class="fc" id="L4207">            return candidates;</span>
        } finally {
<span class="pc" id="L4209">            lock.unlock();</span>
<span class="nc" id="L4210">        }</span>
    }

    /**
     * Returns true if this wallet has at least one of the private keys needed to sign for this scriptPubKey. Returns
     * false if the form of the script is not known or if the script is OP_RETURN.
     */
    public boolean canSignFor(Script script) {
<span class="fc bfc" id="L4218" title="All 2 branches covered.">        if (script.isSentToRawPubKey()) {</span>
<span class="fc" id="L4219">            byte[] pubkey = script.getPubKey();</span>
<span class="fc" id="L4220">            ECKey key = findKeyFromPubKey(pubkey);</span>
<span class="pc bpc" id="L4221" title="3 of 6 branches missed.">            return key != null &amp;&amp; (key.isEncrypted() || key.hasPrivKey());</span>
<span class="pc bpc" id="L4222" title="1 of 2 branches missed.">        } if (script.isPayToScriptHash()) {</span>
<span class="nc" id="L4223">            RedeemData data = findRedeemDataFromScriptHash(script.getPubKeyHash());</span>
<span class="nc bnc" id="L4224" title="All 4 branches missed.">            return data != null &amp;&amp; canSignFor(data.redeemScript);</span>
<span class="pc bpc" id="L4225" title="1 of 2 branches missed.">        } else if (script.isSentToAddress()) {</span>
<span class="fc" id="L4226">            ECKey key = findKeyFromPubHash(script.getPubKeyHash());</span>
<span class="pc bpc" id="L4227" title="3 of 6 branches missed.">            return key != null &amp;&amp; (key.isEncrypted() || key.hasPrivKey());</span>
<span class="nc bnc" id="L4228" title="All 2 branches missed.">        } else if (script.isSentToMultiSig()) {</span>
<span class="nc bnc" id="L4229" title="All 2 branches missed.">            for (ECKey pubkey : script.getPubKeys()) {</span>
<span class="nc" id="L4230">                ECKey key = findKeyFromPubKey(pubkey.getPubKey());</span>
<span class="nc bnc" id="L4231" title="All 6 branches missed.">                if (key != null &amp;&amp; (key.isEncrypted() || key.hasPrivKey()))</span>
<span class="nc" id="L4232">                    return true;</span>
<span class="nc" id="L4233">            }</span>
<span class="nc bnc" id="L4234" title="All 2 branches missed.">        } else if (script.isSentToCLTVPaymentChannel()) {</span>
            // Any script for which we are the recipient or sender counts.
<span class="nc" id="L4236">            byte[] sender = script.getCLTVPaymentChannelSenderPubKey();</span>
<span class="nc" id="L4237">            ECKey senderKey = findKeyFromPubKey(sender);</span>
<span class="nc bnc" id="L4238" title="All 6 branches missed.">            if (senderKey != null &amp;&amp; (senderKey.isEncrypted() || senderKey.hasPrivKey())) {</span>
<span class="nc" id="L4239">                return true;</span>
            }
<span class="nc" id="L4241">            byte[] recipient = script.getCLTVPaymentChannelRecipientPubKey();</span>
<span class="nc" id="L4242">            ECKey recipientKey = findKeyFromPubKey(sender);</span>
<span class="nc bnc" id="L4243" title="All 6 branches missed.">            if (recipientKey != null &amp;&amp; (recipientKey.isEncrypted() || recipientKey.hasPrivKey())) {</span>
<span class="nc" id="L4244">                return true;</span>
            }
<span class="nc" id="L4246">            return false;</span>
        }
<span class="nc" id="L4248">        return false;</span>
    }

    /**
     * Returns the spendable candidates from the {@link UTXOProvider} based on keys that the wallet contains.
     * @return The list of candidates.
     */
    protected LinkedList&lt;TransactionOutput&gt; calculateAllSpendCandidatesFromUTXOProvider(boolean excludeImmatureCoinbases) {
<span class="fc" id="L4256">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L4257">        UTXOProvider utxoProvider = checkNotNull(vUTXOProvider, &quot;No UTXO provider has been set&quot;);</span>
<span class="fc" id="L4258">        LinkedList&lt;TransactionOutput&gt; candidates = Lists.newLinkedList();</span>
        try {
<span class="fc" id="L4260">            int chainHeight = utxoProvider.getChainHeadHeight();</span>
<span class="pc bpc" id="L4261" title="1 of 2 branches missed.">            for (UTXO output : getStoredOutputsFromUTXOProvider()) {</span>
<span class="nc" id="L4262">                boolean coinbase = output.isCoinbase();</span>
<span class="nc" id="L4263">                int depth = chainHeight - output.getHeight() + 1; // the current depth of the output (1 = same as head).</span>
                // Do not try and spend coinbases that were mined too recently, the protocol forbids it.
<span class="nc bnc" id="L4265" title="All 6 branches missed.">                if (!excludeImmatureCoinbases || !coinbase || depth &gt;= params.getSpendableCoinbaseDepth()) {</span>
<span class="nc" id="L4266">                    candidates.add(new FreeStandingTransactionOutput(params, output, chainHeight));</span>
                }
<span class="nc" id="L4268">            }</span>
<span class="nc" id="L4269">        } catch (UTXOProviderException e) {</span>
<span class="nc" id="L4270">            throw new RuntimeException(&quot;UTXO provider error&quot;, e);</span>
<span class="fc" id="L4271">        }</span>
        // We need to handle the pending transactions that we know about.
<span class="pc bpc" id="L4273" title="1 of 2 branches missed.">        for (Transaction tx : pending.values()) {</span>
            // Remove the spent outputs.
<span class="nc bnc" id="L4275" title="All 2 branches missed.">            for (TransactionInput input : tx.getInputs()) {</span>
<span class="nc bnc" id="L4276" title="All 2 branches missed.">                if (input.getConnectedOutput().isMine(this)) {</span>
<span class="nc" id="L4277">                    candidates.remove(input.getConnectedOutput());</span>
                }
<span class="nc" id="L4279">            }</span>
            // Add change outputs. Do not try and spend coinbases that were mined too recently, the protocol forbids it.
<span class="nc bnc" id="L4281" title="All 4 branches missed.">            if (!excludeImmatureCoinbases || tx.isMature()) {</span>
<span class="nc bnc" id="L4282" title="All 2 branches missed.">                for (TransactionOutput output : tx.getOutputs()) {</span>
<span class="nc bnc" id="L4283" title="All 4 branches missed.">                    if (output.isAvailableForSpending() &amp;&amp; output.isMine(this)) {</span>
<span class="nc" id="L4284">                        candidates.add(output);</span>
                    }
<span class="nc" id="L4286">                }</span>
            }
<span class="nc" id="L4288">        }</span>
<span class="fc" id="L4289">        return candidates;</span>
    }

    /**
     * Get all the {@link UTXO}'s from the {@link UTXOProvider} based on keys that the
     * wallet contains.
     * @return The list of stored outputs.
     */
    protected List&lt;UTXO&gt; getStoredOutputsFromUTXOProvider() throws UTXOProviderException {
<span class="fc" id="L4298">        UTXOProvider utxoProvider = checkNotNull(vUTXOProvider, &quot;No UTXO provider has been set&quot;);</span>
<span class="fc" id="L4299">        List&lt;UTXO&gt; candidates = new ArrayList&lt;UTXO&gt;();</span>
<span class="fc" id="L4300">        List&lt;ECKey&gt; keys = getImportedKeys();</span>
<span class="fc" id="L4301">        keys.addAll(getActiveKeyChain().getLeafKeys());</span>
<span class="fc" id="L4302">        List&lt;Address&gt; addresses = new ArrayList&lt;Address&gt;();</span>
<span class="fc bfc" id="L4303" title="All 2 branches covered.">        for (ECKey key : keys) {</span>
<span class="fc" id="L4304">            Address address = new Address(params, key.getPubKeyHash());</span>
<span class="fc" id="L4305">            addresses.add(address);</span>
<span class="fc" id="L4306">        }</span>
<span class="fc" id="L4307">        candidates.addAll(utxoProvider.getOpenTransactionOutputs(addresses));</span>
<span class="fc" id="L4308">        return candidates;</span>
    }

    /** Returns the {@link CoinSelector} object which controls which outputs can be spent by this wallet. */
    public CoinSelector getCoinSelector() {
<span class="nc" id="L4313">        lock.lock();</span>
        try {
<span class="nc" id="L4315">            return coinSelector;</span>
        } finally {
<span class="nc" id="L4317">            lock.unlock();</span>
<span class="nc" id="L4318">        }</span>
    }

    /**
     * A coin selector is responsible for choosing which outputs to spend when creating transactions. The default
     * selector implements a policy of spending transactions that appeared in the best chain and pending transactions
     * that were created by this wallet, but not others. You can override the coin selector for any given send
     * operation by changing {@link SendRequest#coinSelector}.
     */
    public void setCoinSelector(CoinSelector coinSelector) {
<span class="fc" id="L4328">        lock.lock();</span>
        try {
<span class="fc" id="L4330">            this.coinSelector = checkNotNull(coinSelector);</span>
        } finally {
<span class="pc" id="L4332">            lock.unlock();</span>
<span class="pc" id="L4333">        }</span>
<span class="fc" id="L4334">    }</span>

    /**
     * Convenience wrapper for &lt;tt&gt;setCoinSelector(Wallet.AllowUnconfirmedCoinSelector.get())&lt;/tt&gt;. If this method
     * is called on the wallet then transactions will be used for spending regardless of their confidence. This can
     * be dangerous - only use this if you absolutely know what you're doing!
     */
    public void allowSpendingUnconfirmedTransactions() {
<span class="fc" id="L4342">        setCoinSelector(AllowUnconfirmedCoinSelector.get());</span>
<span class="fc" id="L4343">    }</span>

    /**
     * Get the {@link UTXOProvider}.
     * @return The UTXO provider.
     */
    @Nullable public UTXOProvider getUTXOProvider() {
<span class="nc" id="L4350">        lock.lock();</span>
        try {
<span class="nc" id="L4352">            return vUTXOProvider;</span>
        } finally {
<span class="nc" id="L4354">            lock.unlock();</span>
<span class="nc" id="L4355">        }</span>
    }

    /**
     * Set the {@link UTXOProvider}.
     *
     * &lt;p&gt;The wallet will query the provider for spendable candidates, i.e. outputs controlled exclusively
     * by private keys contained in the wallet.&lt;/p&gt;
     *
     * &lt;p&gt;Note that the associated provider must be reattached after a wallet is loaded from disk.
     * The association is not serialized.&lt;/p&gt;
     */
    public void setUTXOProvider(@Nullable UTXOProvider provider) {
<span class="fc" id="L4368">        lock.lock();</span>
        try {
<span class="pc bpc" id="L4370" title="2 of 4 branches missed.">            checkArgument(provider == null || provider.getParams().equals(params));</span>
<span class="fc" id="L4371">            this.vUTXOProvider = provider;</span>
        } finally {
<span class="pc" id="L4373">            lock.unlock();</span>
<span class="pc" id="L4374">        }</span>
<span class="fc" id="L4375">    }</span>

    //endregion

    /******************************************************************************************************************/

    /**
     * A custom {@link TransactionOutput} that is free standing. This contains all the information
     * required for spending without actually having all the linked data (i.e parent tx).
     *
     */
    private class FreeStandingTransactionOutput extends TransactionOutput {
        private UTXO output;
        private int chainHeight;

        /**
         * Construct a free standing Transaction Output.
         * @param params The network parameters.
         * @param output The stored output (free standing).
         */
<span class="nc" id="L4395">        public FreeStandingTransactionOutput(NetworkParameters params, UTXO output, int chainHeight) {</span>
<span class="nc" id="L4396">            super(params, null, output.getValue(), output.getScript().getProgram());</span>
<span class="nc" id="L4397">            this.output = output;</span>
<span class="nc" id="L4398">            this.chainHeight = chainHeight;</span>
<span class="nc" id="L4399">        }</span>

        /**
         * Get the {@link UTXO}.
         * @return The stored output.
         */
        public UTXO getUTXO() {
<span class="nc" id="L4406">            return output;</span>
        }

        /**
         * Get the depth withing the chain of the parent tx, depth is 1 if it the output height is the height of
         * the latest block.
         * @return The depth.
         */
        @Override
        public int getParentTransactionDepthInBlocks() {
<span class="nc" id="L4416">            return chainHeight - output.getHeight() + 1;</span>
        }

        @Override
        public int getIndex() {
<span class="nc" id="L4421">            return (int) output.getIndex();</span>
        }

        @Override
        public Sha256Hash getParentTransactionHash() {
<span class="nc" id="L4426">            return output.getHash();</span>
        }
    }

    /******************************************************************************************************************/


    /******************************************************************************************************************/

    private static class TxOffsetPair implements Comparable&lt;TxOffsetPair&gt; {
        public final Transaction tx;
        public final int offset;

<span class="fc" id="L4439">        public TxOffsetPair(Transaction tx, int offset) {</span>
<span class="fc" id="L4440">            this.tx = tx;</span>
<span class="fc" id="L4441">            this.offset = offset;</span>
<span class="fc" id="L4442">        }</span>

        @Override public int compareTo(TxOffsetPair o) {
            // note that in this implementation compareTo() is not consistent with equals()
<span class="fc" id="L4446">            return Ints.compare(offset, o.offset);</span>
        }
    }

    //region Reorganisations

    /**
     * &lt;p&gt;Don't call this directly. It's not intended for API users.&lt;/p&gt;
     *
     * &lt;p&gt;Called by the {@link BlockChain} when the best chain (representing total work done) has changed. This can
     * cause the number of confirmations of a transaction to go higher, lower, drop to zero and can even result in
     * a transaction going dead (will never confirm) due to a double spend.&lt;/p&gt;
     *
     * &lt;p&gt;The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last.&lt;/p&gt;
     */
    @Override
    public void reorganize(StoredBlock splitPoint, List&lt;StoredBlock&gt; oldBlocks, List&lt;StoredBlock&gt; newBlocks) throws VerificationException {
<span class="fc" id="L4463">        lock.lock();</span>
        try {
            // This runs on any peer thread with the block chain locked.
            //
            // The reorganize functionality of the wallet is tested in ChainSplitTest.java
            //
            // receive() has been called on the block that is triggering the re-org before this is called, with type
            // of SIDE_CHAIN.
            //
            // Note that this code assumes blocks are not invalid - if blocks contain duplicated transactions,
            // transactions that double spend etc then we can calculate the incorrect result. This could open up
            // obscure DoS attacks if someone successfully mines a throwaway invalid block and feeds it to us, just
            // to try and corrupt the internal data structures. We should try harder to avoid this but it's tricky
            // because there are so many ways the block can be invalid.

            // Avoid spuriously informing the user of wallet/tx confidence changes whilst we're re-organizing.
<span class="pc bpc" id="L4479" title="1 of 2 branches missed.">            checkState(confidenceChanged.size() == 0);</span>
<span class="pc bpc" id="L4480" title="1 of 2 branches missed.">            checkState(!insideReorg);</span>
<span class="fc" id="L4481">            insideReorg = true;</span>
<span class="pc bpc" id="L4482" title="1 of 2 branches missed.">            checkState(onWalletChangedSuppressions == 0);</span>
<span class="fc" id="L4483">            onWalletChangedSuppressions++;</span>

            // Map block hash to transactions that appear in it. We ensure that the map values are sorted according
            // to their relative position within those blocks.
<span class="fc" id="L4487">            ArrayListMultimap&lt;Sha256Hash, TxOffsetPair&gt; mapBlockTx = ArrayListMultimap.create();</span>
<span class="fc bfc" id="L4488" title="All 2 branches covered.">            for (Transaction tx : getTransactions(true)) {</span>
<span class="fc" id="L4489">                Map&lt;Sha256Hash, Integer&gt; appearsIn = tx.getAppearsInHashes();</span>
<span class="fc bfc" id="L4490" title="All 2 branches covered.">                if (appearsIn == null) continue;  // Pending.</span>
<span class="fc bfc" id="L4491" title="All 2 branches covered.">                for (Map.Entry&lt;Sha256Hash, Integer&gt; block : appearsIn.entrySet())</span>
<span class="fc" id="L4492">                    mapBlockTx.put(block.getKey(), new TxOffsetPair(tx, block.getValue()));</span>
<span class="fc" id="L4493">            }</span>
<span class="fc bfc" id="L4494" title="All 2 branches covered.">            for (Sha256Hash blockHash : mapBlockTx.keySet())</span>
<span class="fc" id="L4495">                Collections.sort(mapBlockTx.get(blockHash));</span>

<span class="fc" id="L4497">            List&lt;Sha256Hash&gt; oldBlockHashes = new ArrayList&lt;Sha256Hash&gt;(oldBlocks.size());</span>
<span class="fc" id="L4498">            log.info(&quot;Old part of chain (top to bottom):&quot;);</span>
<span class="fc bfc" id="L4499" title="All 2 branches covered.">            for (StoredBlock b : oldBlocks) {</span>
<span class="fc" id="L4500">                log.info(&quot;  {}&quot;, b.getHeader().getHashAsString());</span>
<span class="fc" id="L4501">                oldBlockHashes.add(b.getHeader().getHash());</span>
<span class="fc" id="L4502">            }</span>
<span class="fc" id="L4503">            log.info(&quot;New part of chain (top to bottom):&quot;);</span>
<span class="fc bfc" id="L4504" title="All 2 branches covered.">            for (StoredBlock b : newBlocks) {</span>
<span class="fc" id="L4505">                log.info(&quot;  {}&quot;, b.getHeader().getHashAsString());</span>
<span class="fc" id="L4506">            }</span>

<span class="fc" id="L4508">            Collections.reverse(newBlocks);  // Need bottom-to-top but we get top-to-bottom.</span>

            // For each block in the old chain, disconnect the transactions in reverse order.
<span class="fc" id="L4511">            LinkedList&lt;Transaction&gt; oldChainTxns = Lists.newLinkedList();</span>
<span class="fc bfc" id="L4512" title="All 2 branches covered.">            for (Sha256Hash blockHash : oldBlockHashes) {</span>
<span class="fc bfc" id="L4513" title="All 2 branches covered.">                for (TxOffsetPair pair : mapBlockTx.get(blockHash)) {</span>
<span class="fc" id="L4514">                    Transaction tx = pair.tx;</span>
<span class="fc" id="L4515">                    final Sha256Hash txHash = tx.getHash();</span>
<span class="fc bfc" id="L4516" title="All 2 branches covered.">                    if (tx.isCoinBase()) {</span>
                        // All the transactions that we have in our wallet which spent this coinbase are now invalid
                        // and will never confirm. Hopefully this should never happen - that's the point of the maturity
                        // rule that forbids spending of coinbase transactions for 100 blocks.
                        //
                        // This could be recursive, although of course because we don't have the full transaction
                        // graph we can never reliably kill all transactions we might have that were rooted in
                        // this coinbase tx. Some can just go pending forever, like the Bitcoin Core. However we
                        // can do our best.
<span class="fc" id="L4525">                        log.warn(&quot;Coinbase killed by re-org: {}&quot;, tx.getHashAsString());</span>
<span class="fc" id="L4526">                        killTxns(ImmutableSet.of(tx), null);</span>
                    } else {
<span class="fc bfc" id="L4528" title="All 2 branches covered.">                        for (TransactionOutput output : tx.getOutputs()) {</span>
<span class="fc" id="L4529">                            TransactionInput input = output.getSpentBy();</span>
<span class="fc bfc" id="L4530" title="All 2 branches covered.">                            if (input != null) {</span>
<span class="pc bpc" id="L4531" title="1 of 2 branches missed.">                                if (output.isMineOrWatched(this))</span>
<span class="fc" id="L4532">                                    checkState(myUnspents.add(output));</span>
<span class="fc" id="L4533">                                input.disconnect();</span>
                            }
<span class="fc" id="L4535">                        }</span>
<span class="fc" id="L4536">                        oldChainTxns.add(tx);</span>
<span class="fc" id="L4537">                        unspent.remove(txHash);</span>
<span class="fc" id="L4538">                        spent.remove(txHash);</span>
<span class="pc bpc" id="L4539" title="1 of 2 branches missed.">                        checkState(!pending.containsKey(txHash));</span>
<span class="pc bpc" id="L4540" title="1 of 2 branches missed.">                        checkState(!dead.containsKey(txHash));</span>
                    }
<span class="fc" id="L4542">                }</span>
<span class="fc" id="L4543">            }</span>

            // Put all the disconnected transactions back into the pending pool and re-connect them.
<span class="fc bfc" id="L4546" title="All 2 branches covered.">            for (Transaction tx : oldChainTxns) {</span>
                // Coinbase transactions on the old part of the chain are dead for good and won't come back unless
                // there's another re-org.
<span class="pc bpc" id="L4549" title="1 of 2 branches missed.">                if (tx.isCoinBase()) continue;</span>
<span class="fc" id="L4550">                log.info(&quot;  -&gt;pending {}&quot;, tx.getHash());</span>

<span class="fc" id="L4552">                tx.getConfidence().setConfidenceType(ConfidenceType.PENDING);  // Wipe height/depth/work data.</span>
<span class="fc" id="L4553">                confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE);</span>
<span class="fc" id="L4554">                addWalletTransaction(Pool.PENDING, tx);</span>
<span class="fc" id="L4555">                updateForSpends(tx, false);</span>
<span class="fc" id="L4556">            }</span>

            // Note that dead transactions stay dead. Consider a chain that Finney attacks T1 and replaces it with
            // T2, so we move T1 into the dead pool. If there's now a re-org to a chain that doesn't include T2, it
            // doesn't matter - the miners deleted T1 from their mempool, will resurrect T2 and put that into the
            // mempool and so T1 is still seen as a losing double spend.

            // The old blocks have contributed to the depth for all the transactions in the
            // wallet that are in blocks up to and including the chain split block.
            // The total depth is calculated here and then subtracted from the appropriate transactions.
<span class="fc" id="L4566">            int depthToSubtract = oldBlocks.size();</span>
<span class="fc" id="L4567">            log.info(&quot;depthToSubtract = &quot; + depthToSubtract);</span>
            // Remove depthToSubtract from all transactions in the wallet except for pending.
<span class="fc" id="L4569">            subtractDepth(depthToSubtract, spent.values());</span>
<span class="fc" id="L4570">            subtractDepth(depthToSubtract, unspent.values());</span>
<span class="fc" id="L4571">            subtractDepth(depthToSubtract, dead.values());</span>

            // The effective last seen block is now the split point so set the lastSeenBlockHash.
<span class="fc" id="L4574">            setLastBlockSeenHash(splitPoint.getHeader().getHash());</span>

            // For each block in the new chain, work forwards calling receive() and notifyNewBestBlock().
            // This will pull them back out of the pending pool, or if the tx didn't appear in the old chain and
            // does appear in the new chain, will treat it as such and possibly kill pending transactions that
            // conflict.
<span class="fc bfc" id="L4580" title="All 2 branches covered.">            for (StoredBlock block : newBlocks) {</span>
<span class="fc" id="L4581">                log.info(&quot;Replaying block {}&quot;, block.getHeader().getHashAsString());</span>
<span class="fc bfc" id="L4582" title="All 2 branches covered.">                for (TxOffsetPair pair : mapBlockTx.get(block.getHeader().getHash())) {</span>
<span class="fc" id="L4583">                    log.info(&quot;  tx {}&quot;, pair.tx.getHash());</span>
                    try {
<span class="fc" id="L4585">                        receive(pair.tx, block, BlockChain.NewBlockType.BEST_CHAIN, pair.offset);</span>
<span class="nc" id="L4586">                    } catch (ScriptException e) {</span>
<span class="nc" id="L4587">                        throw new RuntimeException(e);  // Cannot happen as these blocks were already verified.</span>
<span class="fc" id="L4588">                    }</span>
<span class="fc" id="L4589">                }</span>
<span class="fc" id="L4590">                notifyNewBestBlock(block);</span>
<span class="fc" id="L4591">            }</span>
<span class="fc" id="L4592">            isConsistentOrThrow();</span>
<span class="fc" id="L4593">            final Coin balance = getBalance();</span>
<span class="fc" id="L4594">            log.info(&quot;post-reorg balance is {}&quot;, balance.toFriendlyString());</span>
            // Inform event listeners that a re-org took place.
<span class="fc" id="L4596">            queueOnReorganize();</span>
<span class="fc" id="L4597">            insideReorg = false;</span>
<span class="fc" id="L4598">            onWalletChangedSuppressions--;</span>
<span class="fc" id="L4599">            maybeQueueOnWalletChanged();</span>
<span class="fc" id="L4600">            checkBalanceFuturesLocked(balance);</span>
<span class="fc" id="L4601">            informConfidenceListenersIfNotReorganizing();</span>
<span class="fc" id="L4602">            saveLater();</span>
        } finally {
<span class="pc" id="L4604">            lock.unlock();</span>
<span class="pc" id="L4605">        }</span>
<span class="fc" id="L4606">    }</span>

    /**
     * Subtract the supplied depth from the given transactions.
     */
    private void subtractDepth(int depthToSubtract, Collection&lt;Transaction&gt; transactions) {
<span class="fc bfc" id="L4612" title="All 2 branches covered.">        for (Transaction tx : transactions) {</span>
<span class="fc bfc" id="L4613" title="All 2 branches covered.">            if (tx.getConfidence().getConfidenceType() == ConfidenceType.BUILDING) {</span>
<span class="fc" id="L4614">                tx.getConfidence().setDepthInBlocks(tx.getConfidence().getDepthInBlocks() - depthToSubtract);</span>
<span class="fc" id="L4615">                confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.DEPTH);</span>
            }
<span class="fc" id="L4617">        }</span>
<span class="fc" id="L4618">    }</span>

    //endregion

    /******************************************************************************************************************/

    //region Bloom filtering

<span class="fc" id="L4626">    private final ArrayList&lt;TransactionOutPoint&gt; bloomOutPoints = Lists.newArrayList();</span>
    // Used to track whether we must automatically begin/end a filter calculation and calc outpoints/take the locks.
<span class="fc" id="L4628">    private final AtomicInteger bloomFilterGuard = new AtomicInteger(0);</span>

    @Override
    public void beginBloomFilterCalculation() {
<span class="nc bnc" id="L4632" title="All 2 branches missed.">        if (bloomFilterGuard.incrementAndGet() &gt; 1)</span>
<span class="nc" id="L4633">            return;</span>
<span class="nc" id="L4634">        lock.lock();</span>
<span class="nc" id="L4635">        keyChainGroupLock.lock();</span>
        //noinspection FieldAccessNotGuarded
<span class="nc" id="L4637">        calcBloomOutPointsLocked();</span>
<span class="nc" id="L4638">    }</span>

    private void calcBloomOutPointsLocked() {
        // TODO: This could be done once and then kept up to date.
<span class="nc" id="L4642">        bloomOutPoints.clear();</span>
<span class="nc" id="L4643">        Set&lt;Transaction&gt; all = new HashSet&lt;Transaction&gt;();</span>
<span class="nc" id="L4644">        all.addAll(unspent.values());</span>
<span class="nc" id="L4645">        all.addAll(spent.values());</span>
<span class="nc" id="L4646">        all.addAll(pending.values());</span>
<span class="nc bnc" id="L4647" title="All 2 branches missed.">        for (Transaction tx : all) {</span>
<span class="nc bnc" id="L4648" title="All 2 branches missed.">            for (TransactionOutput out : tx.getOutputs()) {</span>
                try {
<span class="nc bnc" id="L4650" title="All 2 branches missed.">                    if (isTxOutputBloomFilterable(out))</span>
<span class="nc" id="L4651">                        bloomOutPoints.add(out.getOutPointFor());</span>
<span class="nc" id="L4652">                } catch (ScriptException e) {</span>
                    // If it is ours, we parsed the script correctly, so this shouldn't happen.
<span class="nc" id="L4654">                    throw new RuntimeException(e);</span>
<span class="nc" id="L4655">                }</span>
<span class="nc" id="L4656">            }</span>
<span class="nc" id="L4657">        }</span>
<span class="nc" id="L4658">    }</span>

    @Override @GuardedBy(&quot;keyChainGroupLock&quot;)
    public void endBloomFilterCalculation() {
<span class="nc bnc" id="L4662" title="All 2 branches missed.">        if (bloomFilterGuard.decrementAndGet() &gt; 0)</span>
<span class="nc" id="L4663">            return;</span>
<span class="nc" id="L4664">        bloomOutPoints.clear();</span>
<span class="nc" id="L4665">        keyChainGroupLock.unlock();</span>
<span class="nc" id="L4666">        lock.unlock();</span>
<span class="nc" id="L4667">    }</span>

    /**
     * Returns the number of distinct data items (note: NOT keys) that will be inserted into a bloom filter, when it
     * is constructed.
     */
    @Override
    public int getBloomFilterElementCount() {

<span class="nc" id="L4676">        beginBloomFilterCalculation();</span>
        try {
<span class="nc" id="L4678">            int size = bloomOutPoints.size();</span>
<span class="nc" id="L4679">            size += keyChainGroup.getBloomFilterElementCount();</span>
            // Some scripts may have more than one bloom element.  That should normally be okay, because under-counting
            // just increases false-positive rate.
<span class="nc" id="L4682">            size += watchedScripts.size();</span>
<span class="nc" id="L4683">            return size;</span>
        } finally {
<span class="nc" id="L4685">            endBloomFilterCalculation();</span>
<span class="nc" id="L4686">        }</span>
    }

    /**
     * If we are watching any scripts, the bloom filter must update on peers whenever an output is
     * identified.  This is because we don't necessarily have the associated pubkey, so we can't
     * watch for it on spending transactions.
     */
    @Override
    public boolean isRequiringUpdateAllBloomFilter() {
        // This is typically called by the PeerGroup, in which case it will have already explicitly taken the lock
        // before calling, but because this is public API we must still lock again regardless.
<span class="nc" id="L4698">        keyChainGroupLock.lock();</span>
        try {
<span class="nc bnc" id="L4700" title="All 2 branches missed.">            return !watchedScripts.isEmpty();</span>
        } finally {
<span class="nc" id="L4702">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L4703">        }</span>
    }

    /**
     * Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     * false-positive rate. See the docs for {@link BloomFilter} for a brief explanation of anonymity when using filters.
     */
    public BloomFilter getBloomFilter(double falsePositiveRate) {
<span class="nc" id="L4711">        beginBloomFilterCalculation();</span>
        try {
<span class="nc" id="L4713">            return getBloomFilter(getBloomFilterElementCount(), falsePositiveRate, (long) (Math.random() * Long.MAX_VALUE));</span>
        } finally {
<span class="nc" id="L4715">            endBloomFilterCalculation();</span>
<span class="nc" id="L4716">        }</span>
    }

    /**
     * &lt;p&gt;Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     * false-positive rate if it has size elements. Keep in mind that you will get 2 elements in the bloom filter for
     * each key in the wallet, for the public key and the hash of the public key (address form).&lt;/p&gt;
     * 
     * &lt;p&gt;This is used to generate a BloomFilter which can be {@link BloomFilter#merge(BloomFilter)}d with another.
     * It could also be used if you have a specific target for the filter's size.&lt;/p&gt;
     * 
     * &lt;p&gt;See the docs for {@link BloomFilter(int, double)} for a brief explanation of anonymity when using bloom
     * filters.&lt;/p&gt;
     */
    @Override @GuardedBy(&quot;keyChainGroupLock&quot;)
    public BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTweak) {
<span class="nc" id="L4732">        beginBloomFilterCalculation();</span>
        try {
<span class="nc" id="L4734">            BloomFilter filter = keyChainGroup.getBloomFilter(size, falsePositiveRate, nTweak);</span>
<span class="nc bnc" id="L4735" title="All 2 branches missed.">            for (Script script : watchedScripts) {</span>
<span class="nc bnc" id="L4736" title="All 2 branches missed.">                for (ScriptChunk chunk : script.getChunks()) {</span>
                    // Only add long (at least 64 bit) data to the bloom filter.
                    // If any long constants become popular in scripts, we will need logic
                    // here to exclude them.
<span class="nc bnc" id="L4740" title="All 4 branches missed.">                    if (!chunk.isOpCode() &amp;&amp; chunk.data.length &gt;= MINIMUM_BLOOM_DATA_LENGTH) {</span>
<span class="nc" id="L4741">                        filter.insert(chunk.data);</span>
                    }
<span class="nc" id="L4743">                }</span>
<span class="nc" id="L4744">            }</span>
<span class="nc bnc" id="L4745" title="All 2 branches missed.">            for (TransactionOutPoint point : bloomOutPoints)</span>
<span class="nc" id="L4746">                filter.insert(point.unsafeBitcoinSerialize());</span>
<span class="nc" id="L4747">            return filter;</span>
        } finally {
<span class="nc" id="L4749">            endBloomFilterCalculation();</span>
<span class="nc" id="L4750">        }</span>
    }

    // Returns true if the output is one that won't be selected by a data element matching in the scriptSig.
    private boolean isTxOutputBloomFilterable(TransactionOutput out) {
<span class="nc" id="L4755">        Script script = out.getScriptPubKey();</span>
<span class="nc bnc" id="L4756" title="All 4 branches missed.">        boolean isScriptTypeSupported = script.isSentToRawPubKey() || script.isPayToScriptHash();</span>
<span class="nc bnc" id="L4757" title="All 6 branches missed.">        return (isScriptTypeSupported &amp;&amp; myUnspents.contains(out)) || watchedScripts.contains(script);</span>
    }

    /**
     * Used by {@link Peer} to decide whether or not to discard this block and any blocks building upon it, in case
     * the Bloom filter used to request them may be exhausted, that is, not have sufficient keys in the deterministic
     * sequence within it to reliably find relevant transactions.
     */
    public boolean checkForFilterExhaustion(FilteredBlock block) {
<span class="nc" id="L4766">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L4768">            int epoch = keyChainGroup.getCombinedKeyLookaheadEpochs();</span>
<span class="nc bnc" id="L4769" title="All 2 branches missed.">            for (Transaction tx : block.getAssociatedTransactions().values()) {</span>
<span class="nc" id="L4770">                markKeysAsUsed(tx);</span>
<span class="nc" id="L4771">            }</span>
<span class="nc" id="L4772">            int newEpoch = keyChainGroup.getCombinedKeyLookaheadEpochs();</span>
<span class="nc bnc" id="L4773" title="All 2 branches missed.">            checkState(newEpoch &gt;= epoch);</span>
            // If the key lookahead epoch has advanced, there was a call to addKeys and the PeerGroup already has a
            // pending request to recalculate the filter queued up on another thread. The calling Peer should abandon
            // block at this point and await a new filter before restarting the download.
<span class="nc bnc" id="L4777" title="All 2 branches missed.">            return newEpoch &gt; epoch;</span>
        } finally {
<span class="nc" id="L4779">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L4780">        }</span>
    }

    //endregion

    /******************************************************************************************************************/

    //region Extensions to the wallet format.

    /**
     * By providing an object implementing the {@link WalletExtension} interface, you can save and load arbitrary
     * additional data that will be stored with the wallet. Each extension is identified by an ID, so attempting to
     * add the same extension twice (or two different objects that use the same ID) will throw an IllegalStateException.
     */
    public void addExtension(WalletExtension extension) {
<span class="nc" id="L4795">        String id = checkNotNull(extension).getWalletExtensionID();</span>
<span class="nc" id="L4796">        lock.lock();</span>
        try {
<span class="nc bnc" id="L4798" title="All 2 branches missed.">            if (extensions.containsKey(id))</span>
<span class="nc" id="L4799">                throw new IllegalStateException(&quot;Cannot add two extensions with the same ID: &quot; + id);</span>
<span class="nc" id="L4800">            extensions.put(id, extension);</span>
<span class="nc" id="L4801">            saveNow();</span>
        } finally {
<span class="nc" id="L4803">            lock.unlock();</span>
<span class="nc" id="L4804">        }</span>
<span class="nc" id="L4805">    }</span>

    /**
     * Atomically adds extension or returns an existing extension if there is one with the same id already present.
     */
    public WalletExtension addOrGetExistingExtension(WalletExtension extension) {
<span class="nc" id="L4811">        String id = checkNotNull(extension).getWalletExtensionID();</span>
<span class="nc" id="L4812">        lock.lock();</span>
        try {
<span class="nc" id="L4814">            WalletExtension previousExtension = extensions.get(id);</span>
<span class="nc bnc" id="L4815" title="All 2 branches missed.">            if (previousExtension != null)</span>
<span class="nc" id="L4816">                return previousExtension;</span>
<span class="nc" id="L4817">            extensions.put(id, extension);</span>
<span class="nc" id="L4818">            saveNow();</span>
<span class="nc" id="L4819">            return extension;</span>
        } finally {
<span class="nc" id="L4821">            lock.unlock();</span>
<span class="nc" id="L4822">        }</span>
    }

    /**
     * Either adds extension as a new extension or replaces the existing extension if one already exists with the same
     * id. This also triggers wallet auto-saving, so may be useful even when called with the same extension as is
     * already present.
     */
    public void addOrUpdateExtension(WalletExtension extension) {
<span class="nc" id="L4831">        String id = checkNotNull(extension).getWalletExtensionID();</span>
<span class="nc" id="L4832">        lock.lock();</span>
        try {
<span class="nc" id="L4834">            extensions.put(id, extension);</span>
<span class="nc" id="L4835">            saveNow();</span>
        } finally {
<span class="nc" id="L4837">            lock.unlock();</span>
<span class="nc" id="L4838">        }</span>
<span class="nc" id="L4839">    }</span>

    /** Returns a snapshot of all registered extension objects. The extensions themselves are not copied. */
    public Map&lt;String, WalletExtension&gt; getExtensions() {
<span class="fc" id="L4843">        lock.lock();</span>
        try {
<span class="fc" id="L4845">            return ImmutableMap.copyOf(extensions);</span>
        } finally {
<span class="pc" id="L4847">            lock.unlock();</span>
<span class="nc" id="L4848">        }</span>
    }

    /**
     * Deserialize the wallet extension with the supplied data and then install it, replacing any existing extension
     * that may have existed with the same ID. If an exception is thrown then the extension is removed from the wallet,
     * if already present.
     */
    public void deserializeExtension(WalletExtension extension, byte[] data) throws Exception {
<span class="nc" id="L4857">        lock.lock();</span>
<span class="nc" id="L4858">        keyChainGroupLock.lock();</span>
        try {
            // This method exists partly to establish a lock ordering of wallet &gt; extension.
<span class="nc" id="L4861">            extension.deserializeWalletExtension(this, data);</span>
<span class="nc" id="L4862">            extensions.put(extension.getWalletExtensionID(), extension);</span>
<span class="nc" id="L4863">        } catch (Throwable throwable) {</span>
<span class="nc" id="L4864">            log.error(&quot;Error during extension deserialization&quot;, throwable);</span>
<span class="nc" id="L4865">            extensions.remove(extension.getWalletExtensionID());</span>
<span class="nc" id="L4866">            Throwables.propagate(throwable);</span>
        } finally {
<span class="nc" id="L4868">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L4869">            lock.unlock();</span>
<span class="nc" id="L4870">        }</span>
<span class="nc" id="L4871">    }</span>

    @Override
    public void setTag(String tag, ByteString value) {
<span class="nc" id="L4875">        super.setTag(tag, value);</span>
<span class="nc" id="L4876">        saveNow();</span>
<span class="nc" id="L4877">    }</span>

    //endregion

    /******************************************************************************************************************/

<span class="fc" id="L4883">    private static class FeeCalculation {</span>
        public CoinSelection bestCoinSelection;
        public TransactionOutput bestChangeOutput;
    }

    //region Fee calculation code

    public FeeCalculation calculateFee(SendRequest req, Coin value, List&lt;TransactionInput&gt; originalInputs,
                                       boolean needAtLeastReferenceFee, List&lt;TransactionOutput&gt; candidates) throws InsufficientMoneyException {
<span class="fc" id="L4892">        checkState(lock.isHeldByCurrentThread());</span>
        // There are 3 possibilities for what adding change might do:
        // 1) No effect
        // 2) Causes increase in fee (change &lt; 0.01 COINS)
        // 3) Causes the transaction to have a dust output or change &lt; fee increase (ie change will be thrown away)
        // If we get either of the last 2, we keep note of what the inputs looked like at the time and try to
        // add inputs as we go up the list (keeping track of minimum inputs for each category).  At the end, we pick
        // the best input set as the one which generates the lowest total fee.
<span class="fc" id="L4900">        Coin additionalValueForNextCategory = null;</span>
<span class="fc" id="L4901">        CoinSelection selection3 = null;</span>
<span class="fc" id="L4902">        CoinSelection selection2 = null;</span>
<span class="fc" id="L4903">        TransactionOutput selection2Change = null;</span>
<span class="fc" id="L4904">        CoinSelection selection1 = null;</span>
<span class="fc" id="L4905">        TransactionOutput selection1Change = null;</span>
        // We keep track of the last size of the transaction we calculated but only if the act of adding inputs and
        // change resulted in the size crossing a 1000 byte boundary. Otherwise it stays at zero.
<span class="fc" id="L4908">        int lastCalculatedSize = 0;</span>
<span class="fc" id="L4909">        int lastCalculatedInputs = 0;</span>
<span class="fc" id="L4910">        Coin valueNeeded, valueMissing = null;</span>
        while (true) {
<span class="fc" id="L4912">            resetTxInputs(req, originalInputs);</span>

<span class="fc" id="L4914">            Coin fees = req.feePerKb.multiply(lastCalculatedSize).divide(1000);</span>
<span class="pc bpc" id="L4915" title="3 of 4 branches missed.">            if (needAtLeastReferenceFee &amp;&amp; fees.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) &lt; 0)</span>
<span class="nc" id="L4916">                fees = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;</span>

            //MTNS instantSend
<span class="pc bpc" id="L4919" title="1 of 2 branches missed.">            if(req.useInstantSend) {</span>
<span class="nc" id="L4920">                fees = Coin.valueOf(max(TransactionLockRequest.MIN_FEE.getValue(), TransactionLockRequest.MIN_FEE.multiply(lastCalculatedInputs).getValue()));</span>
            }

<span class="fc" id="L4923">            valueNeeded = value.add(fees);</span>
<span class="pc bpc" id="L4924" title="1 of 2 branches missed.">            if (additionalValueForNextCategory != null)</span>
<span class="nc" id="L4925">                valueNeeded = valueNeeded.add(additionalValueForNextCategory);</span>
<span class="fc" id="L4926">            Coin additionalValueSelected = additionalValueForNextCategory;</span>

            // Of the coins we could spend, pick some that we actually will spend.
<span class="pc bpc" id="L4929" title="1 of 2 branches missed.">            CoinSelector selector = req.coinSelector == null ? coinSelector : req.coinSelector;</span>
            // selector is allowed to modify candidates list.
<span class="fc" id="L4931">            CoinSelection selection = selector.select(valueNeeded, new LinkedList&lt;TransactionOutput&gt;(candidates));</span>
            // Can we afford this?
<span class="fc bfc" id="L4933" title="All 2 branches covered.">            if (selection.valueGathered.compareTo(valueNeeded) &lt; 0) {</span>
<span class="fc" id="L4934">                valueMissing = valueNeeded.subtract(selection.valueGathered);</span>
<span class="fc" id="L4935">                break;</span>
            }
<span class="pc bpc" id="L4937" title="3 of 4 branches missed.">            checkState(selection.gathered.size() &gt; 0 || originalInputs.size() &gt; 0);</span>

            // We keep track of an upper bound on transaction size to calculate fees that need to be added.
            // Note that the difference between the upper bound and lower bound is usually small enough that it
            // will be very rare that we pay a fee we do not need to.
            //
            // We can't be sure a selection is valid until we check fee per kb at the end, so we just store
            // them here temporarily.
<span class="fc" id="L4945">            boolean eitherCategory2Or3 = false;</span>
<span class="fc" id="L4946">            boolean isCategory3 = false;</span>

<span class="fc" id="L4948">            Coin change = selection.valueGathered.subtract(valueNeeded);</span>
<span class="pc bpc" id="L4949" title="1 of 2 branches missed.">            if (additionalValueSelected != null)</span>
<span class="nc" id="L4950">                change = change.add(additionalValueSelected);</span>

            // If change is &lt; 0.01 BTC, we will need to have at least minfee to be accepted by the network
<span class="pc bpc" id="L4953" title="3 of 4 branches missed.">            if (req.ensureMinRequiredFee &amp;&amp; !change.equals(Coin.ZERO) &amp;&amp;</span>
<span class="nc bnc" id="L4954" title="All 4 branches missed.">                    change.compareTo(Coin.CENT) &lt; 0 &amp;&amp; fees.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) &lt; 0) {</span>
                // This solution may fit into category 2, but it may also be category 3, we'll check that later
<span class="nc" id="L4956">                eitherCategory2Or3 = true;</span>
<span class="nc" id="L4957">                additionalValueForNextCategory = Coin.CENT;</span>
                // If the change is smaller than the fee we want to add, this will be negative
<span class="nc" id="L4959">                change = change.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.subtract(fees));</span>
            }

<span class="fc" id="L4962">            int size = 0;</span>
<span class="fc" id="L4963">            int inputs = 0;</span>
<span class="fc" id="L4964">            TransactionOutput changeOutput = null;</span>
<span class="fc bfc" id="L4965" title="All 2 branches covered.">            if (change.signum() &gt; 0) {</span>
                // The value of the inputs is greater than what we want to send. Just like in real life then,
                // we need to take back some coins ... this is called &quot;change&quot;. Add another output that sends the change
                // back to us. The address comes either from the request or currentChangeAddress() as a default.
<span class="fc" id="L4969">                Address changeAddress = req.changeAddress;</span>
<span class="pc bpc" id="L4970" title="1 of 2 branches missed.">                if (changeAddress == null)</span>
<span class="fc" id="L4971">                    changeAddress = currentChangeAddress();</span>
<span class="fc" id="L4972">                changeOutput = new TransactionOutput(params, req.tx, change, changeAddress);</span>
                // If the change output would result in this transaction being rejected as dust, just drop the change and make it a fee
<span class="pc bpc" id="L4974" title="3 of 4 branches missed.">                if (req.ensureMinRequiredFee &amp;&amp; changeOutput.isDust()) {</span>
                    // This solution definitely fits in category 3
<span class="nc" id="L4976">                    isCategory3 = true;</span>
<span class="nc" id="L4977">                    additionalValueForNextCategory = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(</span>
<span class="nc" id="L4978">                                                     changeOutput.getMinNonDustValue().add(Coin.SATOSHI));</span>
                } else {
<span class="fc" id="L4980">                    size += changeOutput.unsafeBitcoinSerialize().length + VarInt.sizeOf(req.tx.getOutputs().size()) - VarInt.sizeOf(req.tx.getOutputs().size() - 1);</span>
                    // This solution is either category 1 or 2
<span class="pc bpc" id="L4982" title="1 of 2 branches missed.">                    if (!eitherCategory2Or3) // must be category 1</span>
<span class="fc" id="L4983">                        additionalValueForNextCategory = null;</span>
                }
<span class="fc" id="L4985">            } else {</span>
<span class="pc bpc" id="L4986" title="1 of 2 branches missed.">                if (eitherCategory2Or3) {</span>
                    // This solution definitely fits in category 3 (we threw away change because it was smaller than MIN_TX_FEE)
<span class="nc" id="L4988">                    isCategory3 = true;</span>
<span class="nc" id="L4989">                    additionalValueForNextCategory = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Coin.SATOSHI);</span>
                }
            }

            // Now add unsigned inputs for the selected coins.
<span class="fc bfc" id="L4994" title="All 2 branches covered.">            for (TransactionOutput output : selection.gathered) {</span>
<span class="fc" id="L4995">                TransactionInput input = req.tx.addInput(output);</span>
                // If the scriptBytes don't default to none, our size calculations will be thrown off.
<span class="pc bpc" id="L4997" title="1 of 2 branches missed.">                checkState(input.getScriptBytes().length == 0);</span>
<span class="fc" id="L4998">            }</span>

            // Estimate transaction size and loop again if we need more fee per kb. The serialized tx doesn't
            // include things we haven't added yet like input signatures/scripts or the change output.
<span class="fc" id="L5002">            size += req.tx.unsafeBitcoinSerialize().length;</span>
<span class="fc" id="L5003">            size += estimateBytesForSigning(selection);</span>
<span class="fc" id="L5004">            inputs = req.tx.getInputs().size();</span>
<span class="pc bpc" id="L5005" title="5 of 8 branches missed.">            if (size &gt; lastCalculatedSize &amp;&amp; req.feePerKb.signum() &gt; 0 || req.useInstantSend &amp;&amp; inputs &gt; lastCalculatedInputs) {</span>
<span class="nc" id="L5006">                lastCalculatedSize = size;</span>
<span class="nc" id="L5007">                lastCalculatedInputs = inputs;</span>
                // We need more fees anyway, just try again with the same additional value
<span class="nc" id="L5009">                additionalValueForNextCategory = additionalValueSelected;</span>
<span class="nc" id="L5010">                continue;</span>
            }

<span class="pc bpc" id="L5013" title="1 of 2 branches missed.">            if (isCategory3) {</span>
<span class="nc bnc" id="L5014" title="All 2 branches missed.">                if (selection3 == null)</span>
<span class="nc" id="L5015">                    selection3 = selection;</span>
<span class="pc bpc" id="L5016" title="1 of 2 branches missed.">            } else if (eitherCategory2Or3) {</span>
                // If we are in selection2, we will require at least CENT additional. If we do that, there is no way
                // we can end up back here because CENT additional will always get us to 1
<span class="nc bnc" id="L5019" title="All 2 branches missed.">                checkState(selection2 == null);</span>
<span class="nc" id="L5020">                checkState(additionalValueForNextCategory.equals(Coin.CENT));</span>
<span class="nc" id="L5021">                selection2 = selection;</span>
<span class="nc" id="L5022">                selection2Change = checkNotNull(changeOutput); // If we get no change in category 2, we are actually in category 3</span>
            } else {
                // Once we get a category 1 (change kept), we should break out of the loop because we can't do better
<span class="pc bpc" id="L5025" title="1 of 2 branches missed.">                checkState(selection1 == null);</span>
<span class="pc bpc" id="L5026" title="1 of 2 branches missed.">                checkState(additionalValueForNextCategory == null);</span>
<span class="fc" id="L5027">                selection1 = selection;</span>
<span class="fc" id="L5028">                selection1Change = changeOutput;</span>
            }

<span class="pc bpc" id="L5031" title="1 of 2 branches missed.">            if (additionalValueForNextCategory != null) {</span>
<span class="nc bnc" id="L5032" title="All 2 branches missed.">                if (additionalValueSelected != null)</span>
<span class="nc bnc" id="L5033" title="All 2 branches missed.">                    checkState(additionalValueForNextCategory.compareTo(additionalValueSelected) &gt; 0);</span>
                continue;
            }
            break;
        }

<span class="fc" id="L5039">        resetTxInputs(req, originalInputs);</span>

<span class="pc bpc" id="L5041" title="2 of 6 branches missed.">        if (selection3 == null &amp;&amp; selection2 == null &amp;&amp; selection1 == null) {</span>
<span class="fc" id="L5042">            checkNotNull(valueMissing);</span>
<span class="fc" id="L5043">            log.warn(&quot;Insufficient value in wallet for send: needed {} more&quot;, valueMissing.toFriendlyString());</span>
<span class="fc" id="L5044">            throw new InsufficientMoneyException(valueMissing);</span>
        }

<span class="fc" id="L5047">        Coin lowestFee = null;</span>
<span class="fc" id="L5048">        FeeCalculation result = new FeeCalculation();</span>
<span class="pc bpc" id="L5049" title="1 of 2 branches missed.">        if (selection1 != null) {</span>
<span class="fc bfc" id="L5050" title="All 2 branches covered.">            if (selection1Change != null)</span>
<span class="fc" id="L5051">                lowestFee = selection1.valueGathered.subtract(selection1Change.getValue());</span>
            else
<span class="fc" id="L5053">                lowestFee = selection1.valueGathered;</span>
<span class="fc" id="L5054">            result.bestCoinSelection = selection1;</span>
<span class="fc" id="L5055">            result.bestChangeOutput = selection1Change;</span>
        }

<span class="pc bpc" id="L5058" title="1 of 2 branches missed.">        if (selection2 != null) {</span>
<span class="nc" id="L5059">            Coin fee = selection2.valueGathered.subtract(checkNotNull(selection2Change).getValue());</span>
<span class="nc bnc" id="L5060" title="All 4 branches missed.">            if (lowestFee == null || fee.compareTo(lowestFee) &lt; 0) {</span>
<span class="nc" id="L5061">                lowestFee = fee;</span>
<span class="nc" id="L5062">                result.bestCoinSelection = selection2;</span>
<span class="nc" id="L5063">                result.bestChangeOutput = selection2Change;</span>
            }
        }

<span class="pc bpc" id="L5067" title="1 of 2 branches missed.">        if (selection3 != null) {</span>
<span class="nc bnc" id="L5068" title="All 4 branches missed.">            if (lowestFee == null || selection3.valueGathered.compareTo(lowestFee) &lt; 0) {</span>
<span class="nc" id="L5069">                result.bestCoinSelection = selection3;</span>
<span class="nc" id="L5070">                result.bestChangeOutput = null;</span>
            }
        }
<span class="fc" id="L5073">        return result;</span>
    }

    private void resetTxInputs(SendRequest req, List&lt;TransactionInput&gt; originalInputs) {
<span class="fc" id="L5077">        req.tx.clearInputs();</span>
<span class="pc bpc" id="L5078" title="1 of 2 branches missed.">        for (TransactionInput input : originalInputs)</span>
<span class="nc" id="L5079">            req.tx.addInput(input);</span>
<span class="fc" id="L5080">    }</span>

    private int estimateBytesForSigning(CoinSelection selection) {
<span class="fc" id="L5083">        int size = 0;</span>
<span class="fc bfc" id="L5084" title="All 2 branches covered.">        for (TransactionOutput output : selection.gathered) {</span>
            try {
<span class="fc" id="L5086">                Script script = output.getScriptPubKey();</span>
<span class="fc" id="L5087">                ECKey key = null;</span>
<span class="fc" id="L5088">                Script redeemScript = null;</span>
<span class="fc bfc" id="L5089" title="All 2 branches covered.">                if (script.isSentToAddress()) {</span>
<span class="fc" id="L5090">                    key = findKeyFromPubHash(script.getPubKeyHash());</span>
<span class="fc" id="L5091">                    checkNotNull(key, &quot;Coin selection includes unspendable outputs&quot;);</span>
<span class="pc bpc" id="L5092" title="1 of 2 branches missed.">                } else if (script.isPayToScriptHash()) {</span>
<span class="nc" id="L5093">                    redeemScript = findRedeemDataFromScriptHash(script.getPubKeyHash()).redeemScript;</span>
<span class="nc" id="L5094">                    checkNotNull(redeemScript, &quot;Coin selection includes unspendable outputs&quot;);</span>
                }
<span class="fc" id="L5096">                size += script.getNumberOfBytesRequiredToSpend(key, redeemScript);</span>
<span class="nc" id="L5097">            } catch (ScriptException e) {</span>
                // If this happens it means an output script in a wallet tx could not be understood. That should never
                // happen, if it does it means the wallet has got into an inconsistent state.
<span class="nc" id="L5100">                throw new IllegalStateException(e);</span>
<span class="fc" id="L5101">            }</span>
<span class="fc" id="L5102">        }</span>
<span class="fc" id="L5103">        return size;</span>
    }

    //endregion

    /******************************************************************************************************************/

    //region Wallet maintenance transactions

    // Wallet maintenance transactions. These transactions may not be directly connected to a payment the user is
    // making. They may be instead key rotation transactions for when old keys are suspected to be compromised,
    // de/re-fragmentation transactions for when our output sizes are inappropriate or suboptimal, privacy transactions
    // and so on. Because these transactions may require user intervention in some way (e.g. entering their password)
    // the wallet application is expected to poll the Wallet class to get SendRequests. Ideally security systems like
    // hardware wallets or risk analysis providers are programmed to auto-approve transactions that send from our own
    // keys back to our own keys.

    /**
     * &lt;p&gt;Specifies that the given {@link TransactionBroadcaster}, typically a {@link PeerGroup}, should be used for
     * sending transactions to the Bitcoin network by default. Some sendCoins methods let you specify a broadcaster
     * explicitly, in that case, they don't use this broadcaster. If null is specified then the wallet won't attempt
     * to broadcast transactions itself.&lt;/p&gt;
     *
     * &lt;p&gt;You don't normally need to call this. A {@link PeerGroup} will automatically set itself as the wallets
     * broadcaster when you use {@link PeerGroup#addWallet(Wallet)}. A wallet can use the broadcaster when you ask
     * it to send money, but in future also at other times to implement various features that may require asynchronous
     * re-organisation of the wallet contents on the block chain. For instance, in future the wallet may choose to
     * optimise itself to reduce fees or improve privacy.&lt;/p&gt;
     */
    public void setTransactionBroadcaster(@Nullable site.mtnsj.core.TransactionBroadcaster broadcaster) {
<span class="nc" id="L5133">        Transaction[] toBroadcast = {};</span>
<span class="nc" id="L5134">        lock.lock();</span>
        try {
<span class="nc bnc" id="L5136" title="All 2 branches missed.">            if (vTransactionBroadcaster == broadcaster)</span>
<span class="nc" id="L5137">                return;</span>
<span class="nc" id="L5138">            vTransactionBroadcaster = broadcaster;</span>
<span class="nc bnc" id="L5139" title="All 2 branches missed.">            if (broadcaster == null)</span>
<span class="nc" id="L5140">                return;</span>
<span class="nc" id="L5141">            toBroadcast = pending.values().toArray(toBroadcast);</span>
        } finally {
<span class="nc" id="L5143">            lock.unlock();</span>
<span class="nc" id="L5144">        }</span>
        // Now use it to upload any pending transactions we have that are marked as not being seen by any peers yet.
        // Don't hold the wallet lock whilst doing this, so if the broadcaster accesses the wallet at some point there
        // is no inversion.
<span class="nc bnc" id="L5148" title="All 2 branches missed.">        for (Transaction tx : toBroadcast) {</span>
<span class="nc" id="L5149">            ConfidenceType confidenceType = tx.getConfidence().getConfidenceType();</span>
<span class="nc bnc" id="L5150" title="All 2 branches missed.">            if(confidenceType == ConfidenceType.UNKNOWN /*&amp;&amp; tx.getConfidence().getSource() == Source.SELF*/)</span>
            {
<span class="nc" id="L5152">                log.error(&quot;A pending transaction of type UNKNOWN {}\nDeleting&quot;, tx.toString());</span>
                //tx.getConfidence().setConfidenceType(ConfidenceType.PENDING);
                //pending.remove(tx.getHash());
<span class="nc" id="L5155">                continue;</span>

            }
<span class="nc bnc" id="L5158" title="All 4 branches missed.">            checkState(confidenceType == ConfidenceType.PENDING || confidenceType == ConfidenceType.IN_CONFLICT,</span>
                    &quot;Expected PENDING or IN_CONFLICT, was %s.&quot;, confidenceType);
            // Re-broadcast even if it's marked as already seen for two reasons
            // 1) Old wallets may have transactions marked as broadcast by 1 peer when in reality the network
            //    never saw it, due to bugs.
            // 2) It can't really hurt.
<span class="nc" id="L5164">            log.info(&quot;New broadcaster so uploading waiting tx {}&quot;, tx.getHash());</span>
<span class="nc" id="L5165">            broadcaster.broadcastTransaction(tx);</span>
        }
<span class="nc" id="L5167">    }</span>

    /**
     * When a key rotation time is set, and money controlled by keys created before the given timestamp T will be
     * automatically respent to any key that was created after T. This can be used to recover from a situation where
     * a set of keys is believed to be compromised. Once the time is set transactions will be created and broadcast
     * immediately. New coins that come in after calling this method will be automatically respent immediately. The
     * rotation time is persisted to the wallet. You can stop key rotation by calling this method again with zero
     * as the argument.
     */
    public void setKeyRotationTime(Date time) {
<span class="nc" id="L5178">        setKeyRotationTime(time.getTime() / 1000);</span>
<span class="nc" id="L5179">    }</span>

    /**
     * Returns the key rotation time, or null if unconfigured. See {@link #setKeyRotationTime(Date)} for a description
     * of the field.
     */
    public @Nullable Date getKeyRotationTime() {
<span class="fc" id="L5186">        final long keyRotationTimestamp = vKeyRotationTimestamp;</span>
<span class="pc bpc" id="L5187" title="1 of 2 branches missed.">        if (keyRotationTimestamp != 0)</span>
<span class="nc" id="L5188">            return new Date(keyRotationTimestamp * 1000);</span>
        else
<span class="fc" id="L5190">            return null;</span>
    }

    /**
     * &lt;p&gt;When a key rotation time is set, any money controlled by keys created before the given timestamp T will be
     * automatically respent to any key that was created after T. This can be used to recover from a situation where
     * a set of keys is believed to be compromised. You can stop key rotation by calling this method again with zero
     * as the argument. Once set up, calling {@link #doMaintenance(org.spongycastle.crypto.params.KeyParameter, boolean)}
     * will create and possibly send rotation transactions: but it won't be done automatically (because you might have
     * to ask for the users password).&lt;/p&gt;
     *
     * &lt;p&gt;The given time cannot be in the future.&lt;/p&gt;
     */
    public void setKeyRotationTime(long unixTimeSeconds) {
<span class="nc bnc" id="L5204" title="All 2 branches missed.">        checkArgument(unixTimeSeconds &lt;= Utils.currentTimeSeconds(), &quot;Given time (%s) cannot be in the future.&quot;,</span>
<span class="nc" id="L5205">                Utils.dateTimeFormat(unixTimeSeconds * 1000));</span>
<span class="nc" id="L5206">        vKeyRotationTimestamp = unixTimeSeconds;</span>
<span class="nc" id="L5207">        saveNow();</span>
<span class="nc" id="L5208">    }</span>

    /** Returns whether the keys creation time is before the key rotation time, if one was set. */
    public boolean isKeyRotating(ECKey key) {
<span class="nc" id="L5212">        long time = vKeyRotationTimestamp;</span>
<span class="nc bnc" id="L5213" title="All 4 branches missed.">        return time != 0 &amp;&amp; key.getCreationTimeSeconds() &lt; time;</span>
    }

    /** @deprecated Renamed to doMaintenance */
    @Deprecated
    public ListenableFuture&lt;List&lt;Transaction&gt;&gt; maybeDoMaintenance(@Nullable KeyParameter aesKey, boolean andSend) throws DeterministicUpgradeRequiresPassword {
<span class="nc" id="L5219">        return doMaintenance(aesKey, andSend);</span>
    }

    /**
     * A wallet app should call this from time to time in order to let the wallet craft and send transactions needed
     * to re-organise coins internally. A good time to call this would be after receiving coins for an unencrypted
     * wallet, or after sending money for an encrypted wallet. If you have an encrypted wallet and just want to know
     * if some maintenance needs doing, call this method with andSend set to false and look at the returned list of
     * transactions. Maintenance might also include internal changes that involve some processing or work but
     * which don't require making transactions - these will happen automatically unless the password is required
     * in which case an exception will be thrown.
     *
     * @param aesKey the users password, if any.
     * @param signAndSend if true, send the transactions via the tx broadcaster and return them, if false just return them.
     * @return A list of transactions that the wallet just made/will make for internal maintenance. Might be empty.
     * @throws site.mtnsj.wallet.DeterministicUpgradeRequiresPassword if key rotation requires the users password.
     */
    public ListenableFuture&lt;List&lt;Transaction&gt;&gt; doMaintenance(@Nullable KeyParameter aesKey, boolean signAndSend) throws DeterministicUpgradeRequiresPassword {
        List&lt;Transaction&gt; txns;
<span class="nc" id="L5238">        lock.lock();</span>
<span class="nc" id="L5239">        keyChainGroupLock.lock();</span>
        try {
<span class="nc" id="L5241">            txns = maybeRotateKeys(aesKey, signAndSend);</span>
<span class="nc bnc" id="L5242" title="All 2 branches missed.">            if (!signAndSend)</span>
<span class="nc" id="L5243">                return Futures.immediateFuture(txns);</span>
        } finally {
<span class="nc" id="L5245">            keyChainGroupLock.unlock();</span>
<span class="nc" id="L5246">            lock.unlock();</span>
<span class="nc" id="L5247">        }</span>
<span class="nc bnc" id="L5248" title="All 2 branches missed.">        checkState(!lock.isHeldByCurrentThread());</span>
<span class="nc" id="L5249">        ArrayList&lt;ListenableFuture&lt;Transaction&gt;&gt; futures = new ArrayList&lt;ListenableFuture&lt;Transaction&gt;&gt;(txns.size());</span>
<span class="nc" id="L5250">        TransactionBroadcaster broadcaster = vTransactionBroadcaster;</span>
<span class="nc bnc" id="L5251" title="All 2 branches missed.">        for (Transaction tx : txns) {</span>
            try {
<span class="nc" id="L5253">                final ListenableFuture&lt;Transaction&gt; future = broadcaster.broadcastTransaction(tx).future();</span>
<span class="nc" id="L5254">                futures.add(future);</span>
<span class="nc" id="L5255">                Futures.addCallback(future, new FutureCallback&lt;Transaction&gt;() {</span>
                    @Override
                    public void onSuccess(Transaction transaction) {
<span class="nc" id="L5258">                        log.info(&quot;Successfully broadcast key rotation tx: {}&quot;, transaction);</span>
<span class="nc" id="L5259">                    }</span>

                    @Override
                    public void onFailure(Throwable throwable) {
<span class="nc" id="L5263">                        log.error(&quot;Failed to broadcast key rotation tx&quot;, throwable);</span>
<span class="nc" id="L5264">                    }</span>
                });
<span class="nc" id="L5266">            } catch (Exception e) {</span>
<span class="nc" id="L5267">                log.error(&quot;Failed to broadcast rekey tx&quot;, e);</span>
<span class="nc" id="L5268">            }</span>
<span class="nc" id="L5269">        }</span>
<span class="nc" id="L5270">        return Futures.allAsList(futures);</span>
    }

    // Checks to see if any coins are controlled by rotating keys and if so, spends them.
    @GuardedBy(&quot;keyChainGroupLock&quot;)
    private List&lt;Transaction&gt; maybeRotateKeys(@Nullable KeyParameter aesKey, boolean sign) throws DeterministicUpgradeRequiresPassword {
<span class="nc" id="L5276">        checkState(lock.isHeldByCurrentThread());</span>
<span class="nc" id="L5277">        checkState(keyChainGroupLock.isHeldByCurrentThread());</span>
<span class="nc" id="L5278">        List&lt;Transaction&gt; results = Lists.newLinkedList();</span>
        // TODO: Handle chain replays here.
<span class="nc" id="L5280">        final long keyRotationTimestamp = vKeyRotationTimestamp;</span>
<span class="nc bnc" id="L5281" title="All 2 branches missed.">        if (keyRotationTimestamp == 0) return results;  // Nothing to do.</span>

        // We might have to create a new HD hierarchy if the previous ones are now rotating.
<span class="nc" id="L5284">        boolean allChainsRotating = true;</span>
<span class="nc bnc" id="L5285" title="All 2 branches missed.">        for (DeterministicKeyChain chain : keyChainGroup.getDeterministicKeyChains()) {</span>
<span class="nc bnc" id="L5286" title="All 2 branches missed.">            if (chain.getEarliestKeyCreationTime() &gt;= keyRotationTimestamp) {</span>
<span class="nc" id="L5287">                allChainsRotating = false;</span>
<span class="nc" id="L5288">                break;</span>
            }
<span class="nc" id="L5290">        }</span>
<span class="nc bnc" id="L5291" title="All 2 branches missed.">        if (allChainsRotating) {</span>
            try {
<span class="nc bnc" id="L5293" title="All 2 branches missed.">                if (keyChainGroup.getImportedKeys().isEmpty()) {</span>
<span class="nc" id="L5294">                    log.info(&quot;All HD chains are currently rotating and we have no random keys, creating fresh HD chain ...&quot;);</span>
<span class="nc" id="L5295">                    keyChainGroup.createAndActivateNewHDChain();</span>
                } else {
<span class="nc" id="L5297">                    log.info(&quot;All HD chains are currently rotating, attempting to create a new one from the next oldest non-rotating key material ...&quot;);</span>
<span class="nc" id="L5298">                    keyChainGroup.upgradeToDeterministic(keyRotationTimestamp, aesKey);</span>
<span class="nc" id="L5299">                    log.info(&quot; ... upgraded to HD again, based on next best oldest key.&quot;);</span>
                }
<span class="nc" id="L5301">            } catch (AllRandomKeysRotating rotating) {</span>
<span class="nc" id="L5302">                log.info(&quot; ... no non-rotating random keys available, generating entirely new HD tree: backup required after this.&quot;);</span>
<span class="nc" id="L5303">                keyChainGroup.createAndActivateNewHDChain();</span>
<span class="nc" id="L5304">            }</span>
<span class="nc" id="L5305">            saveNow();</span>
        }

        // Because transactions are size limited, we might not be able to re-key the entire wallet in one go. So
        // loop around here until we no longer produce transactions with the max number of inputs. That means we're
        // fully done, at least for now (we may still get more transactions later and this method will be reinvoked).
        Transaction tx;
        do {
<span class="nc" id="L5313">            tx = rekeyOneBatch(keyRotationTimestamp, aesKey, results, sign);</span>
<span class="nc bnc" id="L5314" title="All 2 branches missed.">            if (tx != null) results.add(tx);</span>
<span class="nc bnc" id="L5315" title="All 4 branches missed.">        } while (tx != null &amp;&amp; tx.getInputs().size() == KeyTimeCoinSelector.MAX_SIMULTANEOUS_INPUTS);</span>
<span class="nc" id="L5316">        return results;</span>
    }

    @Nullable
    private Transaction rekeyOneBatch(long timeSecs, @Nullable KeyParameter aesKey, List&lt;Transaction&gt; others, boolean sign) {
<span class="nc" id="L5321">        lock.lock();</span>
        try {
            // Build the transaction using some custom logic for our special needs. Last parameter to
            // KeyTimeCoinSelector is whether to ignore pending transactions or not.
            //
            // We ignore pending outputs because trying to rotate these is basically racing an attacker, and
            // we're quite likely to lose and create stuck double spends. Also, some users who have 0.9 wallets
            // have already got stuck double spends in their wallet due to the Bloom-filtering block reordering
            // bug that was fixed in 0.10, thus, making a re-key transaction depend on those would cause it to
            // never confirm at all.
<span class="nc" id="L5331">            CoinSelector keyTimeSelector = new KeyTimeCoinSelector(this, timeSecs, true);</span>
<span class="nc" id="L5332">            FilteringCoinSelector selector = new FilteringCoinSelector(keyTimeSelector);</span>
<span class="nc bnc" id="L5333" title="All 2 branches missed.">            for (Transaction other : others)</span>
<span class="nc" id="L5334">                selector.excludeOutputsSpentBy(other);</span>
            // TODO: Make this use the standard SendRequest.
<span class="nc" id="L5336">            CoinSelection toMove = selector.select(Coin.ZERO, calculateAllSpendCandidates());</span>
<span class="nc bnc" id="L5337" title="All 2 branches missed.">            if (toMove.valueGathered.equals(Coin.ZERO)) return null;  // Nothing to do.</span>
<span class="nc" id="L5338">            maybeUpgradeToHD(aesKey);</span>
<span class="nc" id="L5339">            Transaction rekeyTx = new Transaction(params);</span>
<span class="nc bnc" id="L5340" title="All 2 branches missed.">            for (TransactionOutput output : toMove.gathered) {</span>
<span class="nc" id="L5341">                rekeyTx.addInput(output);</span>
<span class="nc" id="L5342">            }</span>
            // When not signing, don't waste addresses.
<span class="nc bnc" id="L5344" title="All 2 branches missed.">            rekeyTx.addOutput(toMove.valueGathered, sign ? freshReceiveAddress() : currentReceiveAddress());</span>
<span class="nc bnc" id="L5345" title="All 2 branches missed.">            if (!adjustOutputDownwardsForFee(rekeyTx, toMove, Transaction.DEFAULT_TX_FEE, true, false)) {</span>
<span class="nc" id="L5346">                log.error(&quot;Failed to adjust rekey tx for fees.&quot;);</span>
<span class="nc" id="L5347">                return null;</span>
            }
<span class="nc" id="L5349">            rekeyTx.getConfidence().setSource(TransactionConfidence.Source.SELF);</span>
<span class="nc" id="L5350">            rekeyTx.setPurpose(Transaction.Purpose.KEY_ROTATION);</span>
<span class="nc" id="L5351">            SendRequest req = SendRequest.forTx(rekeyTx);</span>
<span class="nc" id="L5352">            req.aesKey = aesKey;</span>
<span class="nc bnc" id="L5353" title="All 2 branches missed.">            if (sign)</span>
<span class="nc" id="L5354">                signTransaction(req);</span>
            // KeyTimeCoinSelector should never select enough inputs to push us oversize.
<span class="nc bnc" id="L5356" title="All 2 branches missed.">            checkState(rekeyTx.unsafeBitcoinSerialize().length &lt; Transaction.MAX_STANDARD_TX_SIZE);</span>
<span class="nc" id="L5357">            return rekeyTx;</span>
<span class="nc" id="L5358">        } catch (VerificationException e) {</span>
<span class="nc" id="L5359">            throw new RuntimeException(e);  // Cannot happen.</span>
        } finally {
<span class="nc" id="L5361">            lock.unlock();</span>
<span class="nc" id="L5362">        }</span>
    }
    //endregion
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>