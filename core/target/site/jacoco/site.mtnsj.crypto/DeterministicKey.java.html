<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DeterministicKey.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mtnsj</a> &gt; <a href="index.source.html" class="el_package">site.mtnsj.crypto</a> &gt; <span class="el_source">DeterministicKey.java</span></div><h1>DeterministicKey.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Matija Mazi.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package site.mtnsj.crypto;

import site.mtnsj.core.*;

import com.google.common.base.MoreObjects;
import com.google.common.base.Objects;
import com.google.common.collect.ImmutableList;
import site.mtnsj.wallet.DeterministicKeyChain;
import org.spongycastle.crypto.params.KeyParameter;
import org.spongycastle.math.ec.ECPoint;

import javax.annotation.Nullable;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Comparator;

import static site.mtnsj.core.Utils.HEX;
import static com.google.common.base.Preconditions.*;

/**
 * A deterministic key is a node in a {@link DeterministicHierarchy}. As per
 * &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki&quot;&gt;the BIP 32 specification&lt;/a&gt; it is a pair
 * (key, chaincode). If you know its path in the tree and its chain code you can derive more keys from this. To obtain
 * one of these, you can call {@link HDKeyDerivation#createMasterPrivateKey(byte[])}.
 */
public class DeterministicKey extends ECKey {

    /** Sorts deterministic keys in the order of their child number. That's &lt;i&gt;usually&lt;/i&gt; the order used to derive them. */
<span class="fc" id="L47">    public static final Comparator&lt;ECKey&gt; CHILDNUM_ORDER = new Comparator&lt;ECKey&gt;() {</span>
        @Override
        public int compare(ECKey k1, ECKey k2) {
<span class="nc" id="L50">            ChildNumber cn1 = ((DeterministicKey) k1).getChildNumber();</span>
<span class="nc" id="L51">            ChildNumber cn2 = ((DeterministicKey) k2).getChildNumber();</span>
<span class="nc" id="L52">            return cn1.compareTo(cn2);</span>
        }
    };

    private final DeterministicKey parent;
    private final ImmutableList&lt;ChildNumber&gt; childNumberPath;
    private final int depth;
    private int parentFingerprint; // 0 if this key is root node of key hierarchy

    /** 32 bytes */
    private final byte[] chainCode;

    /** Constructs a key from its components. This is not normally something you should use. */
    public DeterministicKey(ImmutableList&lt;ChildNumber&gt; childNumberPath,
                            byte[] chainCode,
                            LazyECPoint publicAsPoint,
                            @Nullable BigInteger priv,
                            @Nullable DeterministicKey parent) {
<span class="fc" id="L70">        super(priv, compressPoint(checkNotNull(publicAsPoint)));</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        checkArgument(chainCode.length == 32);</span>
<span class="fc" id="L72">        this.parent = parent;</span>
<span class="fc" id="L73">        this.childNumberPath = checkNotNull(childNumberPath);</span>
<span class="fc" id="L74">        this.chainCode = Arrays.copyOf(chainCode, chainCode.length);</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">        this.depth = parent == null ? 0 : parent.depth + 1;</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">        this.parentFingerprint = (parent != null) ? parent.getFingerprint() : 0;</span>
<span class="fc" id="L77">    }</span>

    public DeterministicKey(ImmutableList&lt;ChildNumber&gt; childNumberPath,
                            byte[] chainCode,
                            ECPoint publicAsPoint,
                            @Nullable BigInteger priv,
                            @Nullable DeterministicKey parent) {
<span class="nc" id="L84">        this(childNumberPath, chainCode, new LazyECPoint(publicAsPoint), priv, parent);</span>
<span class="nc" id="L85">    }</span>

    /** Constructs a key from its components. This is not normally something you should use. */
    public DeterministicKey(ImmutableList&lt;ChildNumber&gt; childNumberPath,
                            byte[] chainCode,
                            BigInteger priv,
                            @Nullable DeterministicKey parent) {
<span class="fc" id="L92">        super(priv, compressPoint(ECKey.publicPointFromPrivate(priv)));</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        checkArgument(chainCode.length == 32);</span>
<span class="fc" id="L94">        this.parent = parent;</span>
<span class="fc" id="L95">        this.childNumberPath = checkNotNull(childNumberPath);</span>
<span class="fc" id="L96">        this.chainCode = Arrays.copyOf(chainCode, chainCode.length);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        this.depth = parent == null ? 0 : parent.depth + 1;</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        this.parentFingerprint = (parent != null) ? parent.getFingerprint() : 0;</span>
<span class="fc" id="L99">    }</span>

    /** Constructs a key from its components. This is not normally something you should use. */
    public DeterministicKey(ImmutableList&lt;ChildNumber&gt; childNumberPath,
                            byte[] chainCode,
                            KeyCrypter crypter,
                            LazyECPoint pub,
                            EncryptedData priv,
                            @Nullable DeterministicKey parent) {
<span class="nc" id="L108">        this(childNumberPath, chainCode, pub, null, parent);</span>
<span class="nc" id="L109">        this.encryptedPrivateKey = checkNotNull(priv);</span>
<span class="nc" id="L110">        this.keyCrypter = checkNotNull(crypter);</span>
<span class="nc" id="L111">    }</span>

    /**
     * Return the fingerprint of this key's parent as an int value, or zero if this key is the
     * root node of the key hierarchy.  Raise an exception if the arguments are inconsistent.
     * This method exists to avoid code repetition in the constructors.
     */
    private int ascertainParentFingerprint(DeterministicKey parentKey, int parentFingerprint)
    throws IllegalArgumentException {
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (parentFingerprint != 0) {</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">            if (parent != null)</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">                checkArgument(parent.getFingerprint() == parentFingerprint,</span>
                              &quot;parent fingerprint mismatch&quot;,
<span class="nc" id="L124">                              Integer.toHexString(parent.getFingerprint()), Integer.toHexString(parentFingerprint));</span>
<span class="nc" id="L125">            return parentFingerprint;</span>
<span class="nc" id="L126">        } else return 0;</span>
    }

    /**
     * Constructs a key from its components, including its public key data and possibly-redundant
     * information about its parent key.  Invoked when deserializing, but otherwise not something that
     * you normally should use.
     */
    private DeterministicKey(ImmutableList&lt;ChildNumber&gt; childNumberPath,
                            byte[] chainCode,
                            LazyECPoint publicAsPoint,
                            @Nullable DeterministicKey parent,
                            int depth,
                            int parentFingerprint) {
<span class="nc" id="L140">        super(null, compressPoint(checkNotNull(publicAsPoint)));</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        checkArgument(chainCode.length == 32);</span>
<span class="nc" id="L142">        this.parent = parent;</span>
<span class="nc" id="L143">        this.childNumberPath = checkNotNull(childNumberPath);</span>
<span class="nc" id="L144">        this.chainCode = Arrays.copyOf(chainCode, chainCode.length);</span>
<span class="nc" id="L145">        this.depth = depth;</span>
<span class="nc" id="L146">        this.parentFingerprint = ascertainParentFingerprint(parent, parentFingerprint);</span>
<span class="nc" id="L147">    }</span>

    /**
     * Constructs a key from its components, including its private key data and possibly-redundant
     * information about its parent key.  Invoked when deserializing, but otherwise not something that
     * you normally should use.
     */
    private DeterministicKey(ImmutableList&lt;ChildNumber&gt; childNumberPath,
                            byte[] chainCode,
                            BigInteger priv,
                            @Nullable DeterministicKey parent,
                            int depth,
                            int parentFingerprint) {
<span class="nc" id="L160">        super(priv, compressPoint(ECKey.publicPointFromPrivate(priv)));</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        checkArgument(chainCode.length == 32);</span>
<span class="nc" id="L162">        this.parent = parent;</span>
<span class="nc" id="L163">        this.childNumberPath = checkNotNull(childNumberPath);</span>
<span class="nc" id="L164">        this.chainCode = Arrays.copyOf(chainCode, chainCode.length);</span>
<span class="nc" id="L165">        this.depth = depth;</span>
<span class="nc" id="L166">        this.parentFingerprint = ascertainParentFingerprint(parent, parentFingerprint);</span>
<span class="nc" id="L167">    }</span>

    
    /** Clones the key */
    public DeterministicKey(DeterministicKey keyToClone, DeterministicKey newParent) {
<span class="nc" id="L172">        super(keyToClone.priv, keyToClone.pub.get());</span>
<span class="nc" id="L173">        this.parent = newParent;</span>
<span class="nc" id="L174">        this.childNumberPath = keyToClone.childNumberPath;</span>
<span class="nc" id="L175">        this.chainCode = keyToClone.chainCode;</span>
<span class="nc" id="L176">        this.encryptedPrivateKey = keyToClone.encryptedPrivateKey;</span>
<span class="nc" id="L177">        this.depth = this.childNumberPath.size();</span>
<span class="nc" id="L178">        this.parentFingerprint = this.parent.getFingerprint();</span>
<span class="nc" id="L179">    }</span>

    /**
     * Returns the path through some {@link DeterministicHierarchy} which reaches this keys position in the tree.
     * A path can be written as 1/2/1 which means the first child of the root, the second child of that node, then
     * the first child of that node.
     */
    public ImmutableList&lt;ChildNumber&gt; getPath() {
<span class="fc" id="L187">        return childNumberPath;</span>
    }

    /**
     * Returns the path of this key as a human readable string starting with M to indicate the master key.
     */
    public String getPathAsString() {
<span class="fc" id="L194">        return HDUtils.formatPath(getPath());</span>
    }

    /**
     * Return this key's depth in the hierarchy, where the root node is at depth zero.
     * This may be different than the number of segments in the path if this key was
     * deserialized without access to its parent.
     */
    public int getDepth() {
<span class="nc" id="L203">        return depth;</span>
    }

    /** Returns the last element of the path returned by {@link DeterministicKey#getPath()} */
    public ChildNumber getChildNumber() {
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        return childNumberPath.size() == 0 ? ChildNumber.ZERO : childNumberPath.get(childNumberPath.size() - 1);</span>
    }

    /**
     * Returns the chain code associated with this key. See the specification to learn more about chain codes.
     */
    public byte[] getChainCode() {
<span class="fc" id="L215">        return chainCode;</span>
    }

    /**
     * Returns RIPE-MD160(SHA256(pub key bytes)).
     */
    public byte[] getIdentifier() {
<span class="fc" id="L222">        return Utils.sha256hash160(getPubKey());</span>
    }

    /** Returns the first 32 bits of the result of {@link #getIdentifier()}. */
    public int getFingerprint() {
        // TODO: why is this different than armory's fingerprint? BIP 32: &quot;The first 32 bits of the identifier are called the fingerprint.&quot;
<span class="fc" id="L228">        return ByteBuffer.wrap(Arrays.copyOfRange(getIdentifier(), 0, 4)).getInt();</span>
    }

    @Nullable
    public DeterministicKey getParent() {
<span class="fc" id="L233">        return parent;</span>
    }

    /**
     * Return the fingerprint of the key from which this key was derived, if this is a
     * child key, or else an array of four zero-value bytes.
     */
    public int getParentFingerprint() {
<span class="nc" id="L241">        return parentFingerprint;</span>
    }

    /**
     * Returns private key bytes, padded with zeros to 33 bytes.
     * @throws java.lang.IllegalStateException if the private key bytes are missing.
     */
    public byte[] getPrivKeyBytes33() {
<span class="fc" id="L249">        byte[] bytes33 = new byte[33];</span>
<span class="fc" id="L250">        byte[] priv = getPrivKeyBytes();</span>
<span class="fc" id="L251">        System.arraycopy(priv, 0, bytes33, 33 - priv.length, priv.length);</span>
<span class="fc" id="L252">        return bytes33;</span>
    }

    /**
     * Returns the same key with the private bytes removed. May return the same instance. The purpose of this is to save
     * memory: the private key can always be very efficiently rederived from a parent that a private key, so storing
     * all the private keys in RAM is a poor tradeoff especially on constrained devices. This means that the returned
     * key may still be usable for signing and so on, so don't expect it to be a true pubkey-only object! If you want
     * that then you should follow this call with a call to {@link #dropParent()}.
     */
    public DeterministicKey dropPrivateBytes() {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (isPubKeyOnly())</span>
<span class="nc" id="L264">            return this;</span>
        else
<span class="fc" id="L266">            return new DeterministicKey(getPath(), getChainCode(), pub, null, parent);</span>
    }

    /**
     * &lt;p&gt;Returns the same key with the parent pointer removed (it still knows its own path and the parent fingerprint).&lt;/p&gt;
     *
     * &lt;p&gt;If this key doesn't have private key bytes stored/cached itself, but could rederive them from the parent, then
     * the new key returned by this method won't be able to do that. Thus, using dropPrivateBytes().dropParent() on a
     * regular DeterministicKey will yield a new DeterministicKey that cannot sign or do other things involving the
     * private key at all.&lt;/p&gt;
     */
    public DeterministicKey dropParent() {
<span class="nc" id="L278">        DeterministicKey key = new DeterministicKey(getPath(), getChainCode(), pub, priv, null);</span>
<span class="nc" id="L279">        key.parentFingerprint = parentFingerprint;</span>
<span class="nc" id="L280">        return key;</span>
    }

    static byte[] addChecksum(byte[] input) {
<span class="nc" id="L284">        int inputLength = input.length;</span>
<span class="nc" id="L285">        byte[] checksummed = new byte[inputLength + 4];</span>
<span class="nc" id="L286">        System.arraycopy(input, 0, checksummed, 0, inputLength);</span>
<span class="nc" id="L287">        byte[] checksum = Sha256Hash.hashTwice(input);</span>
<span class="nc" id="L288">        System.arraycopy(checksum, 0, checksummed, inputLength, 4);</span>
<span class="nc" id="L289">        return checksummed;</span>
    }

    @Override
    public DeterministicKey encrypt(KeyCrypter keyCrypter, KeyParameter aesKey) throws KeyCrypterException {
<span class="nc" id="L294">        throw new UnsupportedOperationException(&quot;Must supply a new parent for encryption&quot;);</span>
    }

    public DeterministicKey encrypt(KeyCrypter keyCrypter, KeyParameter aesKey, @Nullable DeterministicKey newParent) throws KeyCrypterException {
        // Same as the parent code, except we construct a DeterministicKey instead of an ECKey.
<span class="nc" id="L299">        checkNotNull(keyCrypter);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (newParent != null)</span>
<span class="nc" id="L301">            checkArgument(newParent.isEncrypted());</span>
<span class="nc" id="L302">        final byte[] privKeyBytes = getPrivKeyBytes();</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">        checkState(privKeyBytes != null, &quot;Private key is not available&quot;);</span>
<span class="nc" id="L304">        EncryptedData encryptedPrivateKey = keyCrypter.encrypt(privKeyBytes, aesKey);</span>
<span class="nc" id="L305">        DeterministicKey key = new DeterministicKey(childNumberPath, chainCode, keyCrypter, pub, encryptedPrivateKey, newParent);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (newParent == null)</span>
<span class="nc" id="L307">            key.setCreationTimeSeconds(getCreationTimeSeconds());</span>
<span class="nc" id="L308">        return key;</span>
    }

    /**
     * A deterministic key is considered to be 'public key only' if it hasn't got a private key part and it cannot be
     * rederived. If the hierarchy is encrypted this returns true.
     */
    @Override
    public boolean isPubKeyOnly() {
<span class="pc bpc" id="L317" title="2 of 6 branches missed.">        return super.isPubKeyOnly() &amp;&amp; (parent == null || parent.isPubKeyOnly());</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean hasPrivKey() {
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">        return findParentWithPrivKey() != null;</span>
    }

    @Nullable
    @Override
    public byte[] getSecretBytes() {
<span class="fc bfc" id="L329" title="All 2 branches covered.">        return priv != null ? getPrivKeyBytes() : null;</span>
    }

    /**
     * A deterministic key is considered to be encrypted if it has access to encrypted private key bytes, OR if its
     * parent does. The reason is because the parent would be encrypted under the same key and this key knows how to
     * rederive its own private key bytes from the parent, if needed.
     */
    @Override
    public boolean isEncrypted() {
<span class="pc bpc" id="L339" title="3 of 8 branches missed.">        return priv == null &amp;&amp; (super.isEncrypted() || (parent != null &amp;&amp; parent.isEncrypted()));</span>
    }

    /**
     * Returns this keys {@link site.mtnsj.crypto.KeyCrypter} &lt;b&gt;or&lt;/b&gt; the keycrypter of its parent key.
     */
    @Override @Nullable
    public KeyCrypter getKeyCrypter() {
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (keyCrypter != null)</span>
<span class="nc" id="L348">            return keyCrypter;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        else if (parent != null)</span>
<span class="nc" id="L350">            return parent.getKeyCrypter();</span>
        else
<span class="nc" id="L352">            return null;</span>
    }

    @Override
    public ECDSASignature sign(Sha256Hash input, @Nullable KeyParameter aesKey) throws KeyCrypterException {
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">        if (isEncrypted()) {</span>
            // If the key is encrypted, ECKey.sign will decrypt it first before rerunning sign. Decryption walks the
            // key heirarchy to find the private key (see below), so, we can just run the inherited method.
<span class="nc" id="L360">            return super.sign(input, aesKey);</span>
        } else {
            // If it's not encrypted, derive the private via the parents.
<span class="fc" id="L363">            final BigInteger privateKey = findOrDerivePrivateKey();</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">            if (privateKey == null) {</span>
                // This key is a part of a public-key only heirarchy and cannot be used for signing
<span class="nc" id="L366">                throw new MissingPrivateKeyException();</span>
            }
<span class="fc" id="L368">            return super.doSign(input, privateKey);</span>
        }
    }

    @Override
    public DeterministicKey decrypt(KeyCrypter keyCrypter, KeyParameter aesKey) throws KeyCrypterException {
<span class="nc" id="L374">        checkNotNull(keyCrypter);</span>
        // Check that the keyCrypter matches the one used to encrypt the keys, if set.
<span class="nc bnc" id="L376" title="All 4 branches missed.">        if (this.keyCrypter != null &amp;&amp; !this.keyCrypter.equals(keyCrypter))</span>
<span class="nc" id="L377">            throw new KeyCrypterException(&quot;The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it&quot;);</span>
<span class="nc" id="L378">        BigInteger privKey = findOrDeriveEncryptedPrivateKey(keyCrypter, aesKey);</span>
<span class="nc" id="L379">        DeterministicKey key = new DeterministicKey(childNumberPath, chainCode, privKey, parent);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (!Arrays.equals(key.getPubKey(), getPubKey()))</span>
<span class="nc" id="L381">            throw new KeyCrypterException(&quot;Provided AES key is wrong&quot;);</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">        if (parent == null)</span>
<span class="nc" id="L383">            key.setCreationTimeSeconds(getCreationTimeSeconds());</span>
<span class="nc" id="L384">        return key;</span>
    }

    @Override
    public DeterministicKey decrypt(KeyParameter aesKey) throws KeyCrypterException {
<span class="nc" id="L389">        return (DeterministicKey) super.decrypt(aesKey);</span>
    }

    // For when a key is encrypted, either decrypt our encrypted private key bytes, or work up the tree asking parents
    // to decrypt and re-derive.
    private BigInteger findOrDeriveEncryptedPrivateKey(KeyCrypter keyCrypter, KeyParameter aesKey) {
<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (encryptedPrivateKey != null)</span>
<span class="nc" id="L396">            return new BigInteger(1, keyCrypter.decrypt(encryptedPrivateKey, aesKey));</span>
        // Otherwise we don't have it, but maybe we can figure it out from our parents. Walk up the tree looking for
        // the first key that has some encrypted private key data.
<span class="nc" id="L399">        DeterministicKey cursor = parent;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        while (cursor != null) {</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">            if (cursor.encryptedPrivateKey != null) break;</span>
<span class="nc" id="L402">            cursor = cursor.parent;</span>
        }
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (cursor == null)</span>
<span class="nc" id="L405">            throw new KeyCrypterException(&quot;Neither this key nor its parents have an encrypted private key&quot;);</span>
<span class="nc" id="L406">        byte[] parentalPrivateKeyBytes = keyCrypter.decrypt(cursor.encryptedPrivateKey, aesKey);</span>
<span class="nc" id="L407">        return derivePrivateKeyDownwards(cursor, parentalPrivateKeyBytes);</span>
    }

    private DeterministicKey findParentWithPrivKey() {
<span class="fc" id="L411">        DeterministicKey cursor = this;</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        while (cursor != null) {</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">            if (cursor.priv != null) break;</span>
<span class="fc" id="L414">            cursor = cursor.parent;</span>
        }
<span class="fc" id="L416">        return cursor;</span>
    }

    @Nullable
    private BigInteger findOrDerivePrivateKey() {
<span class="fc" id="L421">        DeterministicKey cursor = findParentWithPrivKey();</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">        if (cursor == null)</span>
<span class="nc" id="L423">            return null;</span>
<span class="fc" id="L424">        return derivePrivateKeyDownwards(cursor, cursor.priv.toByteArray());</span>
    }

    private BigInteger derivePrivateKeyDownwards(DeterministicKey cursor, byte[] parentalPrivateKeyBytes) {
<span class="fc" id="L428">        DeterministicKey downCursor = new DeterministicKey(cursor.childNumberPath, cursor.chainCode,</span>
                cursor.pub, new BigInteger(1, parentalPrivateKeyBytes), cursor.parent);
        // Now we have to rederive the keys along the path back to ourselves. That path can be found by just truncating
        // our path with the length of the parents path.
<span class="fc" id="L432">        ImmutableList&lt;ChildNumber&gt; path = childNumberPath.subList(cursor.getPath().size(), childNumberPath.size());</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">        for (ChildNumber num : path) {</span>
<span class="fc" id="L434">            downCursor = HDKeyDerivation.deriveChildKey(downCursor, num);</span>
<span class="fc" id="L435">        }</span>
        // downCursor is now the same key as us, but with private key bytes.
        // If it's not, it means we tried decrypting with an invalid password and earlier checks e.g. for padding didn't
        // catch it.
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">        if (!downCursor.pub.equals(pub))</span>
<span class="nc" id="L440">            throw new KeyCrypterException(&quot;Could not decrypt bytes&quot;);</span>
<span class="fc" id="L441">        return checkNotNull(downCursor.priv);</span>
    }

    /**
     * Derives a child at the given index using hardened derivation.  Note: &lt;code&gt;index&lt;/code&gt; is
     * not the &quot;i&quot; value.  If you want the softened derivation, then use instead
     * &lt;code&gt;HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, false))&lt;/code&gt;.
     */
    public DeterministicKey derive(int child) {
<span class="nc" id="L450">        return HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, true));</span>
    }

    /**
     * Returns the private key of this deterministic key. Even if this object isn't storing the private key,
     * it can be re-derived by walking up to the parents if necessary and this is what will happen.
     * @throws java.lang.IllegalStateException if the parents are encrypted or a watching chain.
     */
    @Override
    public BigInteger getPrivKey() {
<span class="fc" id="L460">        final BigInteger key = findOrDerivePrivateKey();</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">        checkState(key != null, &quot;Private key bytes not available&quot;);</span>
<span class="fc" id="L462">        return key;</span>
    }

    public byte[] serializePublic(NetworkParameters params) {
<span class="nc" id="L466">        return serialize(params, true);</span>
    }

    public byte[] serializePrivate(NetworkParameters params) {
<span class="nc" id="L470">        return serialize(params, false);</span>
    }

    private byte[] serialize(NetworkParameters params, boolean pub) {
<span class="nc" id="L474">        ByteBuffer ser = ByteBuffer.allocate(78);</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">        ser.putInt(pub ? params.getBip32HeaderPub() : params.getBip32HeaderPriv());</span>
<span class="nc" id="L476">        ser.put((byte) getDepth());</span>
<span class="nc" id="L477">        ser.putInt(getParentFingerprint());</span>
<span class="nc" id="L478">        ser.putInt(getChildNumber().i());</span>
<span class="nc" id="L479">        ser.put(getChainCode());</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">        ser.put(pub ? getPubKey() : getPrivKeyBytes33());</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">        checkState(ser.position() == 78);</span>
<span class="nc" id="L482">        return ser.array();</span>
    }

    public String serializePubB58(NetworkParameters params) {
<span class="nc" id="L486">        return toBase58(serialize(params, true));</span>
    }

    public String serializePrivB58(NetworkParameters params) {
<span class="nc" id="L490">        return toBase58(serialize(params, false));</span>
    }

    static String toBase58(byte[] ser) {
<span class="nc" id="L494">        return Base58.encode(addChecksum(ser));</span>
    }

    /** Deserialize a base-58-encoded HD Key with no parent */
    public static DeterministicKey deserializeB58(String base58, NetworkParameters params) {
<span class="nc" id="L499">        return deserializeB58(null, base58, params);</span>
    }

    /**
      * Deserialize a base-58-encoded HD Key.
      *  @param parent The parent node in the given key's deterministic hierarchy.
      *  @throws IllegalArgumentException if the base58 encoded key could not be parsed.
      */
    public static DeterministicKey deserializeB58(@Nullable DeterministicKey parent, String base58, NetworkParameters params) {
<span class="nc" id="L508">        return deserialize(params, Base58.decodeChecked(base58), parent, DeterministicKeyChain.KeyChainType.BIP32);</span>
    }

    public static DeterministicKey deserializeB58(@Nullable DeterministicKey parent, String base58, NetworkParameters params, DeterministicKeyChain.KeyChainType keyChainType) {
<span class="nc" id="L512">        return deserialize(params, Base58.decodeChecked(base58), parent, keyChainType);</span>
    }

    /**
      * Deserialize an HD Key with no parent
      */
    public static DeterministicKey deserialize(NetworkParameters params, byte[] serializedKey) {
<span class="nc" id="L519">        return deserialize(params, serializedKey, null, DeterministicKeyChain.KeyChainType.BIP32);</span>
    }

    /**
      * Deserialize an HD Key.
     * @param parent The parent node in the given key's deterministic hierarchy.
     */
    public static DeterministicKey deserialize(NetworkParameters params, byte[] serializedKey, @Nullable DeterministicKey parent, DeterministicKeyChain.KeyChainType keyChainType) {
<span class="nc" id="L527">        ByteBuffer buffer = ByteBuffer.wrap(serializedKey);</span>
<span class="nc" id="L528">        int header = buffer.getInt();</span>
<span class="nc bnc" id="L529" title="All 4 branches missed.">        if (header != params.getBip32HeaderPriv() &amp;&amp; header != params.getBip32HeaderPub())</span>
<span class="nc" id="L530">            throw new IllegalArgumentException(&quot;Unknown header bytes: &quot; + toBase58(serializedKey).substring(0, 4));</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">        boolean pub = header == params.getBip32HeaderPub();</span>
<span class="nc" id="L532">        int depth = buffer.get() &amp; 0xFF; // convert signed byte to positive int since depth cannot be negative</span>
<span class="nc" id="L533">        final int parentFingerprint = buffer.getInt();</span>
<span class="nc" id="L534">        final int i = buffer.getInt();</span>
<span class="nc" id="L535">        final ChildNumber childNumber = new ChildNumber(i);</span>
        ImmutableList&lt;ChildNumber&gt; path;
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">            if (parentFingerprint == 0)</span>
<span class="nc" id="L539">                throw new IllegalArgumentException(&quot;Parent was provided but this key doesn't have one&quot;);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            if (parent.getFingerprint() != parentFingerprint)</span>
<span class="nc" id="L541">                throw new IllegalArgumentException(&quot;Parent fingerprints don't match&quot;);</span>
<span class="nc" id="L542">            path = HDUtils.append(parent.getPath(), childNumber);</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">            if (path.size() != depth)</span>
<span class="nc" id="L544">                throw new IllegalArgumentException(&quot;Depth does not match&quot;);</span>
        } else {
<span class="nc bnc" id="L546" title="All 2 branches missed.">            if (depth &gt;= 1)</span>
                // We have been given a key that is not a root key, yet we lack the object representing the parent.
                // This can happen when deserializing an account key for a watching wallet.  In this case, we assume that
                // the client wants to conceal the key's position in the hierarchy.  The path is truncated at the
                // parent's node.
<span class="nc bnc" id="L551" title="All 2 branches missed.">                if (keyChainType == DeterministicKeyChain.KeyChainType.BIP44_MTNS_ONLY){</span>
                    // this is for bip44 only
<span class="nc" id="L553">                    path = HDUtils.append(DeterministicKeyChain.BIP44_ACCOUNT_ZERO_PATH,childNumber);</span>
                }else
<span class="nc" id="L555">                    path = ImmutableList.of(childNumber);</span>
<span class="nc" id="L556">            else path = ImmutableList.of();</span>
        }
<span class="nc" id="L558">        byte[] chainCode = new byte[32];</span>
<span class="nc" id="L559">        buffer.get(chainCode);</span>
<span class="nc" id="L560">        byte[] data = new byte[33];</span>
<span class="nc" id="L561">        buffer.get(data);</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">        checkArgument(!buffer.hasRemaining(), &quot;Found unexpected data in key&quot;);</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">        if (pub) {</span>
<span class="nc" id="L564">            return new DeterministicKey(path, chainCode, new LazyECPoint(ECKey.CURVE.getCurve(), data), parent, depth, parentFingerprint);</span>
        } else {
<span class="nc" id="L566">            return new DeterministicKey(path, chainCode, new BigInteger(1, data), parent, depth, parentFingerprint);</span>
        }
    }

    /**
     * The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree
     * in which case the time is stored alongside the key as per normal, see {@link site.mtnsj.core.ECKey#getCreationTimeSeconds()}.
     */
    @Override
    public long getCreationTimeSeconds() {
<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (parent != null)</span>
<span class="fc" id="L577">            return parent.getCreationTimeSeconds();</span>
        else
<span class="fc" id="L579">            return super.getCreationTimeSeconds();</span>
    }

    /**
     * The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree.
     * Thus, setting the creation time on a leaf is forbidden.
     */
    @Override
    public void setCreationTimeSeconds(long newCreationTimeSeconds) {
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">        if (parent != null)</span>
<span class="nc" id="L589">            throw new IllegalStateException(&quot;Creation time can only be set on root keys.&quot;);</span>
        else
<span class="fc" id="L591">            super.setCreationTimeSeconds(newCreationTimeSeconds);</span>
<span class="fc" id="L592">    }</span>

    /**
     * Verifies equality of all fields but NOT the parent pointer (thus the same key derived in two separate heirarchy
     * objects will equal each other.
     */
    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L600" title="All 2 branches covered.">        if (this == o) return true;</span>
<span class="pc bpc" id="L601" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L602">        DeterministicKey other = (DeterministicKey) o;</span>
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">        return super.equals(other)</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">                &amp;&amp; Arrays.equals(this.chainCode, other.chainCode)</span>
<span class="pc bnc" id="L605" title="All 2 branches missed.">                &amp;&amp; Objects.equal(this.childNumberPath, other.childNumberPath);</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L610">        return Objects.hashCode(super.hashCode(), Arrays.hashCode(chainCode), childNumberPath);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L615">        final MoreObjects.ToStringHelper helper = MoreObjects.toStringHelper(this).omitNullValues();</span>
<span class="nc" id="L616">        helper.add(&quot;pub&quot;, Utils.HEX.encode(pub.getEncoded()));</span>
<span class="nc" id="L617">        helper.add(&quot;chainCode&quot;, HEX.encode(chainCode));</span>
<span class="nc" id="L618">        helper.add(&quot;path&quot;, getPathAsString());</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">        if (creationTimeSeconds &gt; 0)</span>
<span class="nc" id="L620">            helper.add(&quot;creationTimeSeconds&quot;, creationTimeSeconds);</span>
<span class="nc" id="L621">        helper.add(&quot;isEncrypted&quot;, isEncrypted());</span>
<span class="nc" id="L622">        helper.add(&quot;isPubKeyOnly&quot;, isPubKeyOnly());</span>
<span class="nc" id="L623">        return helper.toString();</span>
    }

    @Override
    public void formatKeyWithAddress(boolean includePrivateKeys, StringBuilder builder, NetworkParameters params) {
<span class="nc" id="L628">        final Address address = toAddress(params);</span>
<span class="nc" id="L629">        builder.append(&quot;  addr:&quot;).append(address);</span>
<span class="nc" id="L630">        builder.append(&quot;  hash160:&quot;).append(Utils.HEX.encode(getPubKeyHash()));</span>
<span class="nc" id="L631">        builder.append(&quot;  (&quot;).append(getPathAsString()).append(&quot;)\n&quot;);</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (includePrivateKeys) {</span>
<span class="nc" id="L633">            builder.append(&quot;  &quot;).append(toStringWithPrivate(params)).append(&quot;\n&quot;);</span>
        }
<span class="nc" id="L635">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>