<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Script.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mtnsj</a> &gt; <a href="index.source.html" class="el_package">site.mtnsj.script</a> &gt; <span class="el_source">Script.java</span></div><h1>Script.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2011 Google Inc.
 * Copyright 2012 Matt Corallo.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package site.mtnsj.script;

import site.mtnsj.core.*;
import site.mtnsj.crypto.TransactionSignature;
import com.google.common.collect.Lists;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.spongycastle.crypto.digests.RIPEMD160Digest;

import javax.annotation.Nullable;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

import static site.mtnsj.script.ScriptOpCodes.*;
import static com.google.common.base.Preconditions.*;

// TODO: Redesign this entire API to be more type safe and organised.

/**
 * &lt;p&gt;Programs embedded inside transactions that control redemption of payments.&lt;/p&gt;
 *
 * &lt;p&gt;Bitcoin transactions don't specify what they do directly. Instead &lt;a href=&quot;https://en.bitcoin.it/wiki/Script&quot;&gt;a
 * small binary stack language&lt;/a&gt; is used to define programs that when evaluated return whether the transaction
 * &quot;accepts&quot; or rejects the other transactions connected to it.&lt;/p&gt;
 *
 * &lt;p&gt;In SPV mode, scripts are not run, because that would require all transactions to be available and lightweight
 * clients don't have that data. In full mode, this class is used to run the interpreted language. It also has
 * static methods for building scripts.&lt;/p&gt;
 */
public class Script {

    /** Enumeration to encapsulate the type of this script. */
<span class="pc" id="L57">    public enum ScriptType {</span>
        // Do NOT change the ordering of the following definitions because their ordinals are stored in databases.
<span class="fc" id="L59">        NO_TYPE,</span>
<span class="fc" id="L60">        P2PKH,</span>
<span class="fc" id="L61">        PUB_KEY,</span>
<span class="fc" id="L62">        P2SH</span>
    }

    /** Flags to pass to {@link Script#correctlySpends(Transaction, long, Script, Set)}.
     * Note currently only P2SH, DERSIG and NULLDUMMY are actually supported.
     */
<span class="pc" id="L68">    public enum VerifyFlag {</span>
<span class="fc" id="L69">        P2SH, // Enable BIP16-style subscript evaluation.</span>
<span class="fc" id="L70">        STRICTENC, // Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.</span>
<span class="fc" id="L71">        DERSIG, // Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP66 rule 1)</span>
<span class="fc" id="L72">        LOW_S, // Passing a non-strict-DER signature or one with S &gt; order/2 to a checksig operation causes script failure</span>
<span class="fc" id="L73">        NULLDUMMY, // Verify dummy stack item consumed by CHECKMULTISIG is of zero-length.</span>
<span class="fc" id="L74">        SIGPUSHONLY, // Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).</span>
<span class="fc" id="L75">        MINIMALDATA, // Require minimal encodings for all push operations</span>
<span class="fc" id="L76">        DISCOURAGE_UPGRADABLE_NOPS, // Discourage use of NOPs reserved for upgrades (NOP1-10)</span>
<span class="fc" id="L77">        CLEANSTACK, // Require that only a single stack element remains after evaluation.</span>
<span class="fc" id="L78">        CHECKLOCKTIMEVERIFY // Enable CHECKLOCKTIMEVERIFY operation</span>
    }
<span class="fc" id="L80">    public static final EnumSet&lt;VerifyFlag&gt; ALL_VERIFY_FLAGS = EnumSet.allOf(VerifyFlag.class);</span>

<span class="fc" id="L82">    private static final Logger log = LoggerFactory.getLogger(Script.class);</span>
    public static final long MAX_SCRIPT_ELEMENT_SIZE = 520;  // bytes
    public static final int SIG_SIZE = 75;
    /** Max number of sigops allowed in a standard p2sh redeem script */
    public static final int MAX_P2SH_SIGOPS = 15;

    // The program is a set of chunks where each element is either [opcode] or [data, data, data ...]
    protected List&lt;ScriptChunk&gt; chunks;
    // Unfortunately, scripts are not ever re-serialized or canonicalized when used in signature hashing. Thus we
    // must preserve the exact bytes that we read off the wire, along with the parsed form.
    protected byte[] program;

    // Creation time of the associated keys in seconds since the epoch.
    private long creationTimeSeconds;

    /** Creates an empty script that serializes to nothing. */
<span class="fc" id="L98">    private Script() {</span>
<span class="fc" id="L99">        chunks = Lists.newArrayList();</span>
<span class="fc" id="L100">    }</span>

    // Used from ScriptBuilder.
<span class="fc" id="L103">    Script(List&lt;ScriptChunk&gt; chunks) {</span>
<span class="fc" id="L104">        this.chunks = Collections.unmodifiableList(new ArrayList&lt;ScriptChunk&gt;(chunks));</span>
<span class="fc" id="L105">        creationTimeSeconds = Utils.currentTimeSeconds();</span>
<span class="fc" id="L106">    }</span>

    /**
     * Construct a Script that copies and wraps the programBytes array. The array is parsed and checked for syntactic
     * validity.
     * @param programBytes Array of program bytes from a transaction.
     */
<span class="fc" id="L113">    public Script(byte[] programBytes) throws ScriptException {</span>
<span class="fc" id="L114">        program = programBytes;</span>
<span class="fc" id="L115">        parse(programBytes);</span>
<span class="fc" id="L116">        creationTimeSeconds = 0;</span>
<span class="fc" id="L117">    }</span>

<span class="nc" id="L119">    public Script(byte[] programBytes, long creationTimeSeconds) throws ScriptException {</span>
<span class="nc" id="L120">        program = programBytes;</span>
<span class="nc" id="L121">        parse(programBytes);</span>
<span class="nc" id="L122">        this.creationTimeSeconds = creationTimeSeconds;</span>
<span class="nc" id="L123">    }</span>

    public long getCreationTimeSeconds() {
<span class="nc" id="L126">        return creationTimeSeconds;</span>
    }

    public void setCreationTimeSeconds(long creationTimeSeconds) {
<span class="nc" id="L130">        this.creationTimeSeconds = creationTimeSeconds;</span>
<span class="nc" id="L131">    }</span>

    /**
     * Returns the program opcodes as a string, for example &quot;[1234] DUP HASH160&quot;
     */
    @Override
    public String toString() {
<span class="fc" id="L138">        return Utils.join(chunks);</span>
    }

    /** Returns the serialized program as a newly created byte array. */
    public byte[] getProgram() {
        try {
            // Don't round-trip as Bitcoin Core doesn't and it would introduce a mismatch.
<span class="fc bfc" id="L145" title="All 2 branches covered.">            if (program != null)</span>
<span class="fc" id="L146">                return Arrays.copyOf(program, program.length);</span>
<span class="fc" id="L147">            ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">            for (ScriptChunk chunk : chunks) {</span>
<span class="fc" id="L149">                chunk.write(bos);</span>
<span class="fc" id="L150">            }</span>
<span class="fc" id="L151">            program = bos.toByteArray();</span>
<span class="fc" id="L152">            return program;</span>
<span class="nc" id="L153">        } catch (IOException e) {</span>
<span class="nc" id="L154">            throw new RuntimeException(e);  // Cannot happen.</span>
        }
    }

    /** Returns an immutable list of the scripts parsed form. Each chunk is either an opcode or data element. */
    public List&lt;ScriptChunk&gt; getChunks() {
<span class="fc" id="L160">        return Collections.unmodifiableList(chunks);</span>
    }

<span class="fc" id="L163">    private static final ScriptChunk[] STANDARD_TRANSACTION_SCRIPT_CHUNKS = {</span>
        new ScriptChunk(ScriptOpCodes.OP_DUP, null, 0),
        new ScriptChunk(ScriptOpCodes.OP_HASH160, null, 1),
        new ScriptChunk(ScriptOpCodes.OP_EQUALVERIFY, null, 23),
        new ScriptChunk(ScriptOpCodes.OP_CHECKSIG, null, 24),
    };

    /**
     * &lt;p&gt;To run a script, first we parse it which breaks it up into chunks representing pushes of data or logical
     * opcodes. Then we can run the parsed chunks.&lt;/p&gt;
     *
     * &lt;p&gt;The reason for this split, instead of just interpreting directly, is to make it easier
     * to reach into a programs structure and pull out bits of data without having to run it.
     * This is necessary to render the to/from addresses of transactions in a user interface.
     * Bitcoin Core does something similar.&lt;/p&gt;
     */
    private void parse(byte[] program) throws ScriptException {
<span class="fc" id="L180">        chunks = new ArrayList&lt;ScriptChunk&gt;(5);   // Common size.</span>
<span class="fc" id="L181">        ByteArrayInputStream bis = new ByteArrayInputStream(program);</span>
<span class="fc" id="L182">        int initialSize = bis.available();</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        while (bis.available() &gt; 0) {</span>
<span class="fc" id="L184">            int startLocationInProgram = initialSize - bis.available();</span>
<span class="fc" id="L185">            int opcode = bis.read();</span>

<span class="fc" id="L187">            long dataToRead = -1;</span>
<span class="pc bpc" id="L188" title="1 of 4 branches missed.">            if (opcode &gt;= 0 &amp;&amp; opcode &lt; OP_PUSHDATA1) {</span>
                // Read some bytes of data, where how many is the opcode value itself.
<span class="fc" id="L190">                dataToRead = opcode;</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">            } else if (opcode == OP_PUSHDATA1) {</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                if (bis.available() &lt; 1) throw new ScriptException(&quot;Unexpected end of script&quot;);</span>
<span class="nc" id="L193">                dataToRead = bis.read();</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">            } else if (opcode == OP_PUSHDATA2) {</span>
                // Read a short, then read that many bytes of data.
<span class="nc bnc" id="L196" title="All 2 branches missed.">                if (bis.available() &lt; 2) throw new ScriptException(&quot;Unexpected end of script&quot;);</span>
<span class="nc" id="L197">                dataToRead = bis.read() | (bis.read() &lt;&lt; 8);</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">            } else if (opcode == OP_PUSHDATA4) {</span>
                // Read a uint32, then read that many bytes of data.
                // Though this is allowed, because its value cannot be &gt; 520, it should never actually be used
<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (bis.available() &lt; 4) throw new ScriptException(&quot;Unexpected end of script&quot;);</span>
<span class="nc" id="L202">                dataToRead = ((long)bis.read()) | (((long)bis.read()) &lt;&lt; 8) | (((long)bis.read()) &lt;&lt; 16) | (((long)bis.read()) &lt;&lt; 24);</span>
            }

            ScriptChunk chunk;
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if (dataToRead == -1) {</span>
<span class="fc" id="L207">                chunk = new ScriptChunk(opcode, null, startLocationInProgram);</span>
            } else {
<span class="fc bfc" id="L209" title="All 2 branches covered.">                if (dataToRead &gt; bis.available())</span>
<span class="fc" id="L210">                    throw new ScriptException(&quot;Push of data element that is larger than remaining data&quot;);</span>
<span class="fc" id="L211">                byte[] data = new byte[(int)dataToRead];</span>
<span class="pc bpc" id="L212" title="1 of 4 branches missed.">                checkState(dataToRead == 0 || bis.read(data, 0, (int)dataToRead) == dataToRead);</span>
<span class="fc" id="L213">                chunk = new ScriptChunk(opcode, data, startLocationInProgram);</span>
            }
            // Save some memory by eliminating redundant copies of the same chunk objects.
<span class="fc bfc" id="L216" title="All 2 branches covered.">            for (ScriptChunk c : STANDARD_TRANSACTION_SCRIPT_CHUNKS) {</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                if (c.equals(chunk)) chunk = c;</span>
            }
<span class="fc" id="L219">            chunks.add(chunk);</span>
<span class="fc" id="L220">        }</span>
<span class="fc" id="L221">    }</span>

    /**
     * Returns true if this script is of the form &lt;pubkey&gt; OP_CHECKSIG. This form was originally intended for transactions
     * where the peers talked to each other directly via TCP/IP, but has fallen out of favor with time due to that mode
     * of operation being susceptible to man-in-the-middle attacks. It is still used in coinbase outputs and can be
     * useful more exotic types of transaction, but today most payments are to addresses.
     */
    public boolean isSentToRawPubKey() {
<span class="pc bpc" id="L230" title="1 of 4 branches missed.">        return chunks.size() == 2 &amp;&amp; chunks.get(1).equalsOpCode(OP_CHECKSIG) &amp;&amp;</span>
<span class="pc bpc" id="L231" title="2 of 4 branches missed.">               !chunks.get(0).isOpCode() &amp;&amp; chunks.get(0).data.length &gt; 1;</span>
    }

    /**
     * Returns true if this script is of the form DUP HASH160 &lt;pubkey hash&gt; EQUALVERIFY CHECKSIG, ie, payment to an
     * address like 1VayNert3x1KzbpzMGt2qdqrAThiRovi8. This form was originally intended for the case where you wish
     * to send somebody money with a written code because their node is offline, but over time has become the standard
     * way to make payments due to the short and recognizable base58 form addresses come in.
     */
    public boolean isSentToAddress() {
<span class="fc bfc" id="L241" title="All 2 branches covered.">        return chunks.size() == 5 &amp;&amp;</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">               chunks.get(0).equalsOpCode(OP_DUP) &amp;&amp;</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">               chunks.get(1).equalsOpCode(OP_HASH160) &amp;&amp;</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">               chunks.get(2).data.length == Address.LENGTH &amp;&amp;</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">               chunks.get(3).equalsOpCode(OP_EQUALVERIFY) &amp;&amp;</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">               chunks.get(4).equalsOpCode(OP_CHECKSIG);</span>
    }

    /**
     * An alias for isPayToScriptHash.
     */
    @Deprecated
    public boolean isSentToP2SH() {
<span class="nc" id="L254">        return isPayToScriptHash();</span>
    }

    /**
     * &lt;p&gt;If a program matches the standard template DUP HASH160 &amp;lt;pubkey hash&amp;gt; EQUALVERIFY CHECKSIG
     * then this function retrieves the third element.
     * In this case, this is useful for fetching the destination address of a transaction.&lt;/p&gt;
     * 
     * &lt;p&gt;If a program matches the standard template HASH160 &amp;lt;script hash&amp;gt; EQUAL
     * then this function retrieves the second element.
     * In this case, this is useful for fetching the hash of the redeem script of a transaction.&lt;/p&gt;
     * 
     * &lt;p&gt;Otherwise it throws a ScriptException.&lt;/p&gt;
     *
     */
    public byte[] getPubKeyHash() throws ScriptException {
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (isSentToAddress())</span>
<span class="fc" id="L271">            return chunks.get(2).data;</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">        else if (isPayToScriptHash())</span>
<span class="nc" id="L273">            return chunks.get(1).data;</span>
        else
<span class="nc" id="L275">            throw new ScriptException(&quot;Script not in the standard scriptPubKey form&quot;);</span>
    }

    /**
     * Returns the public key in this script. If a script contains two constants and nothing else, it is assumed to
     * be a scriptSig (input) for a pay-to-address output and the second constant is returned (the first is the
     * signature). If a script contains a constant and an OP_CHECKSIG opcode, the constant is returned as it is
     * assumed to be a direct pay-to-key scriptPubKey (output) and the first constant is the public key.
     *
     * @throws ScriptException if the script is none of the named forms.
     */
    public byte[] getPubKey() throws ScriptException {
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (chunks.size() != 2) {</span>
<span class="nc" id="L288">            throw new ScriptException(&quot;Script not of right size, expecting 2 but got &quot; + chunks.size());</span>
        }
<span class="fc" id="L290">        final ScriptChunk chunk0 = chunks.get(0);</span>
<span class="fc" id="L291">        final byte[] chunk0data = chunk0.data;</span>
<span class="fc" id="L292">        final ScriptChunk chunk1 = chunks.get(1);</span>
<span class="fc" id="L293">        final byte[] chunk1data = chunk1.data;</span>
<span class="pc bpc" id="L294" title="5 of 8 branches missed.">        if (chunk0data != null &amp;&amp; chunk0data.length &gt; 2 &amp;&amp; chunk1data != null &amp;&amp; chunk1data.length &gt; 2) {</span>
            // If we have two large constants assume the input to a pay-to-address output.
<span class="nc" id="L296">            return chunk1data;</span>
<span class="pc bpc" id="L297" title="3 of 6 branches missed.">        } else if (chunk1.equalsOpCode(OP_CHECKSIG) &amp;&amp; chunk0data != null &amp;&amp; chunk0data.length &gt; 2) {</span>
            // A large constant followed by an OP_CHECKSIG is the key.
<span class="fc" id="L299">            return chunk0data;</span>
        } else {
<span class="nc" id="L301">            throw new ScriptException(&quot;Script did not match expected form: &quot; + this);</span>
        }
    }

    /**
     * Retrieves the sender public key from a LOCKTIMEVERIFY transaction
     * @return
     * @throws ScriptException
     */
    public byte[] getCLTVPaymentChannelSenderPubKey() throws ScriptException {
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (!isSentToCLTVPaymentChannel()) {</span>
<span class="nc" id="L312">            throw new ScriptException(&quot;Script not a standard CHECKLOCKTIMVERIFY transaction: &quot; + this);</span>
        }
<span class="nc" id="L314">        return chunks.get(8).data;</span>
    }

    /**
     * Retrieves the recipient public key from a LOCKTIMEVERIFY transaction
     * @return
     * @throws ScriptException
     */
    public byte[] getCLTVPaymentChannelRecipientPubKey() throws ScriptException {
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (!isSentToCLTVPaymentChannel()) {</span>
<span class="nc" id="L324">            throw new ScriptException(&quot;Script not a standard CHECKLOCKTIMVERIFY transaction: &quot; + this);</span>
        }
<span class="nc" id="L326">        return chunks.get(1).data;</span>
    }

    public BigInteger getCLTVPaymentChannelExpiry() {
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (!isSentToCLTVPaymentChannel()) {</span>
<span class="nc" id="L331">            throw new ScriptException(&quot;Script not a standard CHECKLOCKTIMEVERIFY transaction: &quot; + this);</span>
        }
<span class="nc" id="L333">        return castToBigInteger(chunks.get(4).data, 5);</span>
    }

    /**
     * For 2-element [input] scripts assumes that the paid-to-address can be derived from the public key.
     * The concept of a &quot;from address&quot; isn't well defined in Bitcoin and you should not assume the sender of a
     * transaction can actually receive coins on it. This method may be removed in future.
     */
    @Deprecated
    public Address getFromAddress(NetworkParameters params) throws ScriptException {
<span class="nc" id="L343">        return new Address(params, Utils.sha256hash160(getPubKey()));</span>
    }

    /**
     * Gets the destination address from this script, if it's in the required form (see getPubKey).
     */
    public Address getToAddress(NetworkParameters params) throws ScriptException {
<span class="nc" id="L350">        return getToAddress(params, false);</span>
    }

    /**
     * Gets the destination address from this script, if it's in the required form (see getPubKey).
     * 
     * @param forcePayToPubKey
     *            If true, allow payToPubKey to be casted to the corresponding address. This is useful if you prefer
     *            showing addresses rather than pubkeys.
     */
    public Address getToAddress(NetworkParameters params, boolean forcePayToPubKey) throws ScriptException {
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        if (isSentToAddress())</span>
<span class="nc" id="L362">            return new Address(params, getPubKeyHash());</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">        else if (isPayToScriptHash())</span>
<span class="nc" id="L364">            return Address.fromP2SHScript(params, this);</span>
<span class="pc bpc" id="L365" title="1 of 4 branches missed.">        else if (forcePayToPubKey &amp;&amp; isSentToRawPubKey())</span>
<span class="fc" id="L366">            return ECKey.fromPublicOnly(getPubKey()).toAddress(params);</span>
        else
<span class="fc" id="L368">            throw new ScriptException(&quot;Cannot cast this script to a pay-to-address type&quot;);</span>
    }

    ////////////////////// Interface for writing scripts from scratch ////////////////////////////////

    /**
     * Writes out the given byte buffer to the output stream with the correct opcode prefix
     * To write an integer call writeBytes(out, Utils.reverseBytes(Utils.encodeMPI(val, false)));
     */
    public static void writeBytes(OutputStream os, byte[] buf) throws IOException {
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">        if (buf.length &lt; OP_PUSHDATA1) {</span>
<span class="fc" id="L379">            os.write(buf.length);</span>
<span class="fc" id="L380">            os.write(buf);</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">        } else if (buf.length &lt; 256) {</span>
<span class="nc" id="L382">            os.write(OP_PUSHDATA1);</span>
<span class="nc" id="L383">            os.write(buf.length);</span>
<span class="nc" id="L384">            os.write(buf);</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">        } else if (buf.length &lt; 65536) {</span>
<span class="nc" id="L386">            os.write(OP_PUSHDATA2);</span>
<span class="nc" id="L387">            os.write(0xFF &amp; (buf.length));</span>
<span class="nc" id="L388">            os.write(0xFF &amp; (buf.length &gt;&gt; 8));</span>
<span class="nc" id="L389">            os.write(buf);</span>
        } else {
<span class="nc" id="L391">            throw new RuntimeException(&quot;Unimplemented&quot;);</span>
        }
<span class="fc" id="L393">    }</span>

    /** Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. */
    public static byte[] createMultiSigOutputScript(int threshold, List&lt;ECKey&gt; pubkeys) {
<span class="nc bnc" id="L397" title="All 2 branches missed.">        checkArgument(threshold &gt; 0);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        checkArgument(threshold &lt;= pubkeys.size());</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">        checkArgument(pubkeys.size() &lt;= 16);  // That's the max we can represent with a single opcode.</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (pubkeys.size() &gt; 3) {</span>
<span class="nc" id="L401">            log.warn(&quot;Creating a multi-signature output that is non-standard: {} pubkeys, should be &lt;= 3&quot;, pubkeys.size());</span>
        }
        try {
<span class="nc" id="L404">            ByteArrayOutputStream bits = new ByteArrayOutputStream();</span>
<span class="nc" id="L405">            bits.write(encodeToOpN(threshold));</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            for (ECKey key : pubkeys) {</span>
<span class="nc" id="L407">                writeBytes(bits, key.getPubKey());</span>
<span class="nc" id="L408">            }</span>
<span class="nc" id="L409">            bits.write(encodeToOpN(pubkeys.size()));</span>
<span class="nc" id="L410">            bits.write(OP_CHECKMULTISIG);</span>
<span class="nc" id="L411">            return bits.toByteArray();</span>
<span class="nc" id="L412">        } catch (IOException e) {</span>
<span class="nc" id="L413">            throw new RuntimeException(e);  // Cannot happen.</span>
        }
    }

    public static byte[] createInputScript(byte[] signature, byte[] pubkey) {
        try {
            // TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
<span class="fc" id="L420">            ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(signature.length + pubkey.length + 2);</span>
<span class="fc" id="L421">            writeBytes(bits, signature);</span>
<span class="fc" id="L422">            writeBytes(bits, pubkey);</span>
<span class="fc" id="L423">            return bits.toByteArray();</span>
<span class="nc" id="L424">        } catch (IOException e) {</span>
<span class="nc" id="L425">            throw new RuntimeException(e);</span>
        }
    }

    public static byte[] createInputScript(byte[] signature) {
        try {
            // TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
<span class="fc" id="L432">            ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(signature.length + 2);</span>
<span class="fc" id="L433">            writeBytes(bits, signature);</span>
<span class="fc" id="L434">            return bits.toByteArray();</span>
<span class="nc" id="L435">        } catch (IOException e) {</span>
<span class="nc" id="L436">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Creates an incomplete scriptSig that, once filled with signatures, can redeem output containing this scriptPubKey.
     * Instead of the signatures resulting script has OP_0.
     * Having incomplete input script allows to pass around partially signed tx.
     * It is expected that this program later on will be updated with proper signatures.
     */
    public Script createEmptyInputScript(@Nullable ECKey key, @Nullable Script redeemScript) {
<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (isSentToAddress()) {</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">            checkArgument(key != null, &quot;Key required to create pay-to-address input script&quot;);</span>
<span class="fc" id="L449">            return ScriptBuilder.createInputScript(null, key);</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        } else if (isSentToRawPubKey()) {</span>
<span class="fc" id="L451">            return ScriptBuilder.createInputScript(null);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        } else if (isPayToScriptHash()) {</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">            checkArgument(redeemScript != null, &quot;Redeem script required to create P2SH input script&quot;);</span>
<span class="nc" id="L454">            return ScriptBuilder.createP2SHMultiSigInputScript(null, redeemScript);</span>
        } else {
<span class="nc" id="L456">            throw new ScriptException(&quot;Do not understand script type: &quot; + this);</span>
        }
    }

    /**
     * Returns a copy of the given scriptSig with the signature inserted in the given position.
     */
    public Script getScriptSigWithSignature(Script scriptSig, byte[] sigBytes, int index) {
<span class="fc" id="L464">        int sigsPrefixCount = 0;</span>
<span class="fc" id="L465">        int sigsSuffixCount = 0;</span>
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (isPayToScriptHash()) {</span>
<span class="nc" id="L467">            sigsPrefixCount = 1; // OP_0 &lt;sig&gt;* &lt;redeemScript&gt;</span>
<span class="nc" id="L468">            sigsSuffixCount = 1;</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">        } else if (isSentToMultiSig()) {</span>
<span class="nc" id="L470">            sigsPrefixCount = 1; // OP_0 &lt;sig&gt;*</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">        } else if (isSentToAddress()) {</span>
<span class="fc" id="L472">            sigsSuffixCount = 1; // &lt;sig&gt; &lt;pubkey&gt;</span>
        }
<span class="fc" id="L474">        return ScriptBuilder.updateScriptWithSignature(scriptSig, sigBytes, index, sigsPrefixCount, sigsSuffixCount);</span>
    }


    /**
     * Returns the index where a signature by the key should be inserted.  Only applicable to
     * a P2SH scriptSig.
     */
    public int getSigInsertionIndex(Sha256Hash hash, ECKey signingKey) {
        // Iterate over existing signatures, skipping the initial OP_0, the final redeem script
        // and any placeholder OP_0 sigs.
<span class="nc" id="L485">        List&lt;ScriptChunk&gt; existingChunks = chunks.subList(1, chunks.size() - 1);</span>
<span class="nc" id="L486">        ScriptChunk redeemScriptChunk = chunks.get(chunks.size() - 1);</span>
<span class="nc" id="L487">        checkNotNull(redeemScriptChunk.data);</span>
<span class="nc" id="L488">        Script redeemScript = new Script(redeemScriptChunk.data);</span>

<span class="nc" id="L490">        int sigCount = 0;</span>
<span class="nc" id="L491">        int myIndex = redeemScript.findKeyInRedeem(signingKey);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        for (ScriptChunk chunk : existingChunks) {</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            if (chunk.opcode == OP_0) {</span>
                // OP_0, skip
            } else {
<span class="nc" id="L496">                checkNotNull(chunk.data);</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                if (myIndex &lt; redeemScript.findSigInRedeem(chunk.data, hash))</span>
<span class="nc" id="L498">                    return sigCount;</span>
<span class="nc" id="L499">                sigCount++;</span>
            }
<span class="nc" id="L501">        }</span>
<span class="nc" id="L502">        return sigCount;</span>
    }

    private int findKeyInRedeem(ECKey key) {
<span class="nc" id="L506">        checkArgument(chunks.get(0).isOpCode()); // P2SH scriptSig</span>
<span class="nc" id="L507">        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        for (int i = 0 ; i &lt; numKeys ; i++) {</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">            if (Arrays.equals(chunks.get(1 + i).data, key.getPubKey())) {</span>
<span class="nc" id="L510">                return i;</span>
            }
        }

<span class="nc" id="L514">        throw new IllegalStateException(&quot;Could not find matching key &quot; + key.toString() + &quot; in script &quot; + this);</span>
    }

    /**
     * Returns a list of the keys required by this script, assuming a multi-sig script.
     *
     * @throws ScriptException if the script type is not understood or is pay to address or is P2SH (run this method on the &quot;Redeem script&quot; instead).
     */
    public List&lt;ECKey&gt; getPubKeys() {
<span class="nc bnc" id="L523" title="All 2 branches missed.">        if (!isSentToMultiSig())</span>
<span class="nc" id="L524">            throw new ScriptException(&quot;Only usable for multisig scripts.&quot;);</span>

<span class="nc" id="L526">        ArrayList&lt;ECKey&gt; result = Lists.newArrayList();</span>
<span class="nc" id="L527">        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        for (int i = 0 ; i &lt; numKeys ; i++)</span>
<span class="nc" id="L529">            result.add(ECKey.fromPublicOnly(chunks.get(1 + i).data));</span>
<span class="nc" id="L530">        return result;</span>
    }

    private int findSigInRedeem(byte[] signatureBytes, Sha256Hash hash) {
<span class="nc" id="L534">        checkArgument(chunks.get(0).isOpCode()); // P2SH scriptSig</span>
<span class="nc" id="L535">        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);</span>
<span class="nc" id="L536">        TransactionSignature signature = TransactionSignature.decodeFromBitcoin(signatureBytes, true);</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        for (int i = 0 ; i &lt; numKeys ; i++) {</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">            if (ECKey.fromPublicOnly(chunks.get(i + 1).data).verify(hash, signature)) {</span>
<span class="nc" id="L539">                return i;</span>
            }
        }

<span class="nc" id="L543">        throw new IllegalStateException(&quot;Could not find matching key for signature on &quot; + hash.toString() + &quot; sig &quot; + Utils.HEX.encode(signatureBytes));</span>
    }



    ////////////////////// Interface used during verification of transactions/blocks ////////////////////////////////

    private static int getSigOpCount(List&lt;ScriptChunk&gt; chunks, boolean accurate) throws ScriptException {
<span class="fc" id="L551">        int sigOps = 0;</span>
<span class="fc" id="L552">        int lastOpCode = OP_INVALIDOPCODE;</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">        for (ScriptChunk chunk : chunks) {</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">            if (chunk.isOpCode()) {</span>
<span class="pc bpc" id="L555" title="1 of 3 branches missed.">                switch (chunk.opcode) {</span>
                case OP_CHECKSIG:
                case OP_CHECKSIGVERIFY:
<span class="fc" id="L558">                    sigOps++;</span>
<span class="fc" id="L559">                    break;</span>
                case OP_CHECKMULTISIG:
                case OP_CHECKMULTISIGVERIFY:
<span class="nc bnc" id="L562" title="All 6 branches missed.">                    if (accurate &amp;&amp; lastOpCode &gt;= OP_1 &amp;&amp; lastOpCode &lt;= OP_16)</span>
<span class="nc" id="L563">                        sigOps += decodeFromOpN(lastOpCode);</span>
                    else
<span class="nc" id="L565">                        sigOps += 20;</span>
<span class="nc" id="L566">                    break;</span>
                default:
                    break;
                }
<span class="fc" id="L570">                lastOpCode = chunk.opcode;</span>
            }
<span class="fc" id="L572">        }</span>
<span class="fc" id="L573">        return sigOps;</span>
    }

    static int decodeFromOpN(int opcode) {
<span class="nc bnc" id="L577" title="All 8 branches missed.">        checkArgument((opcode == OP_0 || opcode == OP_1NEGATE) || (opcode &gt;= OP_1 &amp;&amp; opcode &lt;= OP_16), &quot;decodeFromOpN called on non OP_N opcode&quot;);</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">        if (opcode == OP_0)</span>
<span class="nc" id="L579">            return 0;</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">        else if (opcode == OP_1NEGATE)</span>
<span class="nc" id="L581">            return -1;</span>
        else
<span class="nc" id="L583">            return opcode + 1 - OP_1;</span>
    }

    static int encodeToOpN(int value) {
<span class="pc bpc" id="L587" title="2 of 4 branches missed.">        checkArgument(value &gt;= -1 &amp;&amp; value &lt;= 16, &quot;encodeToOpN called for &quot; + value + &quot; which we cannot encode in an opcode.&quot;);</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (value == 0)</span>
<span class="fc" id="L589">            return OP_0;</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">        else if (value == -1)</span>
<span class="nc" id="L591">            return OP_1NEGATE;</span>
        else
<span class="fc" id="L593">            return value - 1 + OP_1;</span>
    }

    /**
     * Gets the count of regular SigOps in the script program (counting multisig ops as 20)
     */
    public static int getSigOpCount(byte[] program) throws ScriptException {
<span class="fc" id="L600">        Script script = new Script();</span>
        try {
<span class="fc" id="L602">            script.parse(program);</span>
<span class="fc" id="L603">        } catch (ScriptException e) {</span>
            // Ignore errors and count up to the parse-able length
<span class="fc" id="L605">        }</span>
<span class="fc" id="L606">        return getSigOpCount(script.chunks, false);</span>
    }
    
    /**
     * Gets the count of P2SH Sig Ops in the Script scriptSig
     */
    public static long getP2SHSigOpCount(byte[] scriptSig) throws ScriptException {
<span class="nc" id="L613">        Script script = new Script();</span>
        try {
<span class="nc" id="L615">            script.parse(scriptSig);</span>
<span class="nc" id="L616">        } catch (ScriptException e) {</span>
            // Ignore errors and count up to the parse-able length
<span class="nc" id="L618">        }</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">        for (int i = script.chunks.size() - 1; i &gt;= 0; i--)</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">            if (!script.chunks.get(i).isOpCode()) {</span>
<span class="nc" id="L621">                Script subScript =  new Script();</span>
<span class="nc" id="L622">                subScript.parse(script.chunks.get(i).data);</span>
<span class="nc" id="L623">                return getSigOpCount(subScript.chunks, true);</span>
            }
<span class="nc" id="L625">        return 0;</span>
    }

    /**
     * Returns number of signatures required to satisfy this script.
     */
    public int getNumberOfSignaturesRequiredToSpend() {
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (isSentToMultiSig()) {</span>
            // for N of M CHECKMULTISIG script we will need N signatures to spend
<span class="nc" id="L634">            ScriptChunk nChunk = chunks.get(0);</span>
<span class="nc" id="L635">            return Script.decodeFromOpN(nChunk.opcode);</span>
<span class="nc bnc" id="L636" title="All 4 branches missed.">        } else if (isSentToAddress() || isSentToRawPubKey()) {</span>
            // pay-to-address and pay-to-pubkey require single sig
<span class="nc" id="L638">            return 1;</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">        } else if (isPayToScriptHash()) {</span>
<span class="nc" id="L640">            throw new IllegalStateException(&quot;For P2SH number of signatures depends on redeem script&quot;);</span>
        } else {
<span class="nc" id="L642">            throw new IllegalStateException(&quot;Unsupported script type&quot;);</span>
        }
    }

    /**
     * Returns number of bytes required to spend this script. It accepts optional ECKey and redeemScript that may
     * be required for certain types of script to estimate target size.
     */
    public int getNumberOfBytesRequiredToSpend(@Nullable ECKey pubKey, @Nullable Script redeemScript) {
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">        if (isPayToScriptHash()) {</span>
            // scriptSig: &lt;sig&gt; [sig] [sig...] &lt;redeemscript&gt;
<span class="nc bnc" id="L653" title="All 2 branches missed.">            checkArgument(redeemScript != null, &quot;P2SH script requires redeemScript to be spent&quot;);</span>
<span class="nc" id="L654">            return redeemScript.getNumberOfSignaturesRequiredToSpend() * SIG_SIZE + redeemScript.getProgram().length;</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">        } else if (isSentToMultiSig()) {</span>
            // scriptSig: OP_0 &lt;sig&gt; [sig] [sig...]
<span class="nc" id="L657">            return getNumberOfSignaturesRequiredToSpend() * SIG_SIZE + 1;</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">        } else if (isSentToRawPubKey()) {</span>
            // scriptSig: &lt;sig&gt;
<span class="fc" id="L660">            return SIG_SIZE;</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">        } else if (isSentToAddress()) {</span>
            // scriptSig: &lt;sig&gt; &lt;pubkey&gt;
<span class="fc" id="L663">            int uncompressedPubKeySize = 65;</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">            return SIG_SIZE + (pubKey != null ? pubKey.getPubKey().length : uncompressedPubKeySize);</span>
        } else {
<span class="nc" id="L666">            throw new IllegalStateException(&quot;Unsupported script type&quot;);</span>
        }
    }

    /**
     * &lt;p&gt;Whether or not this is a scriptPubKey representing a pay-to-script-hash output. In such outputs, the logic that
     * controls reclamation is not actually in the output at all. Instead there's just a hash, and it's up to the
     * spending input to provide a program matching that hash. This rule is &quot;soft enforced&quot; by the network as it does
     * not exist in Bitcoin Core. It means blocks containing P2SH transactions that don't match
     * correctly are considered valid, but won't be mined upon, so they'll be rapidly re-orgd out of the chain. This
     * logic is defined by &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki&quot;&gt;BIP 16&lt;/a&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;mtnsj does not support creation of P2SH transactions today. The goal of P2SH is to allow short addresses
     * even for complex scripts (eg, multi-sig outputs) so they are convenient to work with in things like QRcodes or
     * with copy/paste, and also to minimize the size of the unspent output set (which improves performance of the
     * Bitcoin system).&lt;/p&gt;
     */
    public boolean isPayToScriptHash() {
        // We have to check against the serialized form because BIP16 defines a P2SH output using an exact byte
        // template, not the logical program structure. Thus you can have two programs that look identical when
        // printed out but one is a P2SH script and the other isn't! :(
<span class="fc" id="L687">        byte[] program = getProgram();</span>
<span class="pc bpc" id="L688" title="7 of 8 branches missed.">        return program.length == 23 &amp;&amp;</span>
               (program[0] &amp; 0xff) == OP_HASH160 &amp;&amp;
               (program[1] &amp; 0xff) == 0x14 &amp;&amp;
               (program[22] &amp; 0xff) == OP_EQUAL;
    }

    /**
     * Returns whether this script matches the format used for multisig outputs: [n] [keys...] [m] CHECKMULTISIG
     */
    public boolean isSentToMultiSig() {
<span class="fc bfc" id="L698" title="All 2 branches covered.">        if (chunks.size() &lt; 4) return false;</span>
<span class="fc" id="L699">        ScriptChunk chunk = chunks.get(chunks.size() - 1);</span>
        // Must end in OP_CHECKMULTISIG[VERIFY].
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">        if (!chunk.isOpCode()) return false;</span>
<span class="pc bpc" id="L702" title="2 of 4 branches missed.">        if (!(chunk.equalsOpCode(OP_CHECKMULTISIG) || chunk.equalsOpCode(OP_CHECKMULTISIGVERIFY))) return false;</span>
        try {
            // Second to last chunk must be an OP_N opcode and there should be that many data chunks (keys).
<span class="nc" id="L705">            ScriptChunk m = chunks.get(chunks.size() - 2);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">            if (!m.isOpCode()) return false;</span>
<span class="nc" id="L707">            int numKeys = decodeFromOpN(m.opcode);</span>
<span class="nc bnc" id="L708" title="All 4 branches missed.">            if (numKeys &lt; 1 || chunks.size() != 3 + numKeys) return false;</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">            for (int i = 1; i &lt; chunks.size() - 2; i++) {</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">                if (chunks.get(i).isOpCode()) return false;</span>
            }
            // First chunk must be an OP_N opcode too.
<span class="nc bnc" id="L713" title="All 2 branches missed.">            if (decodeFromOpN(chunks.get(0).opcode) &lt; 1) return false;</span>
<span class="nc" id="L714">        } catch (IllegalStateException e) {</span>
<span class="nc" id="L715">            return false;   // Not an OP_N opcode.</span>
<span class="nc" id="L716">        }</span>
<span class="nc" id="L717">        return true;</span>
    }

    public boolean isSentToCLTVPaymentChannel() {
<span class="nc bnc" id="L721" title="All 2 branches missed.">        if (chunks.size() != 10) return false;</span>
        // Check that opcodes match the pre-determined format.
<span class="nc bnc" id="L723" title="All 2 branches missed.">        if (!chunks.get(0).equalsOpCode(OP_IF)) return false;</span>
        // chunk[1] = recipient pubkey
<span class="nc bnc" id="L725" title="All 2 branches missed.">        if (!chunks.get(2).equalsOpCode(OP_CHECKSIGVERIFY)) return false;</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">        if (!chunks.get(3).equalsOpCode(OP_ELSE)) return false;</span>
        // chunk[4] = locktime
<span class="nc bnc" id="L728" title="All 2 branches missed.">        if (!chunks.get(5).equalsOpCode(OP_CHECKLOCKTIMEVERIFY)) return false;</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">        if (!chunks.get(6).equalsOpCode(OP_DROP)) return false;</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">        if (!chunks.get(7).equalsOpCode(OP_ENDIF)) return false;</span>
        // chunk[8] = sender pubkey
<span class="nc bnc" id="L732" title="All 2 branches missed.">        if (!chunks.get(9).equalsOpCode(OP_CHECKSIG)) return false;</span>
<span class="nc" id="L733">        return true;</span>
    }

    private static boolean equalsRange(byte[] a, int start, byte[] b) {
<span class="fc bfc" id="L737" title="All 2 branches covered.">        if (start + b.length &gt; a.length)</span>
<span class="fc" id="L738">            return false;</span>
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">        for (int i = 0; i &lt; b.length; i++)</span>
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">            if (a[i + start] != b[i])</span>
<span class="fc" id="L741">                return false;</span>
<span class="nc" id="L742">        return true;</span>
    }
    
    /**
     * Returns the script bytes of inputScript with all instances of the specified script object removed
     */
    public static byte[] removeAllInstancesOf(byte[] inputScript, byte[] chunkToRemove) {
        // We usually don't end up removing anything
<span class="fc" id="L750">        UnsafeByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(inputScript.length);</span>

<span class="fc" id="L752">        int cursor = 0;</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">        while (cursor &lt; inputScript.length) {</span>
<span class="fc" id="L754">            boolean skip = equalsRange(inputScript, cursor, chunkToRemove);</span>
            
<span class="fc" id="L756">            int opcode = inputScript[cursor++] &amp; 0xFF;</span>
<span class="fc" id="L757">            int additionalBytes = 0;</span>
<span class="pc bpc" id="L758" title="1 of 4 branches missed.">            if (opcode &gt;= 0 &amp;&amp; opcode &lt; OP_PUSHDATA1) {</span>
<span class="fc" id="L759">                additionalBytes = opcode;</span>
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">            } else if (opcode == OP_PUSHDATA1) {</span>
<span class="nc" id="L761">                additionalBytes = (0xFF &amp; inputScript[cursor]) + 1;</span>
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">            } else if (opcode == OP_PUSHDATA2) {</span>
<span class="nc" id="L763">                additionalBytes = ((0xFF &amp; inputScript[cursor]) |</span>
                                  ((0xFF &amp; inputScript[cursor+1]) &lt;&lt; 8)) + 2;
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">            } else if (opcode == OP_PUSHDATA4) {</span>
<span class="nc" id="L766">                additionalBytes = ((0xFF &amp; inputScript[cursor]) |</span>
                                  ((0xFF &amp; inputScript[cursor+1]) &lt;&lt; 8) |
                                  ((0xFF &amp; inputScript[cursor+1]) &lt;&lt; 16) |
                                  ((0xFF &amp; inputScript[cursor+1]) &lt;&lt; 24)) + 4;
            }
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">            if (!skip) {</span>
                try {
<span class="fc" id="L773">                    bos.write(opcode);</span>
<span class="fc" id="L774">                    bos.write(Arrays.copyOfRange(inputScript, cursor, cursor + additionalBytes));</span>
<span class="nc" id="L775">                } catch (IOException e) {</span>
<span class="nc" id="L776">                    throw new RuntimeException(e);</span>
<span class="fc" id="L777">                }</span>
            }
<span class="fc" id="L779">            cursor += additionalBytes;</span>
<span class="fc" id="L780">        }</span>
<span class="fc" id="L781">        return bos.toByteArray();</span>
    }
    
    /**
     * Returns the script bytes of inputScript with all instances of the given op code removed
     */
    public static byte[] removeAllInstancesOfOp(byte[] inputScript, int opCode) {
<span class="fc" id="L788">        return removeAllInstancesOf(inputScript, new byte[] {(byte)opCode});</span>
    }
    
    ////////////////////// Script verification and helpers ////////////////////////////////
    
    private static boolean castToBool(byte[] data) {
<span class="pc bfc" id="L794" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++)</span>
        {
            // &quot;Can be negative zero&quot; - Bitcoin Core (see OpenSSL's BN_bn2mpi)
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">            if (data[i] != 0)</span>
<span class="pc bpc" id="L798" title="2 of 4 branches missed.">                return !(i == data.length - 1 &amp;&amp; (data[i] &amp; 0xFF) == 0x80);</span>
        }
<span class="fc" id="L800">        return false;</span>
    }
    
    /**
     * Cast a script chunk to a BigInteger.
     *
     * @see #castToBigInteger(byte[], int) for values with different maximum
     * sizes.
     * @throws ScriptException if the chunk is longer than 4 bytes.
     */
    private static BigInteger castToBigInteger(byte[] chunk) throws ScriptException {
<span class="nc bnc" id="L811" title="All 2 branches missed.">        if (chunk.length &gt; 4)</span>
<span class="nc" id="L812">            throw new ScriptException(&quot;Script attempted to use an integer larger than 4 bytes&quot;);</span>
<span class="nc" id="L813">        return Utils.decodeMPI(Utils.reverseBytes(chunk), false);</span>
    }

    /**
     * Cast a script chunk to a BigInteger. Normally you would want
     * {@link #castToBigInteger(byte[])} instead, this is only for cases where
     * the normal maximum length does not apply (i.e. CHECKLOCKTIMEVERIFY).
     *
     * @param maxLength the maximum length in bytes.
     * @throws ScriptException if the chunk is longer than the specified maximum.
     */
    private static BigInteger castToBigInteger(final byte[] chunk, final int maxLength) throws ScriptException {
<span class="nc bnc" id="L825" title="All 2 branches missed.">        if (chunk.length &gt; maxLength)</span>
<span class="nc" id="L826">            throw new ScriptException(&quot;Script attempted to use an integer larger than &quot;</span>
                + maxLength + &quot; bytes&quot;);
<span class="nc" id="L828">        return Utils.decodeMPI(Utils.reverseBytes(chunk), false);</span>
    }

    public boolean isOpReturn() {
<span class="nc bnc" id="L832" title="All 4 branches missed.">        return chunks.size() &gt; 0 &amp;&amp; chunks.get(0).equalsOpCode(OP_RETURN);</span>
    }

    public boolean isUnspendable() {
<span class="nc bnc" id="L836" title="All 4 branches missed.">        return chunks.size() &gt; 1 &amp;&amp; chunks.get(0).equalsOpCode(OP_RETURN);</span>
    }

    /**
     * Exposes the script interpreter. Normally you should not use this directly, instead use
     * {@link site.mtnsj.core.TransactionInput#verify(site.mtnsj.core.TransactionOutput)} or
     * {@link site.mtnsj.script.Script#correctlySpends(site.mtnsj.core.Transaction, long, Script)}. This method
     * is useful if you need more precise control or access to the final state of the stack. This interface is very
     * likely to change in future.
     *
     * @deprecated Use {@link #executeScript(site.mtnsj.core.Transaction, long, site.mtnsj.script.Script, java.util.LinkedList, java.util.Set)}
     * instead.
     */
    @Deprecated
    public static void executeScript(@Nullable Transaction txContainingThis, long index,
                                     Script script, LinkedList&lt;byte[]&gt; stack, boolean enforceNullDummy) throws ScriptException {
<span class="nc bnc" id="L852" title="All 2 branches missed.">        final EnumSet&lt;VerifyFlag&gt; flags = enforceNullDummy</span>
<span class="nc" id="L853">            ? EnumSet.of(VerifyFlag.NULLDUMMY)</span>
<span class="nc" id="L854">            : EnumSet.noneOf(VerifyFlag.class);</span>

<span class="nc" id="L856">        executeScript(txContainingThis, index, script, stack, flags);</span>
<span class="nc" id="L857">    }</span>

    /**
     * Exposes the script interpreter. Normally you should not use this directly, instead use
     * {@link site.mtnsj.core.TransactionInput#verify(site.mtnsj.core.TransactionOutput)} or
     * {@link site.mtnsj.script.Script#correctlySpends(site.mtnsj.core.Transaction, long, Script)}. This method
     * is useful if you need more precise control or access to the final state of the stack. This interface is very
     * likely to change in future.
     */
    public static void executeScript(@Nullable Transaction txContainingThis, long index,
                                     Script script, LinkedList&lt;byte[]&gt; stack, Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
<span class="fc" id="L868">        int opCount = 0;</span>
<span class="fc" id="L869">        int lastCodeSepLocation = 0;</span>
        
<span class="fc" id="L871">        LinkedList&lt;byte[]&gt; altstack = new LinkedList&lt;byte[]&gt;();</span>
<span class="fc" id="L872">        LinkedList&lt;Boolean&gt; ifStack = new LinkedList&lt;Boolean&gt;();</span>
        
<span class="fc bfc" id="L874" title="All 2 branches covered.">        for (ScriptChunk chunk : script.chunks) {</span>
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">            boolean shouldExecute = !ifStack.contains(false);</span>

<span class="fc bfc" id="L877" title="All 2 branches covered.">            if (chunk.opcode == OP_0) {</span>
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">                if (!shouldExecute)</span>
<span class="nc" id="L879">                    continue;</span>

<span class="fc" id="L881">                stack.add(new byte[] {});</span>
<span class="fc bfc" id="L882" title="All 2 branches covered.">            } else if (!chunk.isOpCode()) {</span>
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">                if (chunk.data.length &gt; MAX_SCRIPT_ELEMENT_SIZE)</span>
<span class="nc" id="L884">                    throw new ScriptException(&quot;Attempted to push a data string larger than 520 bytes&quot;);</span>
                
<span class="pc bpc" id="L886" title="1 of 2 branches missed.">                if (!shouldExecute)</span>
<span class="nc" id="L887">                    continue;</span>
                
<span class="fc" id="L889">                stack.add(chunk.data);</span>
            } else {
<span class="fc" id="L891">                int opcode = chunk.opcode;</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">                if (opcode &gt; OP_16) {</span>
<span class="fc" id="L893">                    opCount++;</span>
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">                    if (opCount &gt; 201)</span>
<span class="nc" id="L895">                        throw new ScriptException(&quot;More script operations than is allowed&quot;);</span>
                }
                
<span class="pc bpc" id="L898" title="2 of 4 branches missed.">                if (opcode == OP_VERIF || opcode == OP_VERNOTIF)</span>
<span class="nc" id="L899">                    throw new ScriptException(&quot;Script included OP_VERIF or OP_VERNOTIF&quot;);</span>
                
<span class="pc bpc" id="L901" title="15 of 30 branches missed.">                if (opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT ||</span>
                    opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR ||
                    opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV ||
                    opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT)
<span class="nc" id="L905">                    throw new ScriptException(&quot;Script included a disabled Script Op.&quot;);</span>
                
<span class="pc bpc" id="L907" title="4 of 5 branches missed.">                switch (opcode) {</span>
                case OP_IF:
<span class="nc bnc" id="L909" title="All 2 branches missed.">                    if (!shouldExecute) {</span>
<span class="nc" id="L910">                        ifStack.add(false);</span>
<span class="nc" id="L911">                        continue;</span>
                    }
<span class="nc bnc" id="L913" title="All 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L914">                        throw new ScriptException(&quot;Attempted OP_IF on an empty stack&quot;);</span>
<span class="nc" id="L915">                    ifStack.add(castToBool(stack.pollLast()));</span>
<span class="nc" id="L916">                    continue;</span>
                case OP_NOTIF:
<span class="nc bnc" id="L918" title="All 2 branches missed.">                    if (!shouldExecute) {</span>
<span class="nc" id="L919">                        ifStack.add(false);</span>
<span class="nc" id="L920">                        continue;</span>
                    }
<span class="nc bnc" id="L922" title="All 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L923">                        throw new ScriptException(&quot;Attempted OP_NOTIF on an empty stack&quot;);</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">                    ifStack.add(!castToBool(stack.pollLast()));</span>
<span class="nc" id="L925">                    continue;</span>
                case OP_ELSE:
<span class="nc bnc" id="L927" title="All 2 branches missed.">                    if (ifStack.isEmpty())</span>
<span class="nc" id="L928">                        throw new ScriptException(&quot;Attempted OP_ELSE without OP_IF/NOTIF&quot;);</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">                    ifStack.add(!ifStack.pollLast());</span>
<span class="nc" id="L930">                    continue;</span>
                case OP_ENDIF:
<span class="nc bnc" id="L932" title="All 2 branches missed.">                    if (ifStack.isEmpty())</span>
<span class="nc" id="L933">                        throw new ScriptException(&quot;Attempted OP_ENDIF without OP_IF/NOTIF&quot;);</span>
<span class="nc" id="L934">                    ifStack.pollLast();</span>
<span class="nc" id="L935">                    continue;</span>
                }
                
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">                if (!shouldExecute)</span>
<span class="nc" id="L939">                    continue;</span>
                
<span class="pc bpc" id="L941" title="40 of 44 branches missed.">                switch(opcode) {</span>
                // OP_0 is no opcode
                case OP_1NEGATE:
<span class="nc" id="L944">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE.negate(), false)));</span>
<span class="nc" id="L945">                    break;</span>
                case OP_1:
                case OP_2:
                case OP_3:
                case OP_4:
                case OP_5:
                case OP_6:
                case OP_7:
                case OP_8:
                case OP_9:
                case OP_10:
                case OP_11:
                case OP_12:
                case OP_13:
                case OP_14:
                case OP_15:
                case OP_16:
<span class="nc" id="L962">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(decodeFromOpN(opcode)), false)));</span>
<span class="nc" id="L963">                    break;</span>
                case OP_NOP:
<span class="nc" id="L965">                    break;</span>
                case OP_VERIFY:
<span class="nc bnc" id="L967" title="All 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L968">                        throw new ScriptException(&quot;Attempted OP_VERIFY on an empty stack&quot;);</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">                    if (!castToBool(stack.pollLast()))</span>
<span class="nc" id="L970">                        throw new ScriptException(&quot;OP_VERIFY failed&quot;);</span>
                    break;
                case OP_RETURN:
<span class="nc" id="L973">                    throw new ScriptException(&quot;Script called OP_RETURN&quot;);</span>
                case OP_TOALTSTACK:
<span class="nc bnc" id="L975" title="All 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L976">                        throw new ScriptException(&quot;Attempted OP_TOALTSTACK on an empty stack&quot;);</span>
<span class="nc" id="L977">                    altstack.add(stack.pollLast());</span>
<span class="nc" id="L978">                    break;</span>
                case OP_FROMALTSTACK:
<span class="nc bnc" id="L980" title="All 2 branches missed.">                    if (altstack.size() &lt; 1)</span>
<span class="nc" id="L981">                        throw new ScriptException(&quot;Attempted OP_TOALTSTACK on an empty altstack&quot;);</span>
<span class="nc" id="L982">                    stack.add(altstack.pollLast());</span>
<span class="nc" id="L983">                    break;</span>
                case OP_2DROP:
<span class="nc bnc" id="L985" title="All 2 branches missed.">                    if (stack.size() &lt; 2)</span>
<span class="nc" id="L986">                        throw new ScriptException(&quot;Attempted OP_2DROP on a stack with size &lt; 2&quot;);</span>
<span class="nc" id="L987">                    stack.pollLast();</span>
<span class="nc" id="L988">                    stack.pollLast();</span>
<span class="nc" id="L989">                    break;</span>
                case OP_2DUP:
<span class="nc bnc" id="L991" title="All 2 branches missed.">                    if (stack.size() &lt; 2)</span>
<span class="nc" id="L992">                        throw new ScriptException(&quot;Attempted OP_2DUP on a stack with size &lt; 2&quot;);</span>
<span class="nc" id="L993">                    Iterator&lt;byte[]&gt; it2DUP = stack.descendingIterator();</span>
<span class="nc" id="L994">                    byte[] OP2DUPtmpChunk2 = it2DUP.next();</span>
<span class="nc" id="L995">                    stack.add(it2DUP.next());</span>
<span class="nc" id="L996">                    stack.add(OP2DUPtmpChunk2);</span>
<span class="nc" id="L997">                    break;</span>
                case OP_3DUP:
<span class="nc bnc" id="L999" title="All 2 branches missed.">                    if (stack.size() &lt; 3)</span>
<span class="nc" id="L1000">                        throw new ScriptException(&quot;Attempted OP_3DUP on a stack with size &lt; 3&quot;);</span>
<span class="nc" id="L1001">                    Iterator&lt;byte[]&gt; it3DUP = stack.descendingIterator();</span>
<span class="nc" id="L1002">                    byte[] OP3DUPtmpChunk3 = it3DUP.next();</span>
<span class="nc" id="L1003">                    byte[] OP3DUPtmpChunk2 = it3DUP.next();</span>
<span class="nc" id="L1004">                    stack.add(it3DUP.next());</span>
<span class="nc" id="L1005">                    stack.add(OP3DUPtmpChunk2);</span>
<span class="nc" id="L1006">                    stack.add(OP3DUPtmpChunk3);</span>
<span class="nc" id="L1007">                    break;</span>
                case OP_2OVER:
<span class="nc bnc" id="L1009" title="All 2 branches missed.">                    if (stack.size() &lt; 4)</span>
<span class="nc" id="L1010">                        throw new ScriptException(&quot;Attempted OP_2OVER on a stack with size &lt; 4&quot;);</span>
<span class="nc" id="L1011">                    Iterator&lt;byte[]&gt; it2OVER = stack.descendingIterator();</span>
<span class="nc" id="L1012">                    it2OVER.next();</span>
<span class="nc" id="L1013">                    it2OVER.next();</span>
<span class="nc" id="L1014">                    byte[] OP2OVERtmpChunk2 = it2OVER.next();</span>
<span class="nc" id="L1015">                    stack.add(it2OVER.next());</span>
<span class="nc" id="L1016">                    stack.add(OP2OVERtmpChunk2);</span>
<span class="nc" id="L1017">                    break;</span>
                case OP_2ROT:
<span class="nc bnc" id="L1019" title="All 2 branches missed.">                    if (stack.size() &lt; 6)</span>
<span class="nc" id="L1020">                        throw new ScriptException(&quot;Attempted OP_2ROT on a stack with size &lt; 6&quot;);</span>
<span class="nc" id="L1021">                    byte[] OP2ROTtmpChunk6 = stack.pollLast();</span>
<span class="nc" id="L1022">                    byte[] OP2ROTtmpChunk5 = stack.pollLast();</span>
<span class="nc" id="L1023">                    byte[] OP2ROTtmpChunk4 = stack.pollLast();</span>
<span class="nc" id="L1024">                    byte[] OP2ROTtmpChunk3 = stack.pollLast();</span>
<span class="nc" id="L1025">                    byte[] OP2ROTtmpChunk2 = stack.pollLast();</span>
<span class="nc" id="L1026">                    byte[] OP2ROTtmpChunk1 = stack.pollLast();</span>
<span class="nc" id="L1027">                    stack.add(OP2ROTtmpChunk3);</span>
<span class="nc" id="L1028">                    stack.add(OP2ROTtmpChunk4);</span>
<span class="nc" id="L1029">                    stack.add(OP2ROTtmpChunk5);</span>
<span class="nc" id="L1030">                    stack.add(OP2ROTtmpChunk6);</span>
<span class="nc" id="L1031">                    stack.add(OP2ROTtmpChunk1);</span>
<span class="nc" id="L1032">                    stack.add(OP2ROTtmpChunk2);</span>
<span class="nc" id="L1033">                    break;</span>
                case OP_2SWAP:
<span class="nc bnc" id="L1035" title="All 2 branches missed.">                    if (stack.size() &lt; 4)</span>
<span class="nc" id="L1036">                        throw new ScriptException(&quot;Attempted OP_2SWAP on a stack with size &lt; 4&quot;);</span>
<span class="nc" id="L1037">                    byte[] OP2SWAPtmpChunk4 = stack.pollLast();</span>
<span class="nc" id="L1038">                    byte[] OP2SWAPtmpChunk3 = stack.pollLast();</span>
<span class="nc" id="L1039">                    byte[] OP2SWAPtmpChunk2 = stack.pollLast();</span>
<span class="nc" id="L1040">                    byte[] OP2SWAPtmpChunk1 = stack.pollLast();</span>
<span class="nc" id="L1041">                    stack.add(OP2SWAPtmpChunk3);</span>
<span class="nc" id="L1042">                    stack.add(OP2SWAPtmpChunk4);</span>
<span class="nc" id="L1043">                    stack.add(OP2SWAPtmpChunk1);</span>
<span class="nc" id="L1044">                    stack.add(OP2SWAPtmpChunk2);</span>
<span class="nc" id="L1045">                    break;</span>
                case OP_IFDUP:
<span class="nc bnc" id="L1047" title="All 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L1048">                        throw new ScriptException(&quot;Attempted OP_IFDUP on an empty stack&quot;);</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                    if (castToBool(stack.getLast()))</span>
<span class="nc" id="L1050">                        stack.add(stack.getLast());</span>
                    break;
                case OP_DEPTH:
<span class="nc" id="L1053">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.size()), false)));</span>
<span class="nc" id="L1054">                    break;</span>
                case OP_DROP:
<span class="nc bnc" id="L1056" title="All 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L1057">                        throw new ScriptException(&quot;Attempted OP_DROP on an empty stack&quot;);</span>
<span class="nc" id="L1058">                    stack.pollLast();</span>
<span class="nc" id="L1059">                    break;</span>
                case OP_DUP:
<span class="fc bfc" id="L1061" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1062">                        throw new ScriptException(&quot;Attempted OP_DUP on an empty stack&quot;);</span>
<span class="fc" id="L1063">                    stack.add(stack.getLast());</span>
<span class="fc" id="L1064">                    break;</span>
                case OP_NIP:
<span class="nc bnc" id="L1066" title="All 2 branches missed.">                    if (stack.size() &lt; 2)</span>
<span class="nc" id="L1067">                        throw new ScriptException(&quot;Attempted OP_NIP on a stack with size &lt; 2&quot;);</span>
<span class="nc" id="L1068">                    byte[] OPNIPtmpChunk = stack.pollLast();</span>
<span class="nc" id="L1069">                    stack.pollLast();</span>
<span class="nc" id="L1070">                    stack.add(OPNIPtmpChunk);</span>
<span class="nc" id="L1071">                    break;</span>
                case OP_OVER:
<span class="nc bnc" id="L1073" title="All 2 branches missed.">                    if (stack.size() &lt; 2)</span>
<span class="nc" id="L1074">                        throw new ScriptException(&quot;Attempted OP_OVER on a stack with size &lt; 2&quot;);</span>
<span class="nc" id="L1075">                    Iterator&lt;byte[]&gt; itOVER = stack.descendingIterator();</span>
<span class="nc" id="L1076">                    itOVER.next();</span>
<span class="nc" id="L1077">                    stack.add(itOVER.next());</span>
<span class="nc" id="L1078">                    break;</span>
                case OP_PICK:
                case OP_ROLL:
<span class="nc bnc" id="L1081" title="All 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L1082">                        throw new ScriptException(&quot;Attempted OP_PICK/OP_ROLL on an empty stack&quot;);</span>
<span class="nc" id="L1083">                    long val = castToBigInteger(stack.pollLast()).longValue();</span>
<span class="nc bnc" id="L1084" title="All 4 branches missed.">                    if (val &lt; 0 || val &gt;= stack.size())</span>
<span class="nc" id="L1085">                        throw new ScriptException(&quot;OP_PICK/OP_ROLL attempted to get data deeper than stack size&quot;);</span>
<span class="nc" id="L1086">                    Iterator&lt;byte[]&gt; itPICK = stack.descendingIterator();</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">                    for (long i = 0; i &lt; val; i++)</span>
<span class="nc" id="L1088">                        itPICK.next();</span>
<span class="nc" id="L1089">                    byte[] OPROLLtmpChunk = itPICK.next();</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">                    if (opcode == OP_ROLL)</span>
<span class="nc" id="L1091">                        itPICK.remove();</span>
<span class="nc" id="L1092">                    stack.add(OPROLLtmpChunk);</span>
<span class="nc" id="L1093">                    break;</span>
                case OP_ROT:
<span class="nc bnc" id="L1095" title="All 2 branches missed.">                    if (stack.size() &lt; 3)</span>
<span class="nc" id="L1096">                        throw new ScriptException(&quot;Attempted OP_ROT on a stack with size &lt; 3&quot;);</span>
<span class="nc" id="L1097">                    byte[] OPROTtmpChunk3 = stack.pollLast();</span>
<span class="nc" id="L1098">                    byte[] OPROTtmpChunk2 = stack.pollLast();</span>
<span class="nc" id="L1099">                    byte[] OPROTtmpChunk1 = stack.pollLast();</span>
<span class="nc" id="L1100">                    stack.add(OPROTtmpChunk2);</span>
<span class="nc" id="L1101">                    stack.add(OPROTtmpChunk3);</span>
<span class="nc" id="L1102">                    stack.add(OPROTtmpChunk1);</span>
<span class="nc" id="L1103">                    break;</span>
                case OP_SWAP:
                case OP_TUCK:
<span class="nc bnc" id="L1106" title="All 2 branches missed.">                    if (stack.size() &lt; 2)</span>
<span class="nc" id="L1107">                        throw new ScriptException(&quot;Attempted OP_SWAP on a stack with size &lt; 2&quot;);</span>
<span class="nc" id="L1108">                    byte[] OPSWAPtmpChunk2 = stack.pollLast();</span>
<span class="nc" id="L1109">                    byte[] OPSWAPtmpChunk1 = stack.pollLast();</span>
<span class="nc" id="L1110">                    stack.add(OPSWAPtmpChunk2);</span>
<span class="nc" id="L1111">                    stack.add(OPSWAPtmpChunk1);</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">                    if (opcode == OP_TUCK)</span>
<span class="nc" id="L1113">                        stack.add(OPSWAPtmpChunk2);</span>
                    break;
                case OP_CAT:
                case OP_SUBSTR:
                case OP_LEFT:
                case OP_RIGHT:
<span class="nc" id="L1119">                    throw new ScriptException(&quot;Attempted to use disabled Script Op.&quot;);</span>
                case OP_SIZE:
<span class="nc bnc" id="L1121" title="All 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L1122">                        throw new ScriptException(&quot;Attempted OP_SIZE on an empty stack&quot;);</span>
<span class="nc" id="L1123">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.getLast().length), false)));</span>
<span class="nc" id="L1124">                    break;</span>
                case OP_INVERT:
                case OP_AND:
                case OP_OR:
                case OP_XOR:
<span class="nc" id="L1129">                    throw new ScriptException(&quot;Attempted to use disabled Script Op.&quot;);</span>
                case OP_EQUAL:
<span class="nc bnc" id="L1131" title="All 2 branches missed.">                    if (stack.size() &lt; 2)</span>
<span class="nc" id="L1132">                        throw new ScriptException(&quot;Attempted OP_EQUALVERIFY on a stack with size &lt; 2&quot;);</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">                    stack.add(Arrays.equals(stack.pollLast(), stack.pollLast()) ? new byte[] {1} : new byte[] {});</span>
<span class="nc" id="L1134">                    break;</span>
                case OP_EQUALVERIFY:
<span class="pc bpc" id="L1136" title="1 of 2 branches missed.">                    if (stack.size() &lt; 2)</span>
<span class="nc" id="L1137">                        throw new ScriptException(&quot;Attempted OP_EQUALVERIFY on a stack with size &lt; 2&quot;);</span>
<span class="pc bpc" id="L1138" title="1 of 2 branches missed.">                    if (!Arrays.equals(stack.pollLast(), stack.pollLast()))</span>
<span class="nc" id="L1139">                        throw new ScriptException(&quot;OP_EQUALVERIFY: non-equal data&quot;);</span>
                    break;
                case OP_1ADD:
                case OP_1SUB:
                case OP_NEGATE:
                case OP_ABS:
                case OP_NOT:
                case OP_0NOTEQUAL:
<span class="nc bnc" id="L1147" title="All 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L1148">                        throw new ScriptException(&quot;Attempted a numeric op on an empty stack&quot;);</span>
<span class="nc" id="L1149">                    BigInteger numericOPnum = castToBigInteger(stack.pollLast());</span>
                                        
<span class="nc bnc" id="L1151" title="All 7 branches missed.">                    switch (opcode) {</span>
                    case OP_1ADD:
<span class="nc" id="L1153">                        numericOPnum = numericOPnum.add(BigInteger.ONE);</span>
<span class="nc" id="L1154">                        break;</span>
                    case OP_1SUB:
<span class="nc" id="L1156">                        numericOPnum = numericOPnum.subtract(BigInteger.ONE);</span>
<span class="nc" id="L1157">                        break;</span>
                    case OP_NEGATE:
<span class="nc" id="L1159">                        numericOPnum = numericOPnum.negate();</span>
<span class="nc" id="L1160">                        break;</span>
                    case OP_ABS:
<span class="nc bnc" id="L1162" title="All 2 branches missed.">                        if (numericOPnum.signum() &lt; 0)</span>
<span class="nc" id="L1163">                            numericOPnum = numericOPnum.negate();</span>
                        break;
                    case OP_NOT:
<span class="nc bnc" id="L1166" title="All 2 branches missed.">                        if (numericOPnum.equals(BigInteger.ZERO))</span>
<span class="nc" id="L1167">                            numericOPnum = BigInteger.ONE;</span>
                        else
<span class="nc" id="L1169">                            numericOPnum = BigInteger.ZERO;</span>
<span class="nc" id="L1170">                        break;</span>
                    case OP_0NOTEQUAL:
<span class="nc bnc" id="L1172" title="All 2 branches missed.">                        if (numericOPnum.equals(BigInteger.ZERO))</span>
<span class="nc" id="L1173">                            numericOPnum = BigInteger.ZERO;</span>
                        else
<span class="nc" id="L1175">                            numericOPnum = BigInteger.ONE;</span>
<span class="nc" id="L1176">                        break;</span>
                    default:
<span class="nc" id="L1178">                        throw new AssertionError(&quot;Unreachable&quot;);</span>
                    }
                    
<span class="nc" id="L1181">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPnum, false)));</span>
<span class="nc" id="L1182">                    break;</span>
                case OP_2MUL:
                case OP_2DIV:
<span class="nc" id="L1185">                    throw new ScriptException(&quot;Attempted to use disabled Script Op.&quot;);</span>
                case OP_ADD:
                case OP_SUB:
                case OP_BOOLAND:
                case OP_BOOLOR:
                case OP_NUMEQUAL:
                case OP_NUMNOTEQUAL:
                case OP_LESSTHAN:
                case OP_GREATERTHAN:
                case OP_LESSTHANOREQUAL:
                case OP_GREATERTHANOREQUAL:
                case OP_MIN:
                case OP_MAX:
<span class="nc bnc" id="L1198" title="All 2 branches missed.">                    if (stack.size() &lt; 2)</span>
<span class="nc" id="L1199">                        throw new ScriptException(&quot;Attempted a numeric op on a stack with size &lt; 2&quot;);</span>
<span class="nc" id="L1200">                    BigInteger numericOPnum2 = castToBigInteger(stack.pollLast());</span>
<span class="nc" id="L1201">                    BigInteger numericOPnum1 = castToBigInteger(stack.pollLast());</span>

                    BigInteger numericOPresult;
<span class="nc bnc" id="L1204" title="All 13 branches missed.">                    switch (opcode) {</span>
                    case OP_ADD:
<span class="nc" id="L1206">                        numericOPresult = numericOPnum1.add(numericOPnum2);</span>
<span class="nc" id="L1207">                        break;</span>
                    case OP_SUB:
<span class="nc" id="L1209">                        numericOPresult = numericOPnum1.subtract(numericOPnum2);</span>
<span class="nc" id="L1210">                        break;</span>
                    case OP_BOOLAND:
<span class="nc bnc" id="L1212" title="All 4 branches missed.">                        if (!numericOPnum1.equals(BigInteger.ZERO) &amp;&amp; !numericOPnum2.equals(BigInteger.ZERO))</span>
<span class="nc" id="L1213">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="nc" id="L1215">                            numericOPresult = BigInteger.ZERO;</span>
<span class="nc" id="L1216">                        break;</span>
                    case OP_BOOLOR:
<span class="nc bnc" id="L1218" title="All 4 branches missed.">                        if (!numericOPnum1.equals(BigInteger.ZERO) || !numericOPnum2.equals(BigInteger.ZERO))</span>
<span class="nc" id="L1219">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="nc" id="L1221">                            numericOPresult = BigInteger.ZERO;</span>
<span class="nc" id="L1222">                        break;</span>
                    case OP_NUMEQUAL:
<span class="nc bnc" id="L1224" title="All 2 branches missed.">                        if (numericOPnum1.equals(numericOPnum2))</span>
<span class="nc" id="L1225">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="nc" id="L1227">                            numericOPresult = BigInteger.ZERO;</span>
<span class="nc" id="L1228">                        break;</span>
                    case OP_NUMNOTEQUAL:
<span class="nc bnc" id="L1230" title="All 2 branches missed.">                        if (!numericOPnum1.equals(numericOPnum2))</span>
<span class="nc" id="L1231">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="nc" id="L1233">                            numericOPresult = BigInteger.ZERO;</span>
<span class="nc" id="L1234">                        break;</span>
                    case OP_LESSTHAN:
<span class="nc bnc" id="L1236" title="All 2 branches missed.">                        if (numericOPnum1.compareTo(numericOPnum2) &lt; 0)</span>
<span class="nc" id="L1237">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="nc" id="L1239">                            numericOPresult = BigInteger.ZERO;</span>
<span class="nc" id="L1240">                        break;</span>
                    case OP_GREATERTHAN:
<span class="nc bnc" id="L1242" title="All 2 branches missed.">                        if (numericOPnum1.compareTo(numericOPnum2) &gt; 0)</span>
<span class="nc" id="L1243">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="nc" id="L1245">                            numericOPresult = BigInteger.ZERO;</span>
<span class="nc" id="L1246">                        break;</span>
                    case OP_LESSTHANOREQUAL:
<span class="nc bnc" id="L1248" title="All 2 branches missed.">                        if (numericOPnum1.compareTo(numericOPnum2) &lt;= 0)</span>
<span class="nc" id="L1249">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="nc" id="L1251">                            numericOPresult = BigInteger.ZERO;</span>
<span class="nc" id="L1252">                        break;</span>
                    case OP_GREATERTHANOREQUAL:
<span class="nc bnc" id="L1254" title="All 2 branches missed.">                        if (numericOPnum1.compareTo(numericOPnum2) &gt;= 0)</span>
<span class="nc" id="L1255">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="nc" id="L1257">                            numericOPresult = BigInteger.ZERO;</span>
<span class="nc" id="L1258">                        break;</span>
                    case OP_MIN:
<span class="nc bnc" id="L1260" title="All 2 branches missed.">                        if (numericOPnum1.compareTo(numericOPnum2) &lt; 0)</span>
<span class="nc" id="L1261">                            numericOPresult = numericOPnum1;</span>
                        else
<span class="nc" id="L1263">                            numericOPresult = numericOPnum2;</span>
<span class="nc" id="L1264">                        break;</span>
                    case OP_MAX:
<span class="nc bnc" id="L1266" title="All 2 branches missed.">                        if (numericOPnum1.compareTo(numericOPnum2) &gt; 0)</span>
<span class="nc" id="L1267">                            numericOPresult = numericOPnum1;</span>
                        else
<span class="nc" id="L1269">                            numericOPresult = numericOPnum2;</span>
<span class="nc" id="L1270">                        break;</span>
                    default:
<span class="nc" id="L1272">                        throw new RuntimeException(&quot;Opcode switched at runtime?&quot;);</span>
                    }
                    
<span class="nc" id="L1275">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPresult, false)));</span>
<span class="nc" id="L1276">                    break;</span>
                case OP_MUL:
                case OP_DIV:
                case OP_MOD:
                case OP_LSHIFT:
                case OP_RSHIFT:
<span class="nc" id="L1282">                    throw new ScriptException(&quot;Attempted to use disabled Script Op.&quot;);</span>
                case OP_NUMEQUALVERIFY:
<span class="nc bnc" id="L1284" title="All 2 branches missed.">                    if (stack.size() &lt; 2)</span>
<span class="nc" id="L1285">                        throw new ScriptException(&quot;Attempted OP_NUMEQUALVERIFY on a stack with size &lt; 2&quot;);</span>
<span class="nc" id="L1286">                    BigInteger OPNUMEQUALVERIFYnum2 = castToBigInteger(stack.pollLast());</span>
<span class="nc" id="L1287">                    BigInteger OPNUMEQUALVERIFYnum1 = castToBigInteger(stack.pollLast());</span>
                    
<span class="nc bnc" id="L1289" title="All 2 branches missed.">                    if (!OPNUMEQUALVERIFYnum1.equals(OPNUMEQUALVERIFYnum2))</span>
<span class="nc" id="L1290">                        throw new ScriptException(&quot;OP_NUMEQUALVERIFY failed&quot;);</span>
                    break;
                case OP_WITHIN:
<span class="nc bnc" id="L1293" title="All 2 branches missed.">                    if (stack.size() &lt; 3)</span>
<span class="nc" id="L1294">                        throw new ScriptException(&quot;Attempted OP_WITHIN on a stack with size &lt; 3&quot;);</span>
<span class="nc" id="L1295">                    BigInteger OPWITHINnum3 = castToBigInteger(stack.pollLast());</span>
<span class="nc" id="L1296">                    BigInteger OPWITHINnum2 = castToBigInteger(stack.pollLast());</span>
<span class="nc" id="L1297">                    BigInteger OPWITHINnum1 = castToBigInteger(stack.pollLast());</span>
<span class="nc bnc" id="L1298" title="All 4 branches missed.">                    if (OPWITHINnum2.compareTo(OPWITHINnum1) &lt;= 0 &amp;&amp; OPWITHINnum1.compareTo(OPWITHINnum3) &lt; 0)</span>
<span class="nc" id="L1299">                        stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE, false)));</span>
                    else
<span class="nc" id="L1301">                        stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ZERO, false)));</span>
<span class="nc" id="L1302">                    break;</span>
                case OP_RIPEMD160:
<span class="nc bnc" id="L1304" title="All 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L1305">                        throw new ScriptException(&quot;Attempted OP_RIPEMD160 on an empty stack&quot;);</span>
<span class="nc" id="L1306">                    RIPEMD160Digest digest = new RIPEMD160Digest();</span>
<span class="nc" id="L1307">                    byte[] dataToHash = stack.pollLast();</span>
<span class="nc" id="L1308">                    digest.update(dataToHash, 0, dataToHash.length);</span>
<span class="nc" id="L1309">                    byte[] ripmemdHash = new byte[20];</span>
<span class="nc" id="L1310">                    digest.doFinal(ripmemdHash, 0);</span>
<span class="nc" id="L1311">                    stack.add(ripmemdHash);</span>
<span class="nc" id="L1312">                    break;</span>
                case OP_SHA1:
<span class="nc bnc" id="L1314" title="All 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L1315">                        throw new ScriptException(&quot;Attempted OP_SHA1 on an empty stack&quot;);</span>
                    try {
<span class="nc" id="L1317">                        stack.add(MessageDigest.getInstance(&quot;SHA-1&quot;).digest(stack.pollLast()));</span>
<span class="nc" id="L1318">                    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1319">                        throw new RuntimeException(e);  // Cannot happen.</span>
<span class="nc" id="L1320">                    }</span>
                    break;
                case OP_SHA256:
<span class="nc bnc" id="L1323" title="All 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L1324">                        throw new ScriptException(&quot;Attempted OP_SHA256 on an empty stack&quot;);</span>
<span class="nc" id="L1325">                    stack.add(Sha256Hash.hash(stack.pollLast()));</span>
<span class="nc" id="L1326">                    break;</span>
                case OP_HASH160:
<span class="pc bpc" id="L1328" title="1 of 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L1329">                        throw new ScriptException(&quot;Attempted OP_HASH160 on an empty stack&quot;);</span>
<span class="fc" id="L1330">                    stack.add(Utils.sha256hash160(stack.pollLast()));</span>
<span class="fc" id="L1331">                    break;</span>
                case OP_HASH256:
<span class="nc bnc" id="L1333" title="All 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L1334">                        throw new ScriptException(&quot;Attempted OP_SHA256 on an empty stack&quot;);</span>
<span class="nc" id="L1335">                    stack.add(Sha256Hash.hashTwice(stack.pollLast()));</span>
<span class="nc" id="L1336">                    break;</span>
                case OP_CODESEPARATOR:
<span class="nc" id="L1338">                    lastCodeSepLocation = chunk.getStartLocationInProgram() + 1;</span>
<span class="nc" id="L1339">                    break;</span>
                case OP_CHECKSIG:
                case OP_CHECKSIGVERIFY:
<span class="pc bpc" id="L1342" title="1 of 2 branches missed.">                    if (txContainingThis == null)</span>
<span class="nc" id="L1343">                        throw new IllegalStateException(&quot;Script attempted signature check but no tx was provided&quot;);</span>
<span class="fc" id="L1344">                    executeCheckSig(txContainingThis, (int) index, script, stack, lastCodeSepLocation, opcode, verifyFlags);</span>
<span class="fc" id="L1345">                    break;</span>
                case OP_CHECKMULTISIG:
                case OP_CHECKMULTISIGVERIFY:
<span class="nc bnc" id="L1348" title="All 2 branches missed.">                    if (txContainingThis == null)</span>
<span class="nc" id="L1349">                        throw new IllegalStateException(&quot;Script attempted signature check but no tx was provided&quot;);</span>
<span class="nc" id="L1350">                    opCount = executeMultiSig(txContainingThis, (int) index, script, stack, opCount, lastCodeSepLocation, opcode, verifyFlags);</span>
<span class="nc" id="L1351">                    break;</span>
                case OP_CHECKLOCKTIMEVERIFY:
<span class="nc bnc" id="L1353" title="All 2 branches missed.">                    if (!verifyFlags.contains(VerifyFlag.CHECKLOCKTIMEVERIFY)) {</span>
                        // not enabled; treat as a NOP2
<span class="nc bnc" id="L1355" title="All 2 branches missed.">                        if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)) {</span>
<span class="nc" id="L1356">                            throw new ScriptException(&quot;Script used a reserved opcode &quot; + opcode);</span>
                        }
                        break;
                    }
<span class="nc" id="L1360">                    executeCheckLockTimeVerify(txContainingThis, (int) index, script, stack, lastCodeSepLocation, opcode, verifyFlags);</span>
<span class="nc" id="L1361">                    break;</span>
                case OP_NOP1:
                case OP_NOP3:
                case OP_NOP4:
                case OP_NOP5:
                case OP_NOP6:
                case OP_NOP7:
                case OP_NOP8:
                case OP_NOP9:
                case OP_NOP10:
<span class="nc bnc" id="L1371" title="All 2 branches missed.">                    if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)) {</span>
<span class="nc" id="L1372">                        throw new ScriptException(&quot;Script used a reserved opcode &quot; + opcode);</span>
                    }
                    break;
                    
                default:
<span class="nc" id="L1377">                    throw new ScriptException(&quot;Script used a reserved opcode &quot; + opcode);</span>
                }
            }
            
<span class="pc bpc" id="L1381" title="2 of 4 branches missed.">            if (stack.size() + altstack.size() &gt; 1000 || stack.size() + altstack.size() &lt; 0)</span>
<span class="nc" id="L1382">                throw new ScriptException(&quot;Stack size exceeded range&quot;);</span>
<span class="fc" id="L1383">        }</span>
        
<span class="pc bpc" id="L1385" title="1 of 2 branches missed.">        if (!ifStack.isEmpty())</span>
<span class="nc" id="L1386">            throw new ScriptException(&quot;OP_IF/OP_NOTIF without OP_ENDIF&quot;);</span>
<span class="fc" id="L1387">    }</span>

    // This is more or less a direct translation of the code in Bitcoin Core
    private static void executeCheckLockTimeVerify(Transaction txContainingThis, int index, Script script, LinkedList&lt;byte[]&gt; stack,
                                        int lastCodeSepLocation, int opcode,
                                        Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
<span class="nc bnc" id="L1393" title="All 2 branches missed.">        if (stack.size() &lt; 1)</span>
<span class="nc" id="L1394">            throw new ScriptException(&quot;Attempted OP_CHECKLOCKTIMEVERIFY on a stack with size &lt; 1&quot;);</span>

        // Thus as a special case we tell CScriptNum to accept up
        // to 5-byte bignums to avoid year 2038 issue.
<span class="nc" id="L1398">        final BigInteger nLockTime = castToBigInteger(stack.getLast(), 5);</span>

<span class="nc bnc" id="L1400" title="All 2 branches missed.">        if (nLockTime.compareTo(BigInteger.ZERO) &lt; 0)</span>
<span class="nc" id="L1401">            throw new ScriptException(&quot;Negative locktime&quot;);</span>

        // There are two kinds of nLockTime, need to ensure we're comparing apples-to-apples
<span class="nc" id="L1404">        if (!(</span>
<span class="nc bnc" id="L1405" title="All 4 branches missed.">            ((txContainingThis.getLockTime() &lt;  Transaction.LOCKTIME_THRESHOLD) &amp;&amp; (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) &lt; 0) ||</span>
<span class="nc bnc" id="L1406" title="All 4 branches missed.">            ((txContainingThis.getLockTime() &gt;= Transaction.LOCKTIME_THRESHOLD) &amp;&amp; (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) &gt;= 0))</span>
        )
<span class="nc" id="L1408">            throw new ScriptException(&quot;Locktime requirement type mismatch&quot;);</span>

        // Now that we know we're comparing apples-to-apples, the
        // comparison is a simple numeric one.
<span class="nc bnc" id="L1412" title="All 2 branches missed.">        if (nLockTime.compareTo(BigInteger.valueOf(txContainingThis.getLockTime())) &gt; 0)</span>
<span class="nc" id="L1413">            throw new ScriptException(&quot;Locktime requirement not satisfied&quot;);</span>

        // Finally the nLockTime feature can be disabled and thus
        // CHECKLOCKTIMEVERIFY bypassed if every txin has been
        // finalized by setting nSequence to maxint. The
        // transaction would be allowed into the blockchain, making
        // the opcode ineffective.
        //
        // Testing if this vin is not final is sufficient to
        // prevent this condition. Alternatively we could test all
        // inputs, but testing just this input minimizes the data
        // required to prove correct CHECKLOCKTIMEVERIFY execution.
<span class="nc bnc" id="L1425" title="All 2 branches missed.">        if (!txContainingThis.getInput(index).hasSequence())</span>
<span class="nc" id="L1426">            throw new ScriptException(&quot;Transaction contains a final transaction input for a CHECKLOCKTIMEVERIFY script.&quot;);</span>
<span class="nc" id="L1427">    }</span>

    private static void executeCheckSig(Transaction txContainingThis, int index, Script script, LinkedList&lt;byte[]&gt; stack,
                                        int lastCodeSepLocation, int opcode, 
                                        Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
<span class="fc bfc" id="L1432" title="All 2 branches covered.">        final boolean requireCanonical = verifyFlags.contains(VerifyFlag.STRICTENC)</span>
<span class="pc bpc" id="L1433" title="1 of 2 branches missed.">            || verifyFlags.contains(VerifyFlag.DERSIG)</span>
<span class="pc bpc" id="L1434" title="1 of 2 branches missed.">            || verifyFlags.contains(VerifyFlag.LOW_S);</span>
<span class="fc bfc" id="L1435" title="All 2 branches covered.">        if (stack.size() &lt; 2)</span>
<span class="fc" id="L1436">            throw new ScriptException(&quot;Attempted OP_CHECKSIG(VERIFY) on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1437">        byte[] pubKey = stack.pollLast();</span>
<span class="fc" id="L1438">        byte[] sigBytes = stack.pollLast();</span>

<span class="fc" id="L1440">        byte[] prog = script.getProgram();</span>
<span class="fc" id="L1441">        byte[] connectedScript = Arrays.copyOfRange(prog, lastCodeSepLocation, prog.length);</span>

<span class="fc" id="L1443">        UnsafeByteArrayOutputStream outStream = new UnsafeByteArrayOutputStream(sigBytes.length + 1);</span>
        try {
<span class="fc" id="L1445">            writeBytes(outStream, sigBytes);</span>
<span class="nc" id="L1446">        } catch (IOException e) {</span>
<span class="nc" id="L1447">            throw new RuntimeException(e); // Cannot happen</span>
<span class="fc" id="L1448">        }</span>
<span class="fc" id="L1449">        connectedScript = removeAllInstancesOf(connectedScript, outStream.toByteArray());</span>

        // TODO: Use int for indexes everywhere, we can't have that many inputs/outputs
<span class="fc" id="L1452">        boolean sigValid = false;</span>
        try {
<span class="fc" id="L1454">            TransactionSignature sig  = TransactionSignature.decodeFromBitcoin(sigBytes, requireCanonical,</span>
<span class="fc" id="L1455">                verifyFlags.contains(VerifyFlag.LOW_S));</span>

            // TODO: Should check hash type is known
<span class="fc" id="L1458">            Sha256Hash hash = txContainingThis.hashForSignature(index, connectedScript, (byte) sig.sighashFlags);</span>
<span class="fc" id="L1459">            sigValid = ECKey.verify(hash.getBytes(), sig, pubKey);</span>
<span class="fc" id="L1460">        } catch (Exception e1) {</span>
            // There is (at least) one exception that could be hit here (EOFException, if the sig is too short)
            // Because I can't verify there aren't more, we use a very generic Exception catch

            // This RuntimeException occurs when signing as we run partial/invalid scripts to see if they need more
            // signing work to be done inside LocalTransactionSigner.signInputs.
<span class="pc bpc" id="L1466" title="1 of 2 branches missed.">            if (!e1.getMessage().contains(&quot;Reached past end of ASN.1 stream&quot;))</span>
<span class="nc" id="L1467">                log.warn(&quot;Signature checking failed!&quot;, e1);</span>
<span class="fc" id="L1468">        }</span>

<span class="pc bpc" id="L1470" title="1 of 2 branches missed.">        if (opcode == OP_CHECKSIG)</span>
<span class="fc bfc" id="L1471" title="All 2 branches covered.">            stack.add(sigValid ? new byte[] {1} : new byte[] {});</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">        else if (opcode == OP_CHECKSIGVERIFY)</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">            if (!sigValid)</span>
<span class="nc" id="L1474">                throw new ScriptException(&quot;Script failed OP_CHECKSIGVERIFY&quot;);</span>
<span class="fc" id="L1475">    }</span>

    private static int executeMultiSig(Transaction txContainingThis, int index, Script script, LinkedList&lt;byte[]&gt; stack,
                                       int opCount, int lastCodeSepLocation, int opcode, 
                                       Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
<span class="nc bnc" id="L1480" title="All 2 branches missed.">        final boolean requireCanonical = verifyFlags.contains(VerifyFlag.STRICTENC)</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">            || verifyFlags.contains(VerifyFlag.DERSIG)</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">            || verifyFlags.contains(VerifyFlag.LOW_S);</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">        if (stack.size() &lt; 2)</span>
<span class="nc" id="L1484">            throw new ScriptException(&quot;Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size &lt; 2&quot;);</span>
<span class="nc" id="L1485">        int pubKeyCount = castToBigInteger(stack.pollLast()).intValue();</span>
<span class="nc bnc" id="L1486" title="All 4 branches missed.">        if (pubKeyCount &lt; 0 || pubKeyCount &gt; 20)</span>
<span class="nc" id="L1487">            throw new ScriptException(&quot;OP_CHECKMULTISIG(VERIFY) with pubkey count out of range&quot;);</span>
<span class="nc" id="L1488">        opCount += pubKeyCount;</span>
<span class="nc bnc" id="L1489" title="All 2 branches missed.">        if (opCount &gt; 201)</span>
<span class="nc" id="L1490">            throw new ScriptException(&quot;Total op count &gt; 201 during OP_CHECKMULTISIG(VERIFY)&quot;);</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">        if (stack.size() &lt; pubKeyCount + 1)</span>
<span class="nc" id="L1492">            throw new ScriptException(&quot;Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size &lt; num_of_pubkeys + 2&quot;);</span>

<span class="nc" id="L1494">        LinkedList&lt;byte[]&gt; pubkeys = new LinkedList&lt;byte[]&gt;();</span>
<span class="nc bnc" id="L1495" title="All 2 branches missed.">        for (int i = 0; i &lt; pubKeyCount; i++) {</span>
<span class="nc" id="L1496">            byte[] pubKey = stack.pollLast();</span>
<span class="nc" id="L1497">            pubkeys.add(pubKey);</span>
        }

<span class="nc" id="L1500">        int sigCount = castToBigInteger(stack.pollLast()).intValue();</span>
<span class="nc bnc" id="L1501" title="All 4 branches missed.">        if (sigCount &lt; 0 || sigCount &gt; pubKeyCount)</span>
<span class="nc" id="L1502">            throw new ScriptException(&quot;OP_CHECKMULTISIG(VERIFY) with sig count out of range&quot;);</span>
<span class="nc bnc" id="L1503" title="All 2 branches missed.">        if (stack.size() &lt; sigCount + 1)</span>
<span class="nc" id="L1504">            throw new ScriptException(&quot;Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size &lt; num_of_pubkeys + num_of_signatures + 3&quot;);</span>

<span class="nc" id="L1506">        LinkedList&lt;byte[]&gt; sigs = new LinkedList&lt;byte[]&gt;();</span>
<span class="nc bnc" id="L1507" title="All 2 branches missed.">        for (int i = 0; i &lt; sigCount; i++) {</span>
<span class="nc" id="L1508">            byte[] sig = stack.pollLast();</span>
<span class="nc" id="L1509">            sigs.add(sig);</span>
        }

<span class="nc" id="L1512">        byte[] prog = script.getProgram();</span>
<span class="nc" id="L1513">        byte[] connectedScript = Arrays.copyOfRange(prog, lastCodeSepLocation, prog.length);</span>

<span class="nc bnc" id="L1515" title="All 2 branches missed.">        for (byte[] sig : sigs) {</span>
<span class="nc" id="L1516">            UnsafeByteArrayOutputStream outStream = new UnsafeByteArrayOutputStream(sig.length + 1);</span>
            try {
<span class="nc" id="L1518">                writeBytes(outStream, sig);</span>
<span class="nc" id="L1519">            } catch (IOException e) {</span>
<span class="nc" id="L1520">                throw new RuntimeException(e); // Cannot happen</span>
<span class="nc" id="L1521">            }</span>
<span class="nc" id="L1522">            connectedScript = removeAllInstancesOf(connectedScript, outStream.toByteArray());</span>
<span class="nc" id="L1523">        }</span>

<span class="nc" id="L1525">        boolean valid = true;</span>
<span class="nc bnc" id="L1526" title="All 2 branches missed.">        while (sigs.size() &gt; 0) {</span>
<span class="nc" id="L1527">            byte[] pubKey = pubkeys.pollFirst();</span>
            // We could reasonably move this out of the loop, but because signature verification is significantly
            // more expensive than hashing, its not a big deal.
            try {
<span class="nc" id="L1531">                TransactionSignature sig = TransactionSignature.decodeFromBitcoin(sigs.getFirst(), requireCanonical);</span>
<span class="nc" id="L1532">                Sha256Hash hash = txContainingThis.hashForSignature(index, connectedScript, (byte) sig.sighashFlags);</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">                if (ECKey.verify(hash.getBytes(), sig, pubKey))</span>
<span class="nc" id="L1534">                    sigs.pollFirst();</span>
<span class="nc" id="L1535">            } catch (Exception e) {</span>
                // There is (at least) one exception that could be hit here (EOFException, if the sig is too short)
                // Because I can't verify there aren't more, we use a very generic Exception catch
<span class="nc" id="L1538">            }</span>

<span class="nc bnc" id="L1540" title="All 2 branches missed.">            if (sigs.size() &gt; pubkeys.size()) {</span>
<span class="nc" id="L1541">                valid = false;</span>
<span class="nc" id="L1542">                break;</span>
            }
<span class="nc" id="L1544">        }</span>

        // We uselessly remove a stack object to emulate a Bitcoin Core bug.
<span class="nc" id="L1547">        byte[] nullDummy = stack.pollLast();</span>
<span class="nc bnc" id="L1548" title="All 4 branches missed.">        if (verifyFlags.contains(VerifyFlag.NULLDUMMY) &amp;&amp; nullDummy.length &gt; 0)</span>
<span class="nc" id="L1549">            throw new ScriptException(&quot;OP_CHECKMULTISIG(VERIFY) with non-null nulldummy: &quot; + Arrays.toString(nullDummy));</span>

<span class="nc bnc" id="L1551" title="All 2 branches missed.">        if (opcode == OP_CHECKMULTISIG) {</span>
<span class="nc bnc" id="L1552" title="All 2 branches missed.">            stack.add(valid ? new byte[] {1} : new byte[] {});</span>
<span class="nc bnc" id="L1553" title="All 2 branches missed.">        } else if (opcode == OP_CHECKMULTISIGVERIFY) {</span>
<span class="nc bnc" id="L1554" title="All 2 branches missed.">            if (!valid)</span>
<span class="nc" id="L1555">                throw new ScriptException(&quot;Script failed OP_CHECKMULTISIGVERIFY&quot;);</span>
        }
<span class="nc" id="L1557">        return opCount;</span>
    }

    /**
     * Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey, enabling all
     * validation rules.
     * @param txContainingThis The transaction in which this input scriptSig resides.
     *                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     * @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     * @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     * @deprecated Use {@link #correctlySpends(site.mtnsj.core.Transaction, long, site.mtnsj.script.Script, java.util.Set)}
     * instead so that verification flags do not change as new verification options
     * are added.
     */
    @Deprecated
    public void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey)
            throws ScriptException {
<span class="nc" id="L1574">        correctlySpends(txContainingThis, scriptSigIndex, scriptPubKey, ALL_VERIFY_FLAGS);</span>
<span class="nc" id="L1575">    }</span>

    /**
     * Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey.
     * @param txContainingThis The transaction in which this input scriptSig resides.
     *                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     * @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     * @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     * @param verifyFlags Each flag enables one validation rule. If in doubt, use {@link #correctlySpends(Transaction, long, Script)}
     *                    which sets all flags.
     */
    public void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey,
                                Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
        // Clone the transaction because executing the script involves editing it, and if we die, we'll leave
        // the tx half broken (also it's not so thread safe to work on it directly.
        try {
<span class="fc" id="L1591">            txContainingThis = txContainingThis.getParams().getDefaultSerializer().makeTransaction(txContainingThis.bitcoinSerialize());</span>
<span class="nc" id="L1592">        } catch (ProtocolException e) {</span>
<span class="nc" id="L1593">            throw new RuntimeException(e);   // Should not happen unless we were given a totally broken transaction.</span>
<span class="fc" id="L1594">        }</span>
<span class="pc bpc" id="L1595" title="2 of 4 branches missed.">        if (getProgram().length &gt; 10000 || scriptPubKey.getProgram().length &gt; 10000)</span>
<span class="nc" id="L1596">            throw new ScriptException(&quot;Script larger than 10,000 bytes&quot;);</span>
        
<span class="fc" id="L1598">        LinkedList&lt;byte[]&gt; stack = new LinkedList&lt;byte[]&gt;();</span>
<span class="fc" id="L1599">        LinkedList&lt;byte[]&gt; p2shStack = null;</span>
        
<span class="fc" id="L1601">        executeScript(txContainingThis, scriptSigIndex, this, stack, verifyFlags);</span>
<span class="pc bpc" id="L1602" title="1 of 2 branches missed.">        if (verifyFlags.contains(VerifyFlag.P2SH))</span>
<span class="fc" id="L1603">            p2shStack = new LinkedList&lt;byte[]&gt;(stack);</span>
<span class="fc" id="L1604">        executeScript(txContainingThis, scriptSigIndex, scriptPubKey, stack, verifyFlags);</span>
        
<span class="pc bpc" id="L1606" title="1 of 2 branches missed.">        if (stack.size() == 0)</span>
<span class="nc" id="L1607">            throw new ScriptException(&quot;Stack empty at end of script execution.&quot;);</span>
        
<span class="fc bfc" id="L1609" title="All 2 branches covered.">        if (!castToBool(stack.pollLast()))</span>
<span class="fc" id="L1610">            throw new ScriptException(&quot;Script resulted in a non-true stack: &quot; + stack);</span>

        // P2SH is pay to script hash. It means that the scriptPubKey has a special form which is a valid
        // program but it has &quot;useless&quot; form that if evaluated as a normal program always returns true.
        // Instead, miners recognize it as special based on its template - it provides a hash of the real scriptPubKey
        // and that must be provided by the input. The goal of this bizarre arrangement is twofold:
        //
        // (1) You can sum up a large, complex script (like a CHECKMULTISIG script) with an address that's the same
        //     size as a regular address. This means it doesn't overload scannable QR codes/NFC tags or become
        //     un-wieldy to copy/paste.
        // (2) It allows the working set to be smaller: nodes perform best when they can store as many unspent outputs
        //     in RAM as possible, so if the outputs are made smaller and the inputs get bigger, then it's better for
        //     overall scalability and performance.

        // TODO: Check if we can take out enforceP2SH if there's a checkpoint at the enforcement block.
<span class="pc bpc" id="L1625" title="2 of 4 branches missed.">        if (verifyFlags.contains(VerifyFlag.P2SH) &amp;&amp; scriptPubKey.isPayToScriptHash()) {</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">            for (ScriptChunk chunk : chunks)</span>
<span class="nc bnc" id="L1627" title="All 4 branches missed.">                if (chunk.isOpCode() &amp;&amp; chunk.opcode &gt; OP_16)</span>
<span class="nc" id="L1628">                    throw new ScriptException(&quot;Attempted to spend a P2SH scriptPubKey with a script that contained script ops&quot;);</span>
            
<span class="nc" id="L1630">            byte[] scriptPubKeyBytes = p2shStack.pollLast();</span>
<span class="nc" id="L1631">            Script scriptPubKeyP2SH = new Script(scriptPubKeyBytes);</span>
            
<span class="nc" id="L1633">            executeScript(txContainingThis, scriptSigIndex, scriptPubKeyP2SH, p2shStack, verifyFlags);</span>
            
<span class="nc bnc" id="L1635" title="All 2 branches missed.">            if (p2shStack.size() == 0)</span>
<span class="nc" id="L1636">                throw new ScriptException(&quot;P2SH stack empty at end of script execution.&quot;);</span>
            
<span class="nc bnc" id="L1638" title="All 2 branches missed.">            if (!castToBool(p2shStack.pollLast()))</span>
<span class="nc" id="L1639">                throw new ScriptException(&quot;P2SH script execution resulted in a non-true stack&quot;);</span>
        }
<span class="fc" id="L1641">    }</span>

    // Utility that doesn't copy for internal use
    private byte[] getQuickProgram() {
<span class="pc bpc" id="L1645" title="1 of 2 branches missed.">        if (program != null)</span>
<span class="fc" id="L1646">            return program;</span>
<span class="nc" id="L1647">        return getProgram();</span>
    }

    /**
     * Get the {@link site.mtnsj.script.Script.ScriptType}.
     * @return The script type.
     */
    public ScriptType getScriptType() {
<span class="fc" id="L1655">        ScriptType type = ScriptType.NO_TYPE;</span>
<span class="pc bpc" id="L1656" title="1 of 2 branches missed.">        if (isSentToAddress()) {</span>
<span class="nc" id="L1657">            type = ScriptType.P2PKH;</span>
<span class="fc bfc" id="L1658" title="All 2 branches covered.">        } else if (isSentToRawPubKey()) {</span>
<span class="fc" id="L1659">            type = ScriptType.PUB_KEY;</span>
<span class="pc bpc" id="L1660" title="1 of 2 branches missed.">        } else if (isPayToScriptHash()) {</span>
<span class="nc" id="L1661">            type = ScriptType.P2SH;</span>
        }
<span class="fc" id="L1663">        return type;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L1668" title="All 2 branches missed.">        if (this == o) return true;</span>
<span class="nc bnc" id="L1669" title="All 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="nc" id="L1670">        return Arrays.equals(getQuickProgram(), ((Script)o).getQuickProgram());</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1675">        return Arrays.hashCode(getQuickProgram());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>